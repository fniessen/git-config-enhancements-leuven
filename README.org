#+TITLE:     Awesome Git aliases and extra commands
#+AUTHOR:    Fabrice Niessen
#+EMAIL:     (concat "fniessen" at-sign "pirilampo.org")
#+DESCRIPTION: Pretty format for `git log' and different helpful command aliases
#+KEYWORDS:  git, log, pretty format, alias
#+LANGUAGE:  en
#+OPTIONS:   H:4 num:nil toc:nil

#+SETUPFILE: ~/org/theme-readtheorg.setup

#+EXPORT_EXCLUDE_TAGS: noexport
#+PROPERTY:  header-args :tangle .gitconfig :eval no

* Table of Contents                                                   :TOC_1_gh:
- [[#foreword][Foreword]]
- [[#overview][Overview]]
- [[#global-options][Global options]]
- [[#------------------------------------------------------------------------------][------------------------------------------------------------------------------]]
- [[#aliases][Aliases]]
- [[#repository][Repository]]
- [[#instructions][Instructions]]
- [[#source-files][Source Files]]
- [[#commits][Commits]]
- [[#branches][Branches]]
- [[#tags][Tags]]
- [[#compare-revisions-commits-branches-or-tags][Compare Revisions (commits, branches or tags)]]
- [[#releases][?Releases]]
- [[#graph][?Graph]]
- [[#contributors][?Contributors]]
- [[#pull-requests][Pull requests]]
- [[#pipelines][Pipelines]]
- [[#deployments-to-different-environments][Deployments (to different environments)]]
- [[#issues][Issues]]
- [[#wiki][Wiki]]
- [[#downloads][Downloads]]
- [[#settings][Settings]]
- [[#-------------------------------------------------------------------------------1][------------------------------------------------------------------------------]]
- [[#run-on-all-repositories][Run on All repositories]]
- [[#sort-out][Sort out]]
- [[#download-repository][Download repository]]
- [[#what-if][What if]]
- [[#if-you-made-a-mistake][If you made a mistake]]
- [[#if-you-get-errors][If you get errors...]]
- [[#github-tasks][GitHub tasks]]
- [[#references][References]]
- [[#git-clients][Git clients]]
- [[#contributing][Contributing]]
- [[#license][License]]

* Foreword

- This is Git.  It tracks collaborative work on projects through a beautiful
  distributed graph theory model.

- Cool.  How do we use it?

- No idea.  Just memorize these Shell commands and type them to sync up.  If you
  get errors, save your work elsewhere, delete the project, and download a fresh
  copy.

  If that doesn't fix it, =git.txt= contains the phone number of a friend of mine
  who understands ~git~.  Just wait through a few minutes of /'It's really pretty
  simple, just think of branches as...'/ and eventually you'll learn the
  commands that will fix everything.

From [[https://xkcd.com/1597/][xkcd]].

* Overview

The following configures interesting global settings for Git. These are stored
in the =.gitconfig= file located in the user home directory.

* Global options

** User

Setting your user name and e-mail address is important because Git stores the
committer and author of a change in every commit.

#+begin_src conf
[user]
    # Telling Git about yourself.
    name = John Doe
    email = john.doe@example.com

[github]
    user = jdoe
#+end_src

You should "override" the above with your personal details in the file
=.gitconfig_local=:

#+begin_src conf
[include]
    path = .gitconfig_local
#+end_src

** Core

#+begin_src conf
[core]
    editor = emacsclient
#+end_src

*Text viewer* for use by Git commands.

#+begin_note
When the ~LESS~ environment variable is unset, Git sets it to ~FRSX~.  If the ~LESS~
environment variable is set, Git does not change it at all.

We use ~-R~ in the command itself to be sure to *interpret the color codes* when Git
is run from /Windows/ Emacs (~C-x v l~), with /no/ value for the ~LESS~ /environment
variable/.
#+end_note

#+begin_src conf
    # git-grep to ignore ^M.
    pager = tr -d '\\r' | less -REX
#+end_src

Stop viewing non-printable characters (for example, ISO Latin 1 accents in
a UTF-8 terminal) in reverse video and hexadecimals: see ~LESSBINFMT~.

Stop viewing ~^M~ symbols in diff:

#+begin_src conf
    # whitespace = fix,-indent-with-non-tab,trailing-space,space-before-tab,cr-at-eol
    whitespace = cr-at-eol
#+end_src

Improve the ~git diff~ output: diff-so-fancy or [[https://github.com/dandavison/delta][delta]].

#+begin_src conf
    pager = diff-so-fancy | LESS= less --tabs=4 -RFX
#+end_src

(~less~ options -- ~-R~ for colors to persist, ~-F~ to exit immediately if the output
is less than one screen, and ~-X~ for not clearing the screen).

#+begin_tip
The diff-so-fancy ruler was 1 char too long.  It turned out I had an option in
~$LESS~ that enabled the status column, and thus added a space at the beginning
of every line.  I was able to resolve it by clearing the ~LESS~ environment
variable in the ~core.pager~ config.

Also, the diff-so-fancy ruler was not displayed in Unicode.  It turned out I had
set ~LC_CTYPE~ to "".  I had to either unset ~LC_CTYPE~ entirely or set it to
something with UTF-8 in it.

See https://github.com/so-fancy/diff-so-fancy/issues/364.
#+end_tip

[[https://help.github.com/en/github/using-git/configuring-git-to-handle-line-endings][GitHub suggests]] that you should make sure to only use ~\n~ (LF) as a newline
character in Git-handled repositories.

- *Checkout Windows-style, commit Unix-style line endings*

  Git will convert LF to CRLF when checking out text files.  When committing
  text files, CRLF will be converted to LF.  *For cross-platform projects*, this
  is the *recommended setting on Windows* (~core.autocrlf~ is set to ~true~) because
  it ensures that your repository can be used on other platforms while retaining
  CRLF in your working tree.

  #+begin_src conf :tangle no
      # Configure Git to ensure line endings in files you checkout are correct
      # for Windows.  For compatibility, line endings are converted to Unix
      # style when you commit files.
      autocrlf = true
  #+end_src

  This /turns all LF back into CRLF when writing out into the working tree/.

- *Checkout as-is, commit Unix-style line endings*

  Git will /not perform any conversion when checking out text files/.  When
  committing text files, CRLF will be converted to LF.  *For cross-platform
  projects*, this is the *recommended setting on Unix* (~core.autocrlf~ is set to
  ~input~) to prevent CRLF from getting written into the repository.

  #+begin_src conf :tangle no
      # Configure Git to ensure line endings in files you checkout are correct
      # for Linux and macOS.
      autocrlf = input
  #+end_src

  When you read files back out of the object database and write them into the
  working tree, they will still have LF to denote the end of line.

- *Checkout as-is, commit as-is*

  Git will not perform any conversions when checking out or committing text
  files.  Choosing this option is *not recommended for cross-platform projects*
  (~core.autocrlf~ is set to ~false~).

  #+begin_src conf :tangle no
      autocrlf = false
  #+end_src

  This is the default, but most people are encouraged to change this
  immediately.

  The result of using ~false~ is that Git doesn't ever mess with line endings on
  your file. You can check in files with LF or CRLF or CR or some random mix of
  those three and Git does not care. This can make diffs harder to read and
  merges more difficult.

#+begin_src conf :tangle no
    safecrlf = true
#+end_src

Performance:

#+begin_src conf
    # Do filesystem operations in parallel to hide latency (default since v2.1).
    preloadindex = true
#+end_src

*Enable file system caching.*  File system data will be read in bulk and cached in
memory for certain operations.  This provides a significant performance boost.

#+begin_src conf
    # Enable file system caching.  Also, fix UAC issues so you don't need to run
    # Git as administrator (default since v2.8).
    fscache = true
#+end_src

#+begin_src conf
[gc]
    # Minimize the number of files in .git/.
    auto = 256
#+end_src

** Help

#+begin_src conf
[help]
    autocorrect = 1
#+end_src

** Log

Get a better date format; for example:

: 2021-12-03 14:26:38 +0100

instead of:

: Fri Dec 3 14:26:38 2021 +0100

#+begin_src conf
[log]
    date = iso
#+end_src

** Diff

#+begin_src conf
[diff]
    renames = copies
    renameLimit = 30000
#+end_src

Using the patience diff algorithm to compare large swathes of repetitive text
(hello, xml!) often produces a much more readable diff that will reveal context
and therefore hopefully bugs/typos etc.

Here's a quick snippet of a diff to show it helping. Bare LCS-based diff:

#+begin_src diff :tangle no
 def thing1 {
     something += 1
+}
+
+def somethingelse {
+    something += 1
 }

 def thing2 {
     something += 2
 }
#+end_src

With ~patience~ becomes:

#+begin_src diff :tangle no
 def thing1 {
     something += 1
 }

+def somethingelse {
+    something += 1
+}
+
 def thing2 {
     something += 2
 }
#+end_src

Same end result but much easier to read.

#+begin_src conf
    algorithm = patience
#+end_src

Git diff will use (i)ndex, (w)ork tree, (c)ommit and (o)bject instead of a/b/c/d
as prefixes for patches:

#+begin_src conf
    mnemonicprefix = true
#+end_src

#+begin_src conf
    noprefix = true
#+end_src

#+begin_src conf
    colorMoved = dimmed_zebra
#+end_src

*** Use Meld as Git ~difftool~

#+begin_src conf
    tool = meld

[difftool]
    prompt = false

[difftool "meld"]
    cmd = meld "$LOCAL" "$REMOTE"
#+end_src

** Apply

#+begin_src conf
[apply]
    # Don't detect whitespace errors when applying a patch.
    whitespace = nowarn
#+end_src

** Fetch

Automatically delete local branches that have been removed from remote on
fetch/pull:

#+begin_src conf :tangle no
[fetch]
    prune = true
#+end_src

** Status

If you are using submodules, it might be useful to turn on the submodule summary.

#+begin_src conf
[status]
    submoduleSummary = true
#+end_src

** Pull

Git pull allows you to integrate with and fetch from another repository or local
Git branch.

Choose the default behavior of ~git pull~:

- *Default (fast-forward or merge)*

  This is the standard behavior of ~git pull~: fast-forward the current branch to
  the fetched branch when possible, otherwise create a merge commit.

  #+begin_src conf :tangle no
  [pull]
      rebase = merges
  #+end_src

- *Rebase*

  Rebase the current branch onto the fetched branch.  If there are no local
  commits to rebase, this is equivalent to a fast-forward.

  #+begin_src conf :tangle no
  [pull]
      rebase = true
  #+end_src

- *Only ever fast-forward*

  Fast-forward to the fetched branch.  Fail if that is not possible.

rebase with auto-abort
: git rebase foo || git rebase --abort

** Push

Push *only* the *current working branch* (sane pushing -- instead of pushing all
branches), with an added safety: only if it is /tracking/ a remote upstream branch
with the /same name/.

#+begin_src conf
[push]
    default = simple
#+end_src

(~simple~ is the default in Git 2.x)

** Merge

#+begin_src conf
[merge]
    stat = true
    summary = true

    # Include summaries of merged commits in newly created merge commit messages.
    log = true
#+end_src

#+begin_src conf
    conflictstyle = diff3
#+end_src

- For small changes, ~git diff~ and ~vc-diff~ are perfect.
- For medium changes, ~magit~ is perfect.
- For large changes, [[https://www.deltawalker.com/][DeltaWalker]] (39.95 USD) is perfect.

How to resolve merge conflicts in Git?  Try ~git mergetool~.

*** Emacs as a Git mergetool

Ediff or Emerge?  Or Magit???

#+begin_src conf :tangle no
[merge]
    tool = ediff

[mergetool "ediff"]
    cmd = emacsclient -c -a \"\"  --eval \"(ediff-merge-files-with-ancestor \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$BASE\\\" nil \\\"$MERGED\\\")\"
    keepBackup = false
#+end_src

*** Meld as Git mergetool

*How do I set up and use Meld as my git mergetool?*
See https://stackoverflow.com/questions/34119866/setting-up-and-using-meld-as-your-git-difftool-and-mergetool.

See ~auto-merge~ in
https://stackoverflow.com/questions/11133290/git-merging-using-meld (first and
second solution).

#+begin_src conf
    tool = meld
#+end_src

Firstly here is what the parameters mean:

- ~$LOCAL~ is the file in the *current branch* (e.g. ~master~).

- ~$REMOTE~ is the file in the *branch being merged* (e.g. ~branch_name~).

- ~$MERGED~ is the *partially merged file* with the merge conflict information in
  it.

- ~$BASE~ is the *common ancestor* of ~$LOCAL~ and ~$REMOTE~, this is to say the file as
  it was (before both changes) when the branch containing ~$REMOTE~ was originally
  created.

I suggest you use either:

#+begin_src conf :tangle no
[mergetool "meld"]
    cmd = meld "$LOCAL" "$MERGED" "$REMOTE" --output "$MERGED"
    keepBackup = false
#+end_src

or:

#+begin_src conf :tangle no
[mergetool "meld"]
    cmd = meld "$LOCAL" "$BASE" "$REMOTE" --output "$MERGED"
    keepBackup = false
#+end_src

The choice is whether to use ~$MERGED~ or ~$BASE~ in between ~$LOCAL~ and ~$REMOTE~.

Either way, Meld will display 3 panes with:

- ~$LOCAL~ in the left pane,
- ~$REMOTE~ in the right pane and
- either ~$MERGED~ or ~$BASE~ in the middle pane.

In BOTH cases, *the middle pane is the file that you should edit to resolve the
merge conflicts*.  The difference is just in which starting edit position you'd
prefer:

- ~$MERGED~ for the file which contains the partially merged file with the merge
  conflict information or

- ~$BASE~ for the shared commit ancestor of ~$LOCAL~ and ~$REMOTE~.

#+begin_note
Since both cmd lines can be useful, I keep them both in my =.gitconfig= file. Most
of the time I use the ~$MERGED~ line and the ~$BASE~ line is commented out, but the
commenting out can be swapped over if I want to use the ~$BASE~ line instead.
#+end_note

#+begin_src conf
[mergetool "meld"]
    cmd = meld --diff "$LOCAL" "$MERGED" "$REMOTE" --diff "$BASE" "$LOCAL" --diff "$BASE" "$REMOTE" --output "$MERGED"
    # cmd = meld --diff "$LOCAL" "$BASE" "$REMOTE" --diff "$BASE" "$LOCAL" --diff "$BASE" "$REMOTE" --output "$MERGED"
    keepBackup = false
#+end_src

** Rebase

Set ~rebase.stat = true~, so the ~diffstat~ output is still shown when they pull.

#+begin_src conf
[rebase]
    stat = true
#+end_src

#+begin_warning
At this point, let us remind you of [[https://git-scm.com/book/en/v2/Git-Branching-Rebasing#The-Perils-of-Rebasing][the perils of rebasing]].
#+end_warning

** Grep

https://git-scm.com/docs/git-grep

#+begin_src conf
[grep]
    lineNumber = true

    # # Allow extended regular expressions
    # extendedRegexp = true

    fullName = true
#+end_src

** Color

Enable colors in terminal:

#+begin_src conf
[color]
    ui = auto
    branch = auto
    diff = auto
    status = auto
    interactive = auto
#+end_src

*** Branch

#+begin_src conf
[color "branch"]
    current = cyan bold
    local = green bold
    remote = red bold
    upstream = red bold
    plain = yellow reverse
#+end_src

*** Diff

See http://git-scm.com/docs/git-config for the ~slot~ list.

#+begin_src conf
[color "diff"]
    plain = "#888888"
    meta = 11
    frag = magenta bold
    func = "#cc99cc"
    old = red bold
    new = green bold
    commit = yellow bold
    whitespace = red reverse
#+end_src

#+begin_src conf
[diff-so-fancy]
    useUnicodeRuler = true

[color "diff-highlight"]
    oldNormal = red bold
    oldHighlight = red bold 52
    newNormal = green bold
    newHighlight = green bold 22
#+end_src

*** Status

#+begin_src conf
[color "status"]
    header = normal
    added = green bold
    changed = yellow bold
    untracked = cyan
    branch = cyan bold
    nobranch = bold ul blink 12
    unmerged = red reverse bold
#+end_src

- added = modified
- changed = updated

*** Grep

The first color given is the foreground; the second is the background.", e.g
~match 10 22~ -- see ~man 1 git-config~ at "CONFIGURATION FILE" > "Values" >
"color".

#+begin_src conf
[color "grep"]
    context = "#888888"
    filename = yellow bold
    function = red
    linenumber = magenta bold
    match = green reverse bold
    matchContext = yellow reverse bold
    matchSelected = yellow bold blue
    separator = red bold
    selected = white
#+end_src

** Proxy

#+begin_src conf :tangle no
[http]
    proxy = http://proxy-guest.example.com:8080
#+end_src

** Repository administration

The error (when cloning, pulling or pushing)

: SSL certificate problem: Unable to get local issuer certificate

occurs when a *self-signed certificate cannot be verified*.

- For a one-time fix, you can use the ~env~ command to create an environment
  variable of ~GIT_SSL_NO_VERIFY=TRUE~:

  #+begin_src shell :tangle no
  env GIT_SSL_NO_VERIFY=TRUE git COMMAND ARGUMENTS
  #+end_src

- If you don't want to do this all the time, you can disable Git SSL
  verification:

  #+begin_src conf :tangle no
  [http]
      sslVerify = false
  #+end_src

#+begin_warning
Please be advised disabling SSL verification globally *might be considered
a security risk* and should be implemented only temporary.
#+end_warning

** Format

#+begin_src conf
[format]
    pretty = format:%C(green)%ad%C(reset) %C(yellow)%h%C(auto)%d%C(reset) %s %C(bold blue)<%an>%C(reset)

# https://dev.to/megamattmiller/the-git-aliases-that-get-me-to-friday-1cmj
[custom.formats]
    ls   = "[%C(auto,yellow)%<|(10)%h%C(reset)] [%C(auto,bold blue)%<(15trunc)%cn%C(reset)]  %C(auto)%d% C(reset)%s"
    find = "[%C(yellow)%<|(20)%h%C(reset)] [%C(bold blue)%<(10)%cn%C(reset)]  %C(auto)%d %C(reset)  %s"
    graph="%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset) %C(bold yellow)%d%C(reset)%n %C(white)%s%C(reset)%n %C(dim white)- %an <%ae> %C(reset) %C(dim white)(committer: %cn <%ce>)%C(reset)"
#+end_src

See
- https://devhints.io/git-log-format and
- https://git-scm.com/docs/pretty-formats (XXX)

* ------------------------------------------------------------------------------

* Aliases

If you forget your aliases and don't want to open =.gitconfig= just to check, type
~git alias~.

#+begin_src conf
[alias]

    # Usage: git alias
    # Print the list of Git aliases.
    alias = "!git config -l | grep alias | cut -c 7- | sort | sed 's/=/ = /'"
#+end_src

* Repository

For *free private repositories*, see https://bitbucket.org/.

** Create a local Git repository

Set email addresses for you:

#+begin_src conf
    workprofile = config user.email \"john@work.com\"
#+end_src

Then, in the working copy:

#+begin_src conf
    create-local-repository = !git init \
                && ( [ -n "$(ls)" ] || touch .gitignore ) \
                && git add . \
                && git commit -m \"Initial commit\"
#+end_src

#+begin_tip
Since Git doesn't add *empty directories*, if you want to keep them in the
repository, a sort of conventional hack is to create a file called =.gitkeep= in
these directories.  (The file could be called anything; Git assigns no special
significance to this name.)
#+end_tip

Remove Git from current project:

#+begin_src conf :tangle no
find . -name '.git' -exec rm -rf {} \;
#+end_src

** Clone a repository

#+begin_src conf
    # Proxy.
    set-proxy = !git config --global http.proxy http://proxy-guest.example.com:8080 \
                && git config --global https.proxy https://proxy-guest.example.com:8080
    rmv-proxy = !git config --global --unset http.proxy \
                && git config --global --unset https.proxy
#+end_src

Clone an existing repository including all submodules.

#+begin_src conf
    cl = clone --recursive
#+end_src

#+begin_tip
For *passwordless Git pull* (permanently authenticating with Git repositories),
1. *use SSH* when cloning, and
2. *add* your *public key* to the remote server.
#+end_tip

** Create and add your SSH public key to a repository hosting service

https://docs.gitlab.com/ee/gitlab-basics/create-your-ssh-keys.html

It is best practice to use Git over SSH (instead of Git over HTTP).  In order to
use SSH, you will need to:

*** Create an SSH key pair on your local computer

Generate a new ED25519 (should always be favored) SSH key pair:

: ssh-keygen -t ed25519 -C "email@example.com"

Or, if you want to use RSA:

: ssh-keygen -t rsa -b 4096 -C "email@example.com"

*** Add the key to the repository hosting service

*** Testing that everything is set up correctly

** Create a new repository in GitHub

*Private* or *public* repository?

#+begin_src conf :tangle no
    create-repository-gh = "!f() { \
            REPO_OWNER=$1; \
            REPO_SLUG=$2; \
            curl -u \"$1\" https://api.github.com/user/repos -d \"{\"name\":\"$2\"}\"; \
        }; f"
#+end_src

Fetch URL: git@bitbucket.org-something:user/slug

#+begin_src conf
    # origin = !echo "${$(git config clone.defaultRemoteName):-origin}"
    origin = !echo "origin"

    repo-owner = "!f() { \
            git remote show $(git origin) -n \
                | grep 'Fetch URL:' \
                | sed -E 's#^.*[/:](.*)/.*$#\\1#' \
                | sed 's#.git$##'; \
        }; f"
#+end_src

#+begin_src conf
    repo-slug = "!f() { \
            git remote show $(git origin) -n \
                | grep 'Fetch URL:' \
                | sed -E 's#^.*/(.*)$#\\1#' \
                | sed 's#.git$##'; \
        }; f"
#+end_src

# Updating git aliases for different *default branch* names (~master~, ~main~, etc.):
#
# #+begin_src conf
#     ## git remote show $(git origin) | grep "HEAD branch" | cut -d' ' -f5
#     default-branch = !git symbolic-ref refs/remotes/$(git origin)/HEAD | sed 's@^refs/remotes/$(git origin)/@@'
# #+end_src
#
# This method can return incorrect results...

: git branch | grep -o -m1 "\b\(master\|main\)\b"
See https://stackoverflow.com/questions/65703168/how-to-get-the-default-for-the-master-branch-in-git

#+begin_tip
The ~sed~ strings contain ~$#~, which will be replaced by the number of arguments to
the current script/function (generally 0 for an interactive shell).  This is
part of the basic Bourne shell syntax, so *single quotes* will be needed under any
*Bourne-like shell* (even pre-POSIX ones) on any OS.  Read the standard for more
information:
https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html.
#+end_tip

* Instructions

Start working with your repository.

** Create a README

Create a =README.md= file into your repository.

#+begin_src conf :tangle no
echo "# ${$(git repo-slug):-Repository name}\n\nDescription" >> README.md
git add README.md
git commit -m "Add README.md"

git push -u $(git origin) master
#+end_src

** Create a .gitignore

You can also create a =.gitignore= file into your repository.

* Source Files

** Search for files

Search files (by file path) in the current branch.

#+begin_src conf
    # Usage: git search-for-files PATTERN
    # List files matching the pattern.
    search-for-files = !git ls-tree -r --name-only HEAD | grep -i --color=auto

    find-files = !git search-for-files
#+end_src

Search files in all branches.

#+begin_src conf
    search-for-files-all = "!f() { \
            for BRANCH in $(git for-each-ref --format=\"%(refname)\" refs/heads); do \
                printf \"\n$(tput bold)$BRANCH:$(tput sgr0)\n\"; \
                git ls-tree -r --name-only $BRANCH | nl -bn -w3 | grep --color=auto \"$1\"; \
            done; \
        }; f"

    find-files-all = !git search-for-files-all
#+end_src

** Search for code

*Code search* looks through all lines of code of all the files (by the *file
contents*) from the current directory (and its subdirectories).

https://confluence.atlassian.com/bitbucketserver/search-for-code-in-bitbucket-server-814204781.html
https://help.github.com/en/github/searching-for-information-on-github/searching-code

*** Search code for exact matches

#+begin_src conf
    search-for-code = "grep -i --line-number --break --heading -C 1"

# ack = '-c color.grep.linenumber="bold yellow"
#     -c color.grep.filename="bold green"
#     -c color.grep.match="reverse yellow"
#     grep --break --heading --line-number'
#+end_src

Find all instances of the specified string in code files *with a certain file
extension*.

#+begin_src conf
    search-for-code-in-extension = "XXX"
#+end_src

Find all instances of the specified string in code *in the specified path*.

#+begin_src conf
    search-for-code-in-path = "XXX"
#+end_src

*** Pattern in current directory (and its subdirectories)

The advantages of ~git grep~ are not only its *speed*, and the fact it only searches
your project files (i.e. no files in =.git=), but also that is allows you to
interface with your repository's Git database; for example, for searching:

- files registered in the index, rather than the working tree,
- for your regexp in some files from another branch (XXX does not work? XXX).

#+begin_note
It doesn't search files that are not revisioned (untracked, excluded/ignored,
etc.).
#+end_note

Example:

: git grep "foo" -- '*.java'

More readable output, *with grouping* (like Ripgrep, ~rg~, or ~ack~):

#+begin_src conf
    # In all commits, not in all branches!!! Lots of duplicates!!!
    grep-all = "!f() { \
            git rev-list --all \
                | xargs git grep $1; \
        }; f"
#+end_src

Broader search (*case-sensitive*), output *without grouping*:

#+begin_src conf
    # `-I' = Don't match the pattern in binary files.
    g = "grep -I"

    # Name only.
    gno = "grep -I --files-with-matches"
#+end_src

*** Find files that contain multiple terms, not necessarily on the same line

Match any of these patterns, but print matches only from files that have /all/ of
them (files must have lines that match each of them):

: git grep --all-match -e REGEXP -e REGEXP

See also https://askubuntu.com/questions/1019678/find-multiple-word-patterns-in-files

** Undo local changes

See https://docs.gitlab.com/ee/topics/git/numerous_undo_possibilities_in_git/
and http://gitimmersion.com/lab_14.html.

**** Before you staged (in unstaged state)

*Undo* the local changes *in the working tree*: roll a file back to its last
committed version, removing all the changes detected by Git.

#+begin_tip
It can also recover *deleted files* -- if the deletion has not been committed.
#+end_tip

If you decide that the changes you have made since the last commit ought to be
thrown away, the alias to use is ~unmodify~;

#+begin_src conf
    # Usage: git unmodify TREE_ISH
    # Undo local changes in the working copy at or within TREE_ISH.
    unmodify = checkout --
    undelete = checkout --
#+end_src

#+begin_note
The two dashes there (~--~, canonically called the "bare double dashes" or the /end
of options/ character) ensure that the checkout command know that we are trying
to roll back a file and not /change branches/ (the typical usage of the checkout
command).
#+end_note

When you grab a file from a previous time, it sits *in your index*, modified.

**** Before you committed (in staged state)

*Remove* the specified *files from the index* (= staging area, to be included in the
next commit):

#+begin_src conf
    unstage = reset HEAD --
    unadd = reset HEAD --
#+end_src

~unstage~ is the opposite of ~git add~.  It lets you remove items from the staging
area.  This makes it a very useful tool when you're deciding which files to
stage for a commit.  If you've accidentally added something to the staging area,
just use ~unstage~ to remove it.

* Commits

** Create a commit

#+begin_src conf
    # Shortcut for commit.
    ci = commit
#+end_src

A guide on commit messages:
https://dev.to/yvonnickfrin/a-guide-on-commit-messages-d8n

A useful template for good commit messages (see
https://medium.com/compass-true-north/writing-good-commit-messages-fc33af9d6321):

Implementing a Strong Code-Review Culture
https://www.youtube.com/watch?v=PJjmw9TRB7s

#+begin_src text :tangle .git_commit_template.txt
# |<------   50-character subject line   ------->|<------------------->|
# If applied, this commit will...
# [Add / Fix / Remove / Update / Refactor / Document] [summary]


# |<-----   Optional 72-character wrapped extended description   ----->|
# This should answer:
# - Why is this change necessary?  (goals, use cases, stories, etc.?)
# - How does this change address the issue?  (implementations, algorithms, etc.?)
# - What side effects does this change have?


# Include a link to the ticket, if any.
# Closes #ISSUE_NUMBER


# --- COMMIT END ---
# Emoji can be
#    :star:              Add new feature ...
#    :bug:               Fix bug ...
#    :x:                 Remove ...
#    :hammer_and_wrench: Update ...
#    :recycle:           Refactor code ...
#+end_src

# https://dev.to/sublimegeek/semantic-commit-messages-with-emojis-3p8h
# https://gist.github.com/rxaviers/7360908
# https://www.webfx.com/tools/emoji-cheat-sheet/

# https://gist.github.com/zakkak/7e06725ebd1336bfebebe254de3de825

# https://help.github.com/en/github/managing-your-work-on-github/closing-issues-using-keywords
# https://confluence.atlassian.com/bitbucket/resolve-issues-automatically-when-users-push-code-221451126.html
# https://docs.gitlab.com/ee/user/project/issues/managing_issues.html#default-closing-pattern

and you'll be guided into writing concise commit subjects in the imperative
mood -- a good practice. See rule 5 of Chris Beam's "How to write a commit
message" for the inspiration of this tip and more reasoning on the use of the
imperative mood.

You can automatically *close an issue* by using a supported keyword in commit
message, such as ~Closes #10~.  (You should always include the ~#~ if you want to
ensure that links back to the issue resolve.)

For a list of supported keywords, see:
- https://docs.github.com/en/free-pro-team@latest/github/managing-your-work-on-github/linking-a-pull-request-to-an-issue#linking-a-pull-request-to-an-issue-using-a-keyword
- https://support.atlassian.com/bitbucket-cloud/docs/resolve-issues-automatically-when-users-push-code/

See also https://gitlab.com/emacs-stuff/git-commit-insert-issue for better Emacs
support.

#+begin_src conf
[commit]
    template = ~/.git_commit_template.txt
#+end_src

This is a handy table for labels [[https://github.com/angular/angular/blob/master/CONTRIBUTING.md][Angular's commit standards and guidelines]]:

| Label    | Description                                                                                            |
|----------+--------------------------------------------------------------------------------------------------------|
| feat     | A new feature                                                                                          |
| fix      | A bug fix                                                                                              |
| style    | Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc) |
| refactor | A code change that neither fixes a bug nor adds a feature                                              |
| perf     | A code change that improves performance                                                                |
| test     | Adding missing or correcting existing tests                                                            |
| chore    | Changes to the build process or auxiliary tools and libraries such as documentation generation         |
| doc      | Documentation only changes                                                                             |

** Get a commit hash

#+begin_src conf
[alias]

    # Usage: git commit-hash [COMMIT_ISH]
    # Examples:
    #   git commit-hash               find hash of last commit
    #   git commit-hash develop       find hash of last commit in develop
    commit-hash = log -1 --pretty=format:'%h'
#+end_src

** Get a commit detail

List all the changed files *in a commit* (also in a /merge commit/):

#+begin_src conf
    # Usage: git changed-files [COMMIT]
    # Examples:
    #   git changed-files             list files modified in last commit
    #   git changed-files bada55      list files modified in this commit
    changed-files = show --pretty="format:" --name-only -m
#+end_src

** Get the diff of a commit

#+begin_src conf
    download-email-patch = XXX git format-patch $(git current-branch).patch
    download-plain-diff = !git diff ${1:-HEAD}~ ${1:-HEAD} > ${1:-HEAD}.diff
#+end_src

** Diff

Use a generic rev syntax (rev-parse) to transparently allow complex rev
expressions.

#+begin_src conf
    showtool = "!f() { \
            REV=$(git rev-parse \"${*:-HEAD}\"); \
            git difftool $REV~1 $REV; \
        }; f"
#+end_src

This allows doing nice things like:

: git showtool :/some nasty bug

Diff the last commit for a given file:

#+begin_src conf
    diff-file-last-commit = "!f() { \
            PROJECT_ROOT_DIR=$(git root); \
            echo finding full file path of $1 in $PROJECT_ROOT_DIR; \
            FILEPATH=$(find $PROJECT_ROOT_DIR -type f -name $1); \
            echo full file path $FILEPATH; \
            LAST_MODIFIED_COMMIT_HASH=$(git rev-list -1 HEAD $FILEPATH); \
            echo last commit file modified $LAST_MODIFIED_COMMIT_HASH; \
            git difftool $LAST_MODIFIED_COMMIT_HASH^ $FILEPATH; \
        }; f"
#+end_src

Usage (no matter where you are in the repo):

: git diff-file-last-commit File.cpp

This opens your configured ~difftool~ with the changes to =File.cpp= in the last
commit it was touched.

*** Performing directory diffs (Comparing folders)

The following command makes it similar to the =git-meld.pl= script here:
https://github.com/wmanley/git-meld:

#+begin_src conf
    diffall = difftool -t meld --dir-diff
#+end_src

** Get the references the commit has been pushed to (which branches and tags?)

List all the *branches and tags* that contain a specific commit.

#+begin_src conf
    # Usage: git where REV
    # Print only refs which contain the commit.
    where = for-each-ref --format='%(refname)' --contains
    where2 = "!f() { \
            git for-each-ref --format='%(committerdate:iso) %09 %(authorname) %09 %(refname:short)' --contains $1 \
                | sort -r; \
        }; f"
#+end_src

XXX See also git-ls-object-refs

Filter the list of *branches* to only those which have the given *commit ID* among
their ancestors.

#+begin_src conf
    # Find branches containing commit.
    branches-that-contain = branch -a --contains
#+end_src

This also includes *remote tracking branches* in the list, that is "local
branches that have a direct relationship to a remote branch".

List all *tags* that contain a specific commit ID:

#+begin_src conf
    # Find tags containing commit.
    tags-that-contain = "!f() { \
            git tag -l --contains $1 \
                | sort -r; \
        }; f"
#+end_src

** Check if one commit is an ancestor of another

#+begin_src sh :tangle bin/git-is-ancestor
#!/usr/bin/env bash

#? git-is-ancestor , Time-stamp: <2021-10-22 Fri 16:15>
#? Copyright (C) 2021 Fabrice Niessen
#?
#? License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
#? This is free software: you are free to change and redistribute it.
#? There is NO WARRANTY, to the extent permitted by law.

##? Usage: git-is-ancestor [options] COMMIT_1 COMMIT_2
##?
##? Check if one commit is an ancestor of another.
##?
##? Arguments:
##?   COMMIT_1                      commit (or tag) 1
##?   COMMIT_2                      commit (or tag) 2
##?
##? Options:
##?   -h, --help                    display this help and exit
##?   -V, --version                 display version information and exit
##?
##? Example:
##?   git-is-ancestor 71031cec HEAD determine if current branch contains the commit

command -v docopts > /dev/null 2>&1 || { echo >&2 "docopts not found"; exit 2; }
help=$(grep "^##?" "$0" | cut -c 5-)
version=$(grep "^#?"  "$0" | cut -c 4-)
parsed="$(docopts -h "$help" -V "$version" : "$@")"
eval "$parsed"

if $(git merge-base --is-ancestor $COMMIT_1 $COMMIT_2); then
    echo "$COMMIT_1 is an ancestor of $COMMIT_2"
    exit 0
elif $(git merge-base --is-ancestor $COMMIT_2 $COMMIT_1); then
    echo "$COMMIT_2 is an ancestor of $COMMIT_1"
    exit 0
else
    echo "$COMMIT_1 and $COMMIT_2 are not related"
    exit 1
fi
#+end_src

#+begin_src conf
    # Usage: git is-ancestor COMMIT_1 COMMIT_2
    # Check if one commit is an ancestor of another.
    is-ancestor = !$HOME/bin/git-is-ancestor
#+end_src

** Search for commits

#+begin_note
Just for the record -- searching anything "in a branch" is not possible due to
the principle of branches.  Branch is only a pointer to a single commit, which
is considered to be "the last commit of the branch", and commits itself do not
"belong to a branch" anyhow else.

Therefore, Git cannot determine "which branch was which" before merge commits.
#+end_note

: curl --request GET --header "PRIVATE-TOKEN: YOUR_ACCESS_TOKEN" https://gitlab.example.com/api/v4/search?scope=commits&search=bye
: curl --request GET --header "PRIVATE-TOKEN: YOUR_ACCESS_TOKEN" https://gitlab.example.com/api/v4/groups/3/search?scope=issues&search=file

*** Search within Commit Messages

You can find commits that contain particular words in the commit message. For
example, ~fix typo~ matches commits containing the words ~fix~ *and* ~typo~.

If you want to find all commits (*across all branches*, showing names and status
of changed files) where *log message* matches a specified pattern (regular
expression), use ~find~.

#+begin_src conf
    findc1 = "log --decorate -i --all --date=short --grep"
    findc2 = "!f() { \
            git log --decorate --grep=$1 -i --all --date=short; \
        }; f"
#+end_src

#+begin_tip
If you only add options to one single ~git~ command, there is no benefit to the
function wrapper.  On the contrary, you can't add other options.
#+end_tip

#+begin_src conf
    # Search for commits (Filter by commit message).
    search-for-commits = "!f() { \
            STR=\"git log --all-match\"; \
            for VAR in \"$@\"; do \
                str=\"$STR --grep '$VAR'\"; \
            done; \
            eval $STR; \
        }; f"
#+end_src

#+begin_src conf :tangle no
curl -H "Accept: application/vnd.github.cloak-preview" \
    https://api.github.com/search/commits\?q\=repo:fniessen/org-html-themes+local+css \
    | jq '.items[] | {commit}'
#+end_src

Here's the alias which simply loops over each argument and calls ~git
log --grep~. Equivalent of calling ~git log --grep A --grep B --grep C ...~:

#+begin_src conf
    search = "!f() { \
            for l in \"$@\"; do \
                git log --grep \"$l\"; \
            done; \
        }; f"
# XXX Add i, all, date short...
#+end_src



You may want to add history to search through the whole repository, by adding
rev-list to your git log:

#+begin_src conf
    search2 = "!f() { \
            git log --grep \"$1\" $(git rev-list --all); \
        }; f"
#+end_src

Add ~--name-status~ to show only names and status of *changed files*.

To find commits that match *either* of patterns (implicit *OR* semantic), you can
use:

: git log --grep=FOO --grep=BAR

To find /commit/ that has *both* line matching first and line matching second
somewhere, use the *AND* semantic:

: git log --all-match --grep=FOO --grep=BAR

Show the *last commit* whose *message matches a regexp*:

: # Show the LATEST commit which has the text "fix: font" in its message.
: git log :/"fix: font"
: git show :/"fix: font"
:
: # Show the LATEST merge commit.
: git show :/^Merge

*** Search by Author

#+begin_src conf
    # Usage: git search-for-author [PATTERN]
    # Show the log for an author (or my own user email).
    search-for-author = "!f() { \
            git log --decorate -i --no-merges --all --date=short --author=${1-$(git config user.email)}; \
        }; f"
#+end_src

*** Search on File Changes

**** Search string (added/removed) in code

If you want to find all commits where a *string* was *added or removed* in the /file
contents/ (to be more exact: where its *number of occurrences changed* in the
source file), i.e. search the /commit contents/, use ~-S~.

You can dig up commits that have, for example,
- removed calls to a specific function, or
- added a certain CSS classname.

#+begin_warning
If the number of times "foo" appears in the file is the same before and after
a commit, it will not match using ~-S "foo"~.
#+end_warning

In other words, to find the following commit:

#+begin_src diff :tangle no
@@ -4211,9 +4211,10 @@ public class MovesHandler extends EventHandlerBase {
      */

     private boolean actionsNotCompleted(final EventHandlerContext context, final String mo_id) {
         final Object found_mo_id =
                 selectDbValue(context, "activity_log", "activity_log_id", "mo_id=" + mo_id
-                    + " AND status NOT IN ('COMPLETED-V','REJECTED','CANCELLED')");
+                    + " AND status NOT IN ('COMPLETED-V','CLOSED','REJECTED','CANCELLED')");
         return (found_mo_id != null);
     }
#+end_src

you *need to search on 'CLOSED'*.  Searching on 'COMPLETED-V' would not bring back
that commit!

: git log --all -S "foo" --since="1 week ago"

#+begin_src conf
    whatwhen = log --decorate --date=short -p -S
#+end_src

Prettier ~whatchanged~ with full diffs based on text search:

#+begin_src conf
    # Find commits by source code.
    search-for-commits-contents = "!f() { \
            git log --decorate --date=short -S $1; \
        }; f"
# XXX Does not work for strings with spaces in them...
#+end_src

#+begin_src conf
    grep4d = !sh -c 'git log -p -S'$1' $2' -
# Not the best example, but: git grep4d CLOSED '*.java'
#+end_src

By default, ~-S~ accepts a string, but can be modified to accept a *regexp* with
~--pickaxe-regex~.

**** Search regexp (added/removed/changed?) in code

String contained in added/removed lines from Commit contents (Diff)

With the ~-G~ option, the commit is shown in the log if your *regexp* search matches
any *line* that was added, removed, or changed.

: git log --all -G "foo" --since="1 week ago"
: git log --all -G "foo" --full-history --since="1 week ago"

*** How to find all the commits made only on a specific branch

Assuming that your branch was created off of ~develop~, then /while in the branch/
(that is, you have the branch checked out):

: git log --no-merges --graph develop..

** Open a repository in a web browser

#+begin_src conf
    browse-commits = "!f() { \
            URL=$(git config --get remote.$(git origin).url); \
            cygstart ${URL/.git}/commits; \
        }; f"
#+end_src

For Cygwin:

: alias open='cygstart'

** Push

** Undo changes (Oh Shit, Git!?!)

See also:
- https://ohshitgit.com/
- https://i.pinimg.com/originals/5b/af/1b/5baf1bab9f2285b4d9df6e9a959411e9.png
- https://docs.gitlab.com/ee/topics/git/numerous_undo_possibilities_in_git/
- http://gitimmersion.com/lab_16.html

*** Undo local changes which were not pushed to remote repository (after you committed)

*** Undo changes after they are pushed to remote repository

**** Without history modification (preferred way)

git revert?

**** With history modification (requires coordination with team and force pushes)

*** Remove sensitive data from a repository

If you commit sensitive data, such as a password or SSH key into a Git
repository, you can remove it from the history. To entirely remove unwanted
files from a repository's history you can use:
- either the ~git filter-branch~ command
- or the BFG Repo-Cleaner open source tool.

** REVERT - Undo mistakes

*** Change your last commit

This will help when we need to change the most recent commit.

#+begin_warning
~git commit --amend~ is a dangerous operation.  Someone might forget that the
current commit has already been pushed, and amend it anyway.  What will they do
then?

Try to push the result, see a message about non-fast-forward pushes being not
allowed, then go along the "If pushing fails" section (pull, resolve, commit,
push), and we'll have two similar commits in the history.
#+end_warning

#+begin_verse
The key to understanding that is that Git does not rewrite history, it creates
new history and calls that reality.  The commits in this history have different
IDs (because the ID is the content plus the ID of its parent, changing just one
commit means everything after it must change).  If you push this new history
(with --force) everyone else will have the old divergent history.  All their
work will be on top of this divergent history.  They have to do the surgery to
put their work on your new history.

When users do a "git pull", git doesn't store that you did a rebase (it would be
nice if it did) so it assumes something has gone wrong and refuses to pull.  Git
gets a human to look at the divergence and decide what to do with it.
Unfortunately, most people don't know what to do with a divergent repository.

And yes, this applies to amended commits.

This is a common question answered on Stack Overflow.
https://stackoverflow.com/questions/8939977/git-push-rejected-after-feature-branch-rebase

This answer isn't specifically about rebase, but it illustrates how Git creates
new history.
https://stackoverflow.com/questions/27692954/change-mail-address-in-each-commit/27709938#27709938
#+end_verse

Modify the *last* commit, amending with the same message -- without your editor
prompting you for the message you've already entered!

#+begin_src conf
    # Append your staged changes to the LATEST commit (keeping the pre-existing
    # commit message).
    recommit = commit -v --amend --reuse-message HEAD
#+end_src

Oh, you made a typo!

#+begin_src conf
    # Usage: git reword MSG
    # Change LATEST commit message to what you type in.
    reword = commit --amend -m
#+end_src

or use:

: git commit --amend

to open your commit editor and reword the message.

#+begin_src conf
    # Usage: git credit AUTHOR_NAME AUTHOR_EMAIL
    # Credit an author on the LATEST commit.
    credit = "!f() { git commit --amend --author=\"$1 <$2>\" --reuse-message HEAD; }; f"
#+end_src

After discovering these options, I find I am less fearful of making premature
commits, since they are easily fixed. (But not after pushing, of course.)

#+begin_warning
*NEVER AMEND a commit* that you've *ALREADY PUSHED* to a remote repository.
https://stackoverflow.com/questions/17176859/amending-a-pushed-commit-message
#+end_warning

Solution for *amending older commits*:
https://stackoverflow.com/questions/3042437/change-commit-author-at-one-specific-commit
(see 1st and 2nd answers!)

My new favorite alias lets you amend to a specific commit, *no* need to be the
*latest* one.

#+begin_src conf
    fixup2 = "!f() { TARGET=$(git rev-parse \"$1\"); \
                     git commit --fixup=$TARGET ${@:2} \
                         && GIT_EDITOR=true git rebase --interactive --autostash --autosquash $TARGET~; }; f"
    # See https://blog.filippo.io/git-fixup-amending-an-older-commit/

    # Checkout the commit in question, and amend its message.
    reword2 = "!f() { BRANCH=$(git current-branch); \
                      git checkout $1; \
                      git commit --amend; \
                      git checkout $BRANCH; }; f"
#+end_src

*** Undo changes to one (or more) file(s) in a commit -- instead of reverting the entire commit

: git show COMMIT-HASH -- path/to/file.html | git apply --reverse

*** Throw away a commit

http://www.vogella.com/tutorials/Git/article.html#resetcommits
http://git-scm.com/book/en/v2/Git-Tools-Reset-Demystified
http://git-scm.com/2011/07/11/reset.html

~git reset~ is a simple way to undo changes that haven't been shared with anyone
else.

See « Undo 'git add' before commit ».

**** Soft option -- Do not touch the index file or the working tree at all

#+begin_src conf
    # Remove the last commit.
    uncommit = reset --soft HEAD~1
#+end_src

If you make a commit and really didn't mean to, use the ~uncommit~ alias to undo
it like this:

: git uncommit

~uncommit~ *undoes the last commit*, and *puts the changes* in the commit *into your
index* -- leaving the content of your working tree exactly as it is.  It's like
going back in time to the moment right before you committed.

That's really handy if you make a commit and accidently provide the wrong commit
message. For example:

: git commit -m "Fix bug #11"
: (damn - wrong bug number)
: git uncommit
: git commit -m "Fix bug #1"

#+begin_note
~uncommit~ here means to do just the reverse of ~commit~.
#+end_note

This can be a useful technique in resuming work on an unfinished changeset.

**** Mixed option -- Do not touch the working tree (but regenerate the index)

Reset the previous commit, but *puts* all *the changes* from that commit *in the
working tree*:

#+begin_src conf
    uncommit-unstage = reset --mixed HEAD~1
#+end_src

#+begin_note
~--mixed~ with paths is deprecated; use ~git reset -- <paths>~ instead.
#+end_note

This is a useful technique if your pull fails to merge the new stuff from
upstream: ~git reset HEAD~1~, pull again, fix the conflicts, then commit your
changes again.

This can also be a useful technique to slice a single big commit to different
small commits to haste review process.

**** Hard option -- Regenerate both the index and working tree

Remove the last commit, *delete changes in your staging area and in your working
directory*:

#+begin_src conf
    # Erase any changes since your last commit (reset every file in your working
    # directory to its committed state).
    # Destroy the changes from the commit you want to undo.
    undo = reset --hard HEAD~1
    # Delete last commit.
#+end_src

If you reset work that you /never committed/, it is gone for good.  Too bad!  This
is quite a dangerous command (~git reset --hard~ is one of the few Git commands
which deletes information with no backout), and must be used with *EXTREME
CAUTION*.

#+begin_warning
This command will *overwrite all CHANGED tracked files* in the working tree!
(/Untracked files/ are out of scope.)
#+end_warning

#+begin_tip
If you have changes in your working tree or staging area, you'll probably want
to stash them before doing the above.
#+end_tip

#+begin_note
See the functionality of the partly overlapping ~git checkout .~ command (note
that it will only erase all your unstaged changes: the *files in your staging
index will be untouched*), by comparing [[https://wiki.mozilla.org/Cjku/git#git-reset_and_git-checkout][git reset and git checkout]].
#+end_note

Use ~git reset --hard @{u}~ to make sure the integration branch is up-to-date
before merging.

Other scenarios:
- Overtime working, did lots of stupid things.  You want to run away from what
  had been done...
- Recover context before a stale merge.

*** Revert a commit

If you make an unwanted change but it doesn't make sense to uncommit it (because
that code has been pushed to a remote repository say), you can use ~revert~ to
effectively reverse the commit in question. For example:

: git commit "Fix bug #5"
: git push
: (hmm - bad fix)
: git revert 2a5daf3f

This creates a patch that is the opposite of commit ~COMMIT~ and commits it to
your repository.

If you want to revert that commit without committing it (putting the reversion
into your index), use:

: git revert -n COMMIT

*** Squash

Squash change in several commits into one commit so that people think you are
smart.

Squash commits:
https://bitbucket.org/blog/git-squash-commits-merging-bitbucket

#+begin_src conf
    # "Bundle" the last N changes into a single commit.
    squash = "!f() { \
            git reset --soft HEAD~$1 \
                && git commit --edit -m\"$(git log --format=%B --reverse HEAD..HEAD@{1})\"; \
        }; f"
#+end_src

Now it is possible to use this command to *combine together the last N commits*
into one commit:

: git squash N

* Branches

** Branching model

Consistent *naming conventions* (from the [[https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow][Gitflow]] Git workflow):

- =main= or =master= (used for *production releases*)

  It should be the most stable branch. Merges commits from develop, release and
  hotfix branches.

- =develop= (used as integration branch for *"next release" development*)

  It has the newest features and fixes. Merges commits from feature and bugfix
  branches.

- prefix =feature/MSW-709-add-support-for-webm= (for new *features*, such as Jira
  *stories*)

  These branches are short lived as they only exist while a specific feature is
  being developed. Usually does not merge any commits unto it, unless there is
  another feature derived from it.

- prefix =bugfix/= (typically used to fix Release branches, such as Jira *bugs*)

  Used to fix bugs found that either exist in develop but have not made it into
  production, or that do exist in production but can wait until the next
  release. These branches merge into develop.

- prefix =release/2018-12-24= (used for preparing and testing *release* tasks)

- prefix =hotfix/fix-123-for-production= (used to *urgently fix* bugs on *production*,
  that have high impact)

  Used to fix pressing issues that are found in production. Hotfix branches
  merge directly to =master=.

Alternatives:
- https://about.gitlab.com/blog/2014/09/29/gitlab-flow/
- https://trunkbaseddevelopment.com/ (and
  https://dev.to/alediaferia/git-tips-for-trunk-based-development-1i1g)

** Create a branch

Create a new branch (40-character name advised), and then switch to it:

#+begin_src conf
    create-branch = checkout -b
#+end_src

#+begin_note
To create a branch from a specific commit:

: git create-branch bugfix 7e09ef09

Otherwise you're in a "detached head" state, which can have odd results.
The branch method is at least a little more stable.
#+end_note

#+begin_note
I usually branch off from the commit before the offending
commit and stay there until things are resolved (unless I'm able to
resolve it myself).

Or I branch off =master= and revert the offending commit until things are
resolved, ie. like so
 git checkout master
 git create-branch sb-master
 git revert sha1-of-offending-commit
#+end_note

** Publish a branch

Push the ~CURRENT_BRANCH~ branch to the =origin= remote and set up tracking:

#+begin_src conf
    # Usage: git publish
    # Push current branch to remote server.
    publish = !git push -u $(git origin) $(git current-branch)
    # (Create a copy of the current branch on the remote "origin", and set it to
    # track the upstream branch)
#+end_src

Name of current branch (not so useful in itself, but used in other aliases):

#+begin_src conf
    # current-branch = name-rev --name-only HEAD
    # XXX Does not work correctly with tags (returns 'tags/2019.04.25~3')

    # Usage: git current-branch
    # Get the current branch name (v2.22+).
    current-branch = branch --show-current
    # Does work correctly with tags, but not in detached state.

    current-branch-without-slash = "!f() { \
            git current-branch \
                | tr '/' '-'; \
        }; f"
#+end_src

Then:
1. [[id:a7039f6e-825c-484c-8739-f3e32a9c45fc][Create a pull request]].
2. Your team lead will review the code & merge it to the main branch.

** List branches

*** Show all branches

*List all branches* (both local remote-tracking and local branches), showing SHA
and commit subject line for each head, along with the name of the upstream
branch (if any).

(Sort by Last updated)

: git for-each-ref --format="%(refname:short) %(upstream:track)" refs/heads

fco="!f() { git branch -a -vv --color=always --format='%(refname)' | sed "s_refs/heads/__" | sed "s_refs/remotes/__" | fzf --query="$@" --height=40% --ansi --tac --color=16 --border | awk '{print $1}' | xargs git checkout; }; f"
(fuzzy checkout a git branch)

#+begin_src conf
    # Show local and remote branches.
    branches = branch -a -vv
#+end_src

#+begin_src conf
    be = branch --edit-description
#+end_src

#+begin_src conf
    track = for-each-ref --format='%(refname:short) <- %(upstream:short)' refs/heads
#+end_src

#+begin_src conf
    # Show info for branches which have been checked out locally...
    br = for-each-ref \
             --sort=-committerdate refs/heads/ \
             --format='  %(color:green)%(committerdate:short)%(color:reset) %(HEAD) %(color:green bold)%(refname:short)%(color:reset) %(color:red bold)%(upstream:track)%(color:reset) %(color:yellow)%(objectname:short)%(color:reset) %(contents:subject) %(color:bold blue)<%(authorname)>%(color:reset)'
#+end_src

git for-each-ref --sort=committerdate refs/heads/ --format='%(HEAD) %(color:yellow)%(refname:short)%(color:reset) - %(color:red)%(objectname:short)%(color:reset) - %(contents:subject) - %(authorname) (%(color:green)%(committerdate:relative)%(color:reset))'

#+begin_src conf
    recent = for-each-ref \
                 --sort=-committerdate refs/heads/ \
                 --format='%(authordate:short) %(color:red)%(objectname:short) %(color:yellow)%(refname:short)%(color:reset) (%(color:green)%(committerdate:relative)%(color:reset))'
#+end_src

#+begin_src conf
    # Sort by date for branches; can be useful for spring cleaning
    refs-by-date = for-each-ref \
                       --sort=-committerdate \
                       --format='%(committerdate:short) %(refname:short)'
#+end_src

*** Show my branches

*** Show active branches

List branches that are *not merged*.

#+begin_src conf
    br-active = "!f() { \
            git branch --no-merged \
                | grep -v '\\*'; \
        }; f"
    branches-active = "!f() { \
            git branch -a -vv --no-merged \
                | grep -v '\\*'; \
        }; f"
#+end_src

*** Show merged branches

List branches whose tips are reachable from the specified commit (~HEAD~ if not
specified).

#+begin_src conf
    br-merged = "!f() { \
            git branch --merged \
                | grep -v '\\*'; \
        }; f"
    branches-merged = "!f() { \
            git branch -a -vv --merged \
                | grep -v '\\*'; \
        }; f"
#+end_src

*** Show stale branches

"Stale branches" are Git branches *without commits* for the last few months.  This
generally indicates old, unmaintained branches for unreleased, incomplete
features.

For GitHub, such period of inactivity is *3 months* (see
https://help.github.com/articles/viewing-branches-in-your-repository/).

** Switch branches

Checkout [[http://nvie.com/posts/a-successful-git-branching-model/][*common branches*]] (useful if you have feature branches):

#+begin_src conf
    master = !git checkout master
    main =  !git checkout main
    develop = checkout develop
#+end_src

** Close a branch

Manage branches that you no longer plan on working with.

: git checkout badbranch
: git rename-branch badbranch badbranch-CLOSED

This renames the branch, and keeps your coworkers happy.

#+begin_note
Such a closed branch is still considered active and will be displayed by
default.
#+end_note

** Delete a branch

*** Delete a local branch

Delete a *local* branch:

#+begin_src conf
    # Politely ask Git to delete a local branch.
    delete-local-branch = branch -d
#+end_src

#+begin_note
The ~-d~ (~--delete~) option only deletes the branch if it has already been fully
merged in its upstream branch.

You could also use ~-D~, which is an alias for ~--delete --force~, which deletes the
branch "irrespective of its merged status."
#+end_note

*** Delete the merged branches

~delete-local-merged-branches~ *removes* (in bulk) *all* the *local branches* that have
been *merged to the current branch* that you are in.

XXX https://haacked.com/archive/2014/07/28/github-flow-aliases/

#+begin_src conf
bclean = "!f() { \
        DEFAULT=$(git default); \
        git branch --merged ${1-$DEFAULT} \
            | grep -v " ${1-$DEFAULT}$" \
            | xargs git branch -d; \
    }; f"
#+end_src

It deletes every branch that's been merged into the specified branch except the
branch.

#+begin_src conf
    # Delete fully merged branches.
    delete-local-merged-branches = "!f() { \
            git branch --no-color --merged \
                | grep -v '\\*' \
                | egrep -v \"(master|main|develop)\" \
                | xargs -n 1 git delete-local-branch; \
        }; f"

    # # https://stackoverflow.com/questions/6127328/how-can-i-delete-all-git-branches-which-have-been-merged
    # sweep = '!git branch --merged $([ $1 != "-f" ] && git rev-parse master) | \
    #           egrep -v "(^\*|^\s*(master|main|develop)$)" | \
    #           xargs git branch -d'
#+end_src

Not "fully merged" means the branch you are about to delete contains commits
that are not reachable from any of:
- its upstream branch, or
- ~HEAD~ (current branch).
In other words, when you might lose commits.

#+begin_tip
In the event that you accidentally delete ~master~, get it back with:

: git create-branch master $(git origin)/master
#+end_tip

See http://haacked.com/archive/2014/07/28/github-flow-aliases/.

See
https://www.oreilly.com/library/view/git-pocket-guide/9781449327507/ch05.html
for the distinction between "merged" and "fully merged" branches!

- https://stackoverflow.com/questions/6127328/how-can-i-delete-all-git-branches-which-have-been-merged
- https://github.com/arc90/git-sweep

*** Delete remote branch

Delete a *remote* branch:

#+begin_src conf
    # Usage: git delete-remote-branch BRANCH
    # Delete a remote branch.
    delete-remote-branch = !git push $(git origin) --delete

    # Usage: git unpublish
    # Delete current branch on remote server.
    unpublish = !git delete-remote-branch $(git current-branch)
#+end_src

*** Delete a branch locally and on the ~origin~ remote

#+begin_src conf
    delete-branch = "!f() { \
            git delete-local-branch $1 \
                && git delete-remote-branch $1; \
        }; f"
#+end_src

*** Delete all orphaned branches (that no longer exist at remote)

Once you delete the branch from the remote, you can *remove all orphaned
remote-tracking branches that you have locally*, in =.git/refs/remotes/origin=, but
are *no more present in the remote repository* ~origin~ with:

: git remote prune $(git origin)

Use the ~--dry-run~ flag to only see what branches will be pruned, but not
actually prune them:

: git remote prune $(git origin) --dry-run

#+begin_src conf
    # Prune deleted branches from all remotes.
    prune-all = !git remote | xargs -n 1 git remote prune
    # 'git remote prune' does not understand '--all'.

    # There's no way to tell git remote update to prune orphaned branches?
#+end_src

#+begin_tip
If you want this to be run automatically every time you fetch/pull:

: git config --global fetch.prune true
#+end_tip

or prune individual remote tracking branches with:

: git branch -dr BRANCH_NAME

*Remove orphaned branches in your local repository* that *no longer exist in the
remote* one (by deleting the local ones that show they are "gone" in ~git
branch -vv~):

#+begin_src conf
    prune-local-branches = "!f() { \
            git branch -vv \
                | grep ': gone]' \
                | awk '{print $1}' \
                | xargs git delete-local-branch; \
        }; f"
#+end_src

** Rename a branch

Sometimes we name a branch poorly or maybe we thought the name was "good" but
not meaningful to the work we are doing.

To rename a branch *locally*:

- If we are on the branch we want to rename, we can just
  ~git rename-local-branch NEW_BRANCH_NAME~.

- If we are on another branch, we have to use
  ~git rename-local-branch OLD_BRANCH_NAME NEW_BRANCH_NAME~.

#+begin_src conf
    rename-local-branch = branch -m
#+end_src

XXX Try
: git rename-local-branch "#520-application-fee-refunds" "#509-application-fee-refunds"
(see https://gist.github.com/lttlrck/9628955)

To rename a branch *locally and remotely*:

1. Rename the branch locally,
2. Push the new branch and set local branch to track the new remote, and
3. Delete the old branch.

#+begin_src conf
    # Usage: git rename-branch OLD_BRANCH_NAME NEW_BRANCH_NAME
    # Rename both a local and remote branch.
    rename-branch = "!f() { \
            git rename-local-branch $1 $2 \
                && git push --set-upstream $(git origin) $2 \
                && git delete-remote-branch $1; \
        }; f"
#+end_src

* Tags

Tags give the ability to *mark a specific commit* in your repository history as
being important.

** Create a tag

While Git supports annotated and lightweight tags, you can only *create*
- *annotated tags* in /Bitbucket/ and in /GitLab/, and
- *lightweight tags* via /GitHub/ interface (for releases).

*Annotated tags* are *regular objects* in the repository, which means they have an
author, a date, a message, and can be referred because they have their own SHA
key.

*Lightweight tags* are just pointers to specific commits.  They *don't include any
further information*.

If knowing *who* tagged *what* and *when* is relevant for you, then use /annotated
tags/. If you *just want to tag a specific point in your development*, no matter
who and when did that, then /lightweight tags/ are good enough.

#+begin_note
/Annotated tags/ are meant for *release* while /lightweight tags/ are meant for
private or temporary object labels.
#+end_note

Create an /annotated tag/:

: git tag -a TAG_NAME -m 'TAG_MESSAGE'

Create a /lightweight tag/ (/no message!/):

: git tag TAG_NAME

Create a date/time tag with a suffix, e.g: 2021.01.12_15.25_PREVIOUS:

#+begin_src conf
    tag-with-date = !sh -c 'git tag $(date "+%Y.%m.%d_%H.%M")_"$0"'
#+end_src

** See the commits for a tag

See the list of all the commits for that tag.

: git ls TAG_NAME

** Push a tag to your repository

#+begin_src conf
    # Push TAG_NAME to remote repo.
    publish-tag = "!sh -c 'git push ${2:-$(git origin)} $1' -"

    # Remove TAG_NAME from remote repo.
    unpublish-tag = "!sh -c 'git push ${2:-$(git origin)} :refs/tags/$1' -"
#+end_src

Push all your tags (a regular push won't push a tag):

#+begin_src conf
    push-tags = push --tags
#+end_src

: git push --tags                         # Only tags.
: git push --tags $(git origin) master    # Code and tags.

** List the repository tags

List tags using (better) version sorting (not going from =v0.1= to =v0.10=):

#+begin_src conf
    # List tags.
    tags = tag -l --sort=v:refname

    # Show a list of tag names and the commits they reference.
    tags-show-ids = show-ref --tags
#+end_src

#+begin_src conf
    show-tags-by-date = log --tags --simplify-by-decoration --pretty="format:%ai %d"
#+end_src

: # Show annotated and lightweight tags.
: git show-ref -d --tags \
:     | cut -b 42- \
:     | sort \
:     | sed 's/\^{}//' \
:     | uniq -c \
:     | sed 's/2\ refs\/tags\// a /' \
:     | sed 's/1\ refs\/tags\//lw /'
: # 2. Remove the commit-id.
: # 4. Remove ^{} markings.
: # 5. Count identical lines.
: # 6. 2 identicals = annotated.

Show the last tag /in the current branch/:

#+begin_src conf
    last-tag = describe --tags --abbrev=0
#+end_src

Show the latest tag /in all branches/:

#+begin_src conf
    last-tagged = !git describe --tags $(git rev-list --tags --max-count=1)
#+end_src

** Rename a tag

Change the tag name but keep it on the same commit.

#+begin_src conf
    # Usage: git rename-tag OLD_TAG_NAME NEW_TAG_NAME
    # Rename a tag (locally and remotely).
    rename-tag = "!f() { \
            git tag $2 $1; \
            git tag -d $1; \
            git push $(git origin) $2; \
            git push $(git origin) :refs/tags/$1; \
        }; f"
#+end_src

** Clear a tag

If you have defined a tag and no longer want it defined, use the ~delete-tag~
alias to remove it.

#+begin_src conf
    # Delete local and remote tags.
    delete-tag = "!f() { \
            [ -z $1 ] \
                && echo \"No tags given as an argument!\" \
                || (git tag -l $1 | \
                    xargs -I % echo \"git tag -d % \
                                   && git push --delete $(git origin) %\" | \
                    sh); \
        }; f"
#+end_src

For example:

: git tag v2.0-beta-4
: (oops, we're not releasing a 4th beta)
: git delete-tag v2.0-beta-4

Delete similar tags:

: git delete-tag 'v2.0-*'

** Remove all tags

#+begin_src conf :tangle no
    # Delete all local and remote tags.
    delete-all-tags = "!f() { \
            for TAG_NAME in $(git tags); do
                git tag -d $TAG_NAME
                git push $(git origin) :$TAG_NAME
            done;
        }; f"
#+end_src

* Compare Revisions (commits, branches or tags)

*See what's changed* between two revisions.

Easily determine which changes:
- are on the "compare" side (= merge /source/) but
- are /not/ on the "base" side (= merge /destination/).

#+begin_note
Diff using three-dot (~...~) notation.
#+end_note

You can see:
- a list of commits,
- a list of changed files,
- a diff, and
- any pull requests merged between the two versions.

** Commits

#+begin_src conf
    # Usage: git compare-commits REV_BASE REV_COMPARE
    compare-commits = "!f() { \
            git log --date=short $1...$2; \
        }; f"
#+end_src

** Files changed

List all the changed *files between 2 commits*:

#+begin_src conf
    # Usage: git compare-changed-files REV_BASE REV_COMPARE
    # Show changed files (with stat about line additions and line deletions)
    # between two commits.
    compare-changed-files = "!f() { \
            git diff --stat $1...$2; \
        }; f"
#+end_src

** Diff

View all diffs.

- Inline diff (unified, single view)

  #+begin_src conf
    # Usage: git compare REV_BASE REV_COMPARE
    #      = git diff REV_BASE...REV_COMPARE
    # Example: git compare master@{1day} master
    compare = "!f() { \
            git diff $1...$2; \
        }; f"
    # https://github.com/fniessen/git-leuven/compare/master@%7B1day%7D...master
  #+end_src

- Side-by-side diff (split view)

*** Compare files from two different branches

: git diff BRANCH_1..BRANCH_2 -- PATH/TO/FILE

If either side is ~HEAD~, it may be omitted (e.g. ~master..~ compares ~master~ to
~HEAD~).

** Merged pull requests

** Example comparisons

#+begin_src conf
    # Show commits that haven't made it to master yet.
    ahead-of-master = !git log --oneline $(git origin)/master..HEAD
#+end_src

*** What did I do since I forked from the origin branch?

#+begin_src conf
    log-local = log --oneline $(git origin)..HEAD
#+end_src

#+begin_src conf
    show-branch-history = "!f() { \
            git log HEAD --not master; \
        }; f"
# XXX We should get the name of the branch merge base
#+end_src

Assuming that your branch was created off of master, then while in the branch
(that is, you have the branch checked out):

: git cherry -v master

or

: git log master..

If you are not in the branch, then you can add the branch name to the "git log"
command, like this:

: git log master..BRANCH_NAME

*** How do I find a list of files committed to a Git branch (since branching from master)?

Show all the changed files in a Git branch *since it was forked from the =master=
branch*:

#+begin_src conf
    # Usage: git missing-files [COMMIT_ISH]
    # Show the changed files between this and another branch
    # Examples:
    #   git missing-files             list changed files between this and master
    #   git missing-files feature/7   list changed files between this and the 'feature/7' branch
    missing-files = "!f() { \
            git diff --stat ${1:-master}...; \
        }; f"
#+end_src

See the added / copied / deleted / modified / renamed files in a branch:

: git diff forked_from_branch...my_forked_branch --name-status --diff-filter=ACDMR

Available filters for ~--diff-filter~ are:

- A :: Added
- C :: Copied
- D :: Deleted
- M :: Modified
- R :: Renamed

*** History of your branch: List all commits on only one side of the branches

= UNION of log-local AND log-fetched?  (with prefix < or > for branch A or B)

#+begin_src conf :tangle no
    git log --graph --left-right --cherry-pick --oneline master...<branch>
#+end_src

It is really a list of commits reachable from 'branch' that are not reachable
from master. This gives you the information you want, but if and only if you
have never merged 'branch' back to master, and have never merged master into
'branch' since you created it. If you have merged, then this history of
differences will collapse.

*** What did the origin do since I forked from them?

#+begin_src conf
    log-fetched = log --oneline HEAD..$(git origin)
#+end_src

*** TODO Show the history difference between a local branch and its remote

= git out?  (if I'm the only one pushing?)

#+begin_src conf
    divergence = !git log --left-right --graph --cherry-pick --oneline $1...$(git origin)/$1
#+end_src

* ?Releases

You can create a release to package software, along with release notes and links
to binary files, for other people to use.

Releases are based on *Git tags*: tags are used to mark *release* versions, with the
*version number* as the *tag name*.

We recommend naming tags that fit within [[https://semver.org/][semantic versioning]], i.e. having the
form ~v<major>.<minor>.<patch>~:
- *Major* release (from ~v0.8.1~ to ~v1.0.0~) for bug fixes and new features that
  break backwards compatibility,
- *Minor* release (from ~v0.8.1~ to ~v0.9.0~) for bug fixes and new features that
  maintain backwards compatibility, and
- *Patch* release (from ~v0.8.1~ to ~v0.8.2~) only for bug fixes.

# https://stackoverflow.com/questions/21639437/git-flow-release-branches-and-tags-with-or-without-v-prefix

#+begin_note
It's common practice to prefix your version names with the letter ~v~.
#+end_note

Tag and push changes to the repository:

#+begin_src conf
    release = "!f() { \
            git tag -a v$1 -m \"Release version $1\" \
                && git push $(git origin) --tags \
                && git push $(git origin); \
        }; f"
#+end_src

* ?Graph

Graphical history viewers

See example at https://gitlab.com/procps-ng/procps/-/network/master

[[https://jonas.github.io/tig/][Tig]]

To see real *timeline* of who is working on what and when:

#+begin_src conf
    # this is a summary?
    graph = log --graph -25 --branches --remotes --tags --format=format:'%C(yellow)%h %C(reset) %<(75,trunc)%s <%cn> (%cr) %C(red)%d' --date-order

    # Show log as a graph
    glog = log --graph --all --oneline --decorate
#+end_src

#+begin_src conf
    releases = log --decorate --no-merges --all --simplify-by-decoration --oneline --graph
    # XXX Add date

    show-tree = log --decorate --all --simplify-by-decoration --oneline --date=short --graph
#+end_src

#+begin_src conf
    hist = log --date=short --graph
#+end_src

Directed Acyclic Graph:

  # Use graphviz for display.
  # This produces output that can be displayed using dotty, for example:
  #   $ git graphviz HEAD~100..HEAD~60 | dotty /dev/stdin
  #   $ git graphviz --first-parent master | dotty /dev/stdin

See https://tortoisegit.org/docs/tortoisegit/tgit-dug-revgraph.html

#+begin_src conf
    graphviz = "!f() { \
            echo 'digraph git {' ; \
            git log -25 --pretty='format:  %h -> { %p }' \"$@\" \
                | sed 's/[0-9a-f][0-9a-f]*/\"&\"/g' ; \
            echo '}'; \
        }; f"
#+end_src

* ?Contributors

Show authors of commits in the repository, /excluding merge commits/.

#+begin_src conf
    contributors-name  = shortlog -n -s --no-merges --
    contributors-email = shortlog -n -s -e --no-merges --
#+end_src

#+begin_note
The ~--~ signals the /end of options/, that the rest of the parameters are limiters.
#+end_note

* Pull requests

A pull request (PR) is a request from someone to merge in code from one branch
to another.

XXX See https://github.com/github/hub/

** Create a pull request
:PROPERTIES:
:ID:       a7039f6e-825c-484c-8739-f3e32a9c45fc
:END:

You'll be asked to select a "From" branch and a "To" branch.

You need to enter a PR summary.  The description is optional.

Create a pull request against the default branch:

#+begin_src conf
    pull-request-bb = "!f() { \
            USER_NAME=$1; \
            curl --user $USER_NAME https://bitbucket.org/$(git repo-owner)/$(git repo-slug)/pull-requests/new?source=$(git current-branch)&t=1; \
        }; f"
#+end_src

#+begin_src conf :tangle no
function pr () {
  if ["$1" == ""]
  then
      echo "Please provide the name of the branch to create a pull request against."
  else
      local REPO=$(git remote -v | grep -m 1 "(push)" | sed -e "s/.*github.com[:/]\(.*\)\.git.*/\1/")
      local BRANCH=$(git name-rev --name-only HEAD)
      echo "... creating pull request for branch \"$BRANCH\" in \"$REPO\""
      open https://github.com/$REPO/compare/$1...$BRANCH
  fi
}
#+end_src

Add a comment in GitHub pull request:

: curl -s -H \"Authorization: token $GITHUB_TOKEN\" -X POST -d '{\"body\": \"$TEXT_PR\"}' \"https://api.github.com/repos/$REPOSITORY_NAME/issues/$GHPRBPULLID/comments\""

** List pull requests

List pull requests in the current repository.

- Pull Requests assigned to me
- Pull Requests I've created

- *Open*
- *Merged*
- Closed
- All

Git aliases for pull requests and other useful stuff
https://gist.github.com/metlos/9368527

For GitHub
: git ls-remote $(git origin) 'refs/pull/*'

#+begin_src conf
    pr-list = XXX
#+end_src

** 1. Check out a pull request locally

XXX https://gitlab.com/help/user/project/merge_requests/index.md#checkout-merge-requests-locally

Sometimes, just reading the code of a pull request might not be enough to verify
if it should be merged.  Maybe you want to add something, or some tests are
failing, and you want to run them locally on your computer.

*Check out* the head of a *pull request* (given the pull request number) as a *local
branch*:

#+begin_src conf
    # For GitHub.
    pr-checkout-gh = "!f() { \
            git fetch $(git origin) pull/$1/head:pr/$1 \
                && git checkout pr/$1; \
        }; f"
    # https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/checking-out-pull-requests-locally

    # For GitLab.
    pr-checkout-gl = "!f() { \
            git fetch $(git origin) merge-requests/$1/head:pr/$1 \
                && git checkout pr/$1; \
        }; f"
    # https://about.gitlab.com/blog/2016/12/08/git-tips-and-tricks/#add-an-alias-to-checkout-merge-requests-locally
#+end_src

Now you can check out a particular pull request.  For example:

: git pr-checkout 5

will fetch the *pull request* #5 into a *local* ~pr/5~ *branch* and check it out.

** 2. Review the changes locally

** Push changes to a pull request

#+begin_src shell :tangle no
#!/bin/bash
TMPFILE=$(mktemp)
REPOSLUG=$(git remote -v | grep '^upstream' | head -n 1 | perl -lne 's/github.com:?\/?(.*)\/([^.]*)([.]git| )// or next; print $1,"/",$2')
PRNUMBER=$(git rev-parse --abbrev-ref HEAD | cut -d/ -f 2)
curl -s https://api.github.com/repos/$REPOSLUG/pulls/$PRNUMBER > $TMPFILE
trap "{ rm -f $TMPFILE; }" EXIT
HEADREF=$(cat $TMPFILE | jq -r '.head.ref')
HEADSLUG=$(cat $TMPFILE | jq -r '.head.repo.full_name')
git push -f git@github.com:$HEADSLUG HEAD:$HEADREF
#+end_src

For more details on pushing changes to a PR, please see [[https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/allowing-changes-to-a-pull-request-branch-created-from-a-fork][the official article]].

** 3. Merge the branch and fix any conflicts that come up

git fetch $(git origin)
git checkout "$(git origin)/master"
git merge --no-ff "1-change-encoding-of-read-sql-file"

XXX See https://gitlab.com/help/user/project/merge_requests/squash_and_merge

** Merge pull request

If everything is OK, you can merge the pull request.

#+begin_src conf
    # For GitHub.
    mpr = "!f() { \
            declare CURRENTBRANCH=\"$(git current-branch)\"; \
            declare BRANCH=\"${2:-$CURRENTBRANCH}\"; \
            if [ $(printf \"%s\" \"$1\" | grep '^[0-9]\\+$' > /dev/null; printf $?) -eq 0 ]; then \
                git fetch $(git origin) refs/pull/$1/head:pr/$1 \
                    && git checkout -B $BRANCH \
                    && git rebase $BRANCH pr/$1 \
                    && git checkout -B $BRANCH \
                    && git merge --ff-only pr/$1 \
                    && git delete-local-branch pr/$1; \
            fi \
        }; f"

    # Merge given pull request into the current branch.
    # The commit message will have the same for as if done using the
    # merge button on github.com
    # Example:
    #   git merge-pr $(git origin) 5
    merge-pr = "!sh -c '\
        USER_AND_REPO=$(git remote show $1 | grep \"Fetch URL\" | sed -E \"s/.*github.com[:\\/]([a-zA-Z_\\-]+)\\/([a-zA-Z_\\-]+)\\.git$/\\1 \\2/\"); \
        USER=$(echo $USER_AND_REPO | cut -d\" \" -f1); \
        REPO=$(echo $USER_AND_REPO | cut -d\" \" -f2); \
        TMPFILE=$(mktemp); \
        curl -si https://api.github.com/repos/$USER/$REPO/pulls/$2 > $TMPFILE; \
        PULL_AUTHOR=$(cat $TMPFILE | awk \"{if (/ *\\\"head\\\"/) head=\\\\$1; if (/ *\\\"login\\\": \\\"/) value=\\\\$2}{if (head && value) print value; if (head && value) exit}\" | sed -E \"s/\\\"([^\\\"]+)\\\".*/\\1/\"); \
        PULL_REF=$(cat $TMPFILE | awk \"{if (/ *\\\"head\\\"/) head=\\\\$1; if (/ *\\\"ref\\\": \\\"/) label=\\\\$2}{if (head && label) print label; if (head && label) exit}\" | sed -E \"s/\\\"([^\\\"]+)\\\".*/\\1/\"); \
        PULL_TITLE=$(cat $TMPFILE | grep \"\\\"title\\\": \" | sed \"s/^ *\\\"title\\\": \\\"//\" | sed \"s/\\\",$//\"); \
        rm $TMPFILE; \
        git fetch $1 pull/$2/head; \
        git merge --no-ff -m \"Merged pull request #$2 from $PULL_AUTHOR/$PULL_REF\n\n$PULL_TITLE\" FETCH_HEAD; \
        ' -"
#+end_src

This is actually quite useful if you are a maintainer of a project on
GitHub.

There are two ways you can call it:

- ~git mpr 123~

  This will merge pull request number 123 on top of the current branch.

- ~git mpr 123 master~.

  This will merge pull request number 123 on top of the branch called master.

If you are using GitHub, you can easily merge a pull request using the web
interface, but if you want a bit more control over how you are merging the pull
requests (for example, I'm using the ~git merge --ff-only~ option, while GitHub
will use ~git merge --no-ff~), or you just want to merge a bunch of pull requests
without leaving your terminal -- this function will help you.

** 4. Push the result of the merge to the remote

: git push $(git origin) "master"

** Clean up old branch

Delete the *from* branch after PR is merged (or ignored -- if it was created
b accident or if it's irrelevant):

#+begin_src conf
    pr-clean = "!f() { \
            git delete-local-branch pr/$1; \
        }; f"
#+end_src

** Show in a web browser

Open a pull request page in a web browser.

#+begin_src conf
    pr-show = XXX <pr-number>
#+end_src

** Who?

Extra script (called [[https://github.com/mislav/dotfiles/blob/master/bin/git-overwritten][git-overwritten]]) which shows blame information about
original authors of lines changed or removed in a given branch:

: git overwritten feature $(git origin)/master

This is useful when opening pull requests per GitHub Flow; you'll want your pull
request reviewed by colleagues but you might not be sure who to ping. With
git-overwritten you'll get the names of people who wrote the lines you just
changed, so you'll know who to @-mention when opening a pull request.

> So, given a patch (or a branch) together with a "base revision", you'd get
> a list of code chunks modified by that patch, then run "annotate" on the
> base revision, and look for those code chunks, collecting the names of
> corresponding authors.

Sounds like git-guilt (which I've just read about today), might be
relevant: https://bitbucket.org/tpettersen/git-guilt

** Find the pull request that introduced a commit

Related pull request:

#+begin_src conf
    related-pr-of-commit = "! sh -c 'git log $1..master --ancestry-path --merges --oneline | tail -n 1 ' -"
#+end_src

Example:

: $ git related-pr-of-commit 22689a1
: 1c6b5c4 Merge branch '5-resolve-it' into 'master'

In this case, the commit comes from pull request 5.

** Saved replies

GitHub allows to [[https://github.blog/2016-03-29-saved-replies/][save replies]]. You can set them in [[https://github.com/settings/replies][your GitHub settings]].  Here
are a couple of commonly used replies:

Missing changelog

#+begin_src text :tangle no
This still lacks a changelog entry. Please see [the changelog folder](../tree/master/changelog) for instructions.
Hence, I added the "pending changelog" label.
#+end_src

Missing spec PR

#+begin_src text :tangle no
This still needs a PR to the [specification](https://github.com/dlang/dlang.org/tree/master/spec) at [dlang.org](https://github.com/dlang/dlang.org). Hence, I added the label "missing spec PR".

Please refer to the [dlang.org CONTRIBUTING guide](https://github.com/dlang/dlang.org/blob/master/CONTRIBUTING.md) for instructions to build dlang.org locally. If you use Windows, don't worry, you can do your changes "blindly" and preview them at DAutoTest.
#+end_src

Phantom Zone

#+begin_src text :tangle no
This PR entered the Phantom Zone
-----------------------------------------------


This PR has entered the [Phantom Zone](http://forum.dlang.org/post/ouuutodvhmnghzbeoqen@forum.dlang.org) as it still needs to have the reviewers' concerns addressed and rebased.

Reason for entering the Phantom Zone
----------------------------------------------------

This PR is nice, and normally I would revive such a PR if the author was no longer active. I would also revive it if it were an important bug fix or something of higher priority.  This PR, however, is just a refactoring, so I'm going to put it in the [Phantom Zone](http://forum.dlang.org/post/ouuutodvhmnghzbeoqen@forum.dlang.org) and close it for now.

How do I get this PR out of the Phantom Zone
-------------------------------------------------------------

Easy: Address the comments -> open a new PR (mention this one + short summary in the description).
#+end_src

* Pipelines

#+begin_src conf
rsync-deploy =
#+end_src

* Deployments (to different environments)

(see structure of actions in BitBucket)

See https://bitbucket.org/blog/wordpress-continuous-deployment

#+begin_src conf
# Deploy a branch to review server (https://review-feature-1.example.com).
deploy-review =

# Deploy master to staging server (https://staging.example.com).
deploy-staging =

# Deploy master to production server (https://example.com).
deploy-prod =

  # # Deploy
  # staging = !git push heroku-staging $(git current-branch):master -f && git track 'Deployed to staging ' # push current branch to staging, can add more comments after
  # dev = !git push heroku-dev $(git current-branch):master -f && git track 'Deployed to dev ' # push current branch to dev
  # deploy = !git push heroku $(git current-branch):master -f && git track 'Deployed to production ' # push current branch to production

# shipit = push heroku master

 # deploy='git push production master && terminal-notifier-notify -title "Deploy" -message "Deploy complete"'
 # stage='git push staging $(git current-branch):master'
#+end_src

* Issues

Status (and status values that are allowed on a ticket).

- Open
  + New
  + Accepted
  + Test

- Closed
  + Invalid
  + Closed

** Create Issue

Open an issue in the current repository:
- Enter a summary
- Write an optional description

#+begin_src conf
# title
# description
# assignee
# kind
# priority
    create-issue = XXX
#+end_src

Issue template:

#+begin_src text :tangle .issue_template.txt
### Expected behavior
### Actual behavior
### Steps to reproduce the behavior
#+end_src

See https://github.com/devspace/awesome-github-templates
and https://jwong.co.uk/blog/2018/09/01/useful-github-features/#emoji-organising

** Create Pull Requests

#+begin_src conf
    create-issue-pull-request = XXX
#+end_src

Title of pull request:

: WIP: Resolve "Title of issue"

Once merged:

: Resolve "Title of issue"

** List All Issues

See https://blog.bennycornelissen.nl/post/github-from-your-terminal/

#+begin_src conf
    # issues = "!f() { USER_NAME=$1; \
    #     curl --user $USER_NAME \
    #         https://api.bitbucket.org/2.0/repositories/$(git repo-owner)/$(git repo-slug)/issues \
    #         | jq -C --compact-output '.values | .[] | [.id, .title, .type, .priority, .state, .votes, .assignee.display_name, .created_on, .updated_on]' \
    #         | sed -r 's/(....)-(..)-(..)T(..):(..):(..).(............)/\\1-\\2-\\3/g' \
    #         | sed \"s/new/NEW/\" \
    #         | sed \"s/NEW/$(tput setaf 2) -- NOUVEAU -- $(tput sgr0)/\" \
    #         | sed \"s/NEW/\$(tput setaf 3) -NOUV- \$(tput sgr0)/\" \
    #         | sed \"s/open/OPEN/\" \
    #         | sed \"s/closed/CLOSED/\"; }; f"
# --data-urlencode 'priority >= \"major\"'
#+end_src

#+begin_src conf :tangle no
    issues = "!f() { \
            USER_NAME=$1; \
            curl --user $USER_NAME 'https://api.bitbucket.org/2.0/repositories/$(git repo-owner)/$(git repo-slug)/issues?pagelen=100' \
                | jq --compact-output '.values | .[] | [.id, .title, .type, .priority, .state, .votes, .assignee.display_name, .created_on, .updated_on]' \
                | sed \"s#\"open\"#$(tput setaf 2)&$(tput sgr0)#\" \
                | sed \"s#\"closed\"#$(tput setaf 1)&$(tput sgr0)#\"; \
        }; f"
#+end_src

Set color to red or green, depending on issue state.

#+begin_src conf :tangle no
# Works!  Need to put quotes around the URL!
curl -u $USER_NAME -X GET 'https://api.bitbucket.org/2.0/repositories/$(git repo-owner)/$(git repo-slug)/issues?pagelen=100' \
    | jq --compact-output '.values | .[] | [.id, .title, .type, .priority, .state, .votes, .assignee.display_name, .created_on, .updated_on]'
# curl -s -S
#+end_src

See also [[https://cran.r-project.org/web/packages/jsonlite/vignettes/json-apis.html][Fetching JSON data from Github REST API]].

** List Open Issues

#+begin_src conf
    issues-open = !git issues | grep "open"
#+end_src

** List My Issues (assigned to me)

#+begin_src conf
    issues-assigned-to-me = !git issues | grep "$(git config user.name)"
#+end_src

** List Issues I've created

#+begin_src conf
    issues-created-by-me = XXX
#+end_src

** Show Issue

Show an existing issue specified by NUMBER.

#+begin_src conf
    show-issue = XXX
#+end_src

** Open Issues in a web browser

#+begin_src conf
    browse-issues = "!f() { \
            URL=$(git config --get remote.$(git origin).url); \
            cygstart ${URL/.git}/issues/$1; \
        }; f"
#+end_src

* Wiki

#+begin_src conf
    browse-wiki = "!f() { \
            URL=$(git config --get remote.$(git origin).url); \
            cygstart ${URL/.git}/wiki; \
        }; f"
#+end_src

* Downloads

Download repository, tag or branch.

#+begin_src conf
    # Put everything in the current repo in a Zip archive.
    download-repository = "!f() { \
            git archive ${1:-HEAD} --format=zip -o $(basename $(git root))-commit-$(git rev-parse ${1:-HEAD}).zip; \
        }; f"
# XXX Test it with tag or branch.
#+end_src

* Settings

** SSH keys

List the user's public SSH keys:

#+begin_src shell :tangle no
# For GitHub.
curl -O https://github.com/fniessen.keys

# For BitBucket.
curl https://api.bitbucket.org/2.0/users/fniessen/ssh-keys | jq '.values'
#+end_src

* ------------------------------------------------------------------------------

* Run on All repositories

The biggest use I get out of this alias is making sure I have everything
committed. Sometimes I'll work on a project and then forget about it for
a little while without committing. When I want to double-check that I'm not
forgetting anything, I run ~git all status --short~ to quickly scan which repos
have uncommitted changes that I need to take care of.

#+begin_src conf
    all = "!find . -type d -name .git -prune -execdir pwd ';' -execdir git $@ ';' #"

    print-reponame-then-run = "!f() { \
            echo "======"; \
            basename $(git rev-parse --show-toplevel); \
            echo "======"; \
            git "$@"; \
        }; f"

    # Run commands for each repository in the current directory.
    allr = "!f() { \
            ls -R -d */.git \
                | sed s,/.git,, \
                | xargs -I{} git -C {} print-reponame-then-run "$@"; \
        }; f"
#+end_src

See also ~git-repos~:
http://osiux.com/2015-01-14-sincronizar-repositorios-git-repos.html

* Sort out

#+begin_src conf
    # Useful for exploring Git.
    type = cat-file -t
    dump = cat-file -p
#+end_src

#+begin_src conf
     # Catch up those random feature branches you haven't had to touch in months.
     catchup = !git fetch; git rebase $(git origin)/master
#+end_src

(see http://gitimmersion.com/lab_11.html)

Define:

#+begin_src conf
    exec = '!exec '
#+end_src

so that you can do things like ~git exec make~.  This works because Shell aliases
are always executed in the top-level directory.

#+begin_src conf
    # Show the diff between the latest commit and the current state
    d = !"git diff-index --quiet HEAD -- || clear; git --no-pager diff --patch-with-stat"

    # `git di $number' shows the diff between the state `$number' commits ago and the current state
    di = !"f() { git diff --patch-with-stat HEAD~$1; }; \
           git diff-index --quiet HEAD -- || clear; \
           f"

    # Pull in remote changes for the current repository and all its submodules
    p = !"git pull; git submodule foreach git pull $(git origin) master"
#+end_src

Clean up your commits before publishing.  Before you push your commits to the
repository, it's good to revise them.  You can run the git interactive rebase to
squash your commits or modify commit messages.  The goal is to publish only
clean and relevant commits, no experiments or fixing typos.

#+begin_src conf
    # Interactive rebase with the given number of latest commits
    ireb = "!r() { git rebase -i HEAD~$1; }; r"
#+end_src

#+begin_src conf
    # Starts an interactive rebase of all the commits you haven't pushed
    # yet. Handy for collapsing a bunch of work-in-progress snapshots into
    # logical commits before pushing, without having to worry about accidentally
    # squashing a commit someone else has already referred to.
    work-in-progress = rebase -i @{u}
#+end_src

#+begin_src conf
#BASIC HISTORY VIEWING

    hist = log --pretty=format:'%Cred%h%Creset %C(bold blue)<%an>%Creset%C(yellow)%d%Creset %Cgreen(%cr)%Creset%n%w(80,8,8)%s' --graph
    histfull = log --pretty=format:'%Cred%h%Creset %C(bold blue)<%an>%Creset%C(yellow)%d%Creset %Cgreen(%cr)%Creset%n%w(80,8,8)%s%n' --graph --name-status
    llog = log --pretty=format:'%C(yellow)%h %Cred%ad %Cblue%an%Cgreen%d %Creset%s' --date=iso
    ls = log --pretty=format:'%C(yellow)%p..%h %C(white dim)%cd %<|(49,trunc)%an %C(reset)%s' --date=short --abbrev=8 --no-merges

#BASIC REPO INFORMATION

    whois = "!sh -c 'git log -i -1 --pretty=\"format::%an <%ae>\n\" --author=\"$1\"' -"
    whatis = show -s --pretty='tformat::%h (%s, %ad)' --date=short

#WHAT WAS GOING ON, WHILE YOU WERE AWAY

    anychanges = !sh -c 'git fetch' && git log --oneline HEAD..$(git origin)/$1
    anychangesonmaster = !sh -c 'git fetch' && git log --oneline HEAD..$(git origin)/master
    whoischanging = !sh -c 'git shortlog HEAD..$(git origin)/$0'
    whoischangingmaster = !sh -c 'git shortlog HEAD..$(git origin)/master'

    # what branches you have on origin, with info on who is guilty and how long ago. Useful for gitflow and feature branches in general. Requires fetch up-front.
    showorigin = "!sh -c 'for BRANCH in $(git branch -r | grep -v HEAD); do echo $(git show -s --format=\"%Cred%ci %C(green)%h %C(yellow)%cr %C(magenta)%an %C(blue)\" $BRANCH | head -n 1) \\\t$BRANCH; done | sort -r'"

    # get remote branches
    trackallbranches = !sh -c "for BRANCH_NAME in $(git branch -r); do git branch --track $BRANCH_NAME; done"
    updateallbranches = !sh -c "for BRANCH_NAME in $(git branch -r); do git checkout $BRANCH_NAME ; git pull; done"
#+end_src

#+begin_src conf
#IGNORING

    # fix .gitignore
    fixgitignore = !git rm -r --cached . && git add . && git commit -m \"Just a .gitignore fix \"

#OTHER

    # Deletes all branches that were safely merged into the master. All other are skipped (no worries).
    # on osx xargs does not have -r argument, so it fail. If you remove -r, it will run at least once, making this not safe operation
    cleanup = !git branch --merged=master | grep -Ev '^\\* | master$' | xargs -r git branch -d

    # Deletes orphaned remote branches (.git/refs/remotes/origin), clean up reflog and remove all untracked files
    cleanuplocal = !git remote prune $(git origin) && git gc && git clean -df

    # Check if any file in repo has whitespace errors
    # As described in http://peter.eisentraut.org/blog/2014/11/04/checking-whitespace-with-git/
    check-whitespace = diff-tree --check $(git hash-object -t tree /dev/null) HEAD
    whitespace-violations = "!git diff --check $(git hash-object -t tree /dev/null)"

    # Check if any file in repo has windows line endings
    # Currently do not work as alias, works from comand line directly. There is a problem with \r
    check-eol = grep --files-with-matches $'\\r' HEAD

    # Jira tickets (from: http://blogs.atlassian.com/2014/08/whats-new-git-2-1/)
    issues = "!f() { : git log ; echo 'Printing issue keys'; git log --oneline $@ | egrep -o [A-Z]+-[0-9]+ | sort -u; }; f"
#+end_src

** SHOW - Check the status of your files

Give the status in the *short-format* (preceded by a line showing the /branch name/
and /tracking info/).

#+begin_src conf
    st = status -s -b
#+end_src

In the following example:

#+begin_example
M  README
 M lisp/mail/rmail.el
MM ChangeLog
#+end_example

- =README= is changed and *staged for commit* (it's *in the index*),
- =lisp/mail/rmail.el= is changed but *not staged for commit*, and
- =Changelog= is changed and staged for commit, then *changed again* and the new
  change is *not staged for commit*.

#+begin_note
Staging for commit is typically done by ~git add~.
#+end_note

** SHOW - View your changes

*** Changes between the working tree and the index (staged for the next commit)

See also ~-b~ (~--ignore-space-change~): Ignore changes in amount of
whitespace. This ignores whitespace at line end, and considers all other
sequences of one or more whitespace characters to be equivalent.

# permet d'ignorer les différences d'espaces et d'indentations
git diff -b
# permet d'ignorer les différences d'espaces et indentations au sein de la même ligne, mais indique les lignes vides ajoutées ou supprimées
git diff -w

#+begin_src conf
    # Ignore whitespace changes.
    wdiff = diff -b
    wdiff = diff --word-diff

    dw = diff --word-diff
#+end_src

#+begin_src conf
    # Configure git-diff to produce the absolutely most minimal diff possible.
    wdiff = diff -w --word-diff-regex=. --color-words -U0
#+end_src

#+begin_src conf
    # Diff line-wise.
    df = diff

    # Diff word-wise.
    dw = diff --color-words

    # Diff character-wise.
    dt = diff --word-diff-regex=.
#+end_src

*** Changes between the working tree and the latest commit (HEAD)

#+begin_src conf :tangle no
    diff-all = diff HEAD
#+end_src

*** Changes between the index (staged for the next commit) and the latest commit (HEAD)

Just before committing the *staged* changes, check what your commit changes:

#+begin_src conf
    # Review staged changes (about to be committed).
    dc = diff --cached
#+end_src

#+begin_src conf
    # Diff staged line-wise
    ds = diff --cached

    # Diff staged word-wise
    dws = diff --color-words --cached

    # Diff staged character-wise
    dts = diff --word-diff-regex=. --cached
#+end_src

*** Precommit

This is a key part of my workflow. I run this before every commit to make sure
I don't need to use the undo commands.

#+begin_src conf
    precommit = diff --cached --diff-algorithm=minimal -w
#+end_src

#+begin_src conf
    # Show log of new commits after you fetched, with stats, excluding merges
    log-fresh = log ORIG_HEAD.. --stat --no-merges
#+end_src

*** When was this file last updated

#+begin_src conf
    # When was this file last updated, on each local branch.
    wwflu = "!f() { for b in $(git rev-parse --symbolic --branches); do \
                        echo -e $(git log --format=%at:%ar -1 $b -- \"$1\")\\\\t$b; \
                    done | sort -r | cut -f2 -d:; }; f"
#+end_src

*** Add only modified changes (and ignore untracked files)

Ideally your =.gitignore= should prevent the untracked (and ignored) files from
being shown in status, added using ~git add~ etc.  So correct your =.gitignore=.

You can do ~git add -u~ so that it will *stage* the modified and deleted files.

#+begin_src conf
    stage-modified-removed-files = add -u
#+end_src

You can also do ~git commit -a~ to *commit* only the modified and deleted files.

#+begin_src conf
    wip = commit -am "WIP"
#+end_src

** SHOW - View the commit history

#+begin_note
The ~git log~ command shows, by default, the "author date" -- not the "committer
date".
#+end_note

#+begin_src conf
    # Show the log entries in oneline format.
    ls = log --decorate --date=short

    ld = log --decorate --date=relative

    log = log --decorate --date=short
#+end_src

XXX Check out http://marcgg.com/blog/2015/08/04/git-first-parent-log/

List commits *showing changed files* (prettier and more concise version of
~whatchanged~):

#+begin_src conf
    ll = log --pretty=medium --abbrev-commit --decorate --date=short --stat
#+end_src

#+begin_src conf
    ls-modified  = "!git status --porcelain -uno | awk 'match($1, /M/) {print $2}'"
    ls-added     = "!git status --porcelain -uno | awk 'match($1, /A/) {print $2}'"
    ls-deleted   = "!git status --porcelain -uno | awk 'match($1, /D/) {print $2}'"
    ls-renamed   = "!git status --porcelain -uno | awk 'match($1, /R/) {print $2}'"
    ls-copied    = "!git status --porcelain -uno | awk 'match($1, /C/) {print $2}'"
    ls-updated   = "!git status --porcelain -uno | awk 'match($1, /U/) {print $2}'"
    ls-staged    = "!git status --porcelain -uno | grep -P '^[MA]' | awk '{ print $2 }'"
#+end_src

#+begin_src conf
    ls-del  = ls-files -d
    ls-mod  = ls-files -m   # This will include deleted files also.
    ls-new  = ls-files --exclude-standard -o
    lsfiles = ls-files --exclude-per-directory=.gitignore \
                     --exclude-from=.git/info/exclude \
                     -v -d -o -m -s -u
#+end_src

#+begin_src conf
    # Return the last commit.
    last = log --decorate -1 --date=short --stat

    # # Show the last N commits on the current branch.
    # last = !git log --name-status -${1:-1}
#+end_src

*** Show the history of a file

*List of commits* that modified the *specified file* (will follow renames and
copies):

#+begin_src conf
    file-history = log --follow --date-order --date=short -C
#+end_src

#+begin_tip
Add ~-m~ to show merge commits.  And add ~--all~ to show commits of /all your
branches/, not just from the current branch.
#+end_tip

#+begin_src conf :tangle no
curl 'https://api.bitbucket.org/2.0/repositories/mcpflow/pflow/filehistory/master/CHANGELOG.org'
#+end_src

#+begin_src conf
    related = !sh -c 'git log --follow --format=format:%H $1 | xargs -L 1 git diff-tree --no-commit-id --name-only -r | sort | uniq -c | sort -b -n -r'
#+end_src

Find the *most recent commit* (chronologically) that modified a file -- looking in
all known commits:

#+begin_src conf
    file-last-modified = log -n 1 --follow --all --date-order --date=short -C
#+end_src

*** Inspect the commits for each edit

: git log ... | xargs -n 1 git show

** SHOW - Show blame information about original authors of lines changed or removed

$ git blame -w  # ignores white space
$ git blame -M  # ignores moving text
$ git blame -C  # ignores moving text into other files

git blame -w README.md
The -w option ignores whitespace changes. If a previous author has modified the
spacing of a file by switching from tabs to spaces or adding new lines this,
unfortunately, obscures the output of git blame by showing these changes.

git blame -M README.md
The -M option detects moved or copied lines within in the same file. This will
report the original author of the lines instead of the last author that moved or
copied the lines.

git blame -C README.md
The -C option detects lines that were moved or copied from other files. This
will report the original author of the lines instead of the last author that
moved or copied the lines.

: git blame -L 1509,1511 lisp/ox-html.el

#+begin_src conf
    praise = blame -w
    archeology = blame -w -C -n
    whodoikill = blame -w -C -n
#+end_src

** SHOW - find all "unpushed" commits for all projects in a directory

See https://stackoverflow.com/questions/12499195/git-how-to-find-all-unpushed-commits-for-all-projects-in-a-directory

#+begin_src conf
    status-all = "!for D in $(find . -name \".git\"); do \
                     echo \"\n*** Repository: $D ***\" \
                     && git --git-dir=$D --work-tree=$D/.. status | grep -q \"is ahead of\"; \
                   done"
#+end_src

** Ignoring files

*** List untracked files

Tell if a file is being tracked:

#+begin_src conf
    # List all tracked files.
    ls-tracked = ls-files -t

    tracked1 = "!f() { TRACKED=$(git ls-files $1); if [ -z \"$TRACKED\" ]; then echo 'File NOT tracked (or No such file)'; else echo 'File tracked'; fi; }; f"

    tracked2 = "!f() { echo -n $1': '; if [ -f \"$1\" ]; then TRACKED=$(git ls-files $1); if [ -z \"$TRACKED\" ]; then echo 'File NOT tracked'; else echo 'File tracked'; fi; else echo 'No such file!'; fi; }; f"
# does not work!?
#+end_src

#+begin_note
~[[~ has fewer surprises and is generally safer to use. But it is not portable --
it's a *Bashism*, POSIX doesn't specify what it does.

For example, you can do

: [[ -e $b ]]

to test whether a file exists.

But with ~[~, you have to quote ~$b~, because it splits the argument and expands
things like ~"a*"~ (where ~[[~ takes it literally).

: [ -e "$b" ]

That has also to do with how ~[~ can be an external program and receives its
argument just normally like every other program (although it can also be
a builtin, but then it still has not this special handling).
#+end_note

List untracked *files ignored* by a =.gitignore= statement somewhere.

#+begin_src conf
    # List all untracked files.
    ls-untracked = ls-files --others
#+end_src

#+begin_src conf
    # this one is a MUST have
    ls-ign  = ls-files --exclude-standard -o -i
    ls-ignored = ls-files --others --ignored --exclude-standard
#+end_src

Remove ignored files that are still on the repository:

#+begin_src shell :tangle bin/git-delete-ignored :shebang #!/usr/bin/env bash
git ls-ignored | xargs rm
#+end_src

*** Add ignore entry to the repository

- Ignore exact filename: filename
- Ignore everything beneath: folder
- Ignore all files with this extension: pattern
- Ignore custom pattern: pattern

#+begin_src conf :tangle no
# Add any directories, files, or patterns you don't want to be tracked by version control
#+end_src

Quickly add a file or directory to =.gitignore=:

#+begin_src conf
    ignore = "!f() { echo \"$1\" >> \"${GIT_PREFIX}.gitignore\"; }; f"
    # ignore=!([ ! -e .gitignore ] && touch .gitignore) | echo $1 >>.gitignore
# XXX What is GIT_PREFIX?

    # Ignore all untracked files by appending them to .gitignore:
    ignore-untracked = "!git status | grep -P \"^\\t\" | grep -vF .gitignore | sed \"s/^\\t//\" >> .gitignore"
#+end_src

*Note that adding the .gitignore and the file specification will have no effect
on files that are already being tracked.* If you're already tracking these,
you'll have to stop tracking them. (Right-click on the folder or file and select
Stop Tracking.) You'll then see them change from having a green/clean or
amber/changed icon to a red/removed icon. On your next commit the files will be
removed from the repository and thereafter appear with a blue/ignored
icon. Another contributor asked why Ignore was disabled for particular files and
I believe it was because he was trying to ignore a file that was already being
tracked. You can only ignore a file that has a blue question mark icon.

*** ~assume-unchanged~ command

Ignore/unignore changes to *tracked file(s)* without =.gitignore=:

#+begin_src conf
    skip = update-index --assume-unchanged
    unskip = update-index --no-assume-unchanged

    # Ignore files only locally.
    hide = update-index --assume-unchanged
    unhide = update-index --no-assume-unchanged
#+end_src

XXX Have a look at Git lock = skip-worktree

It has to be configured for each project member individually.

#+begin_warning
As stated in [[http://stackoverflow.com/questions/23097368/git-ignore-vs-exclude-vs-assume-unchanged][git ignore vs. exclude vs. assume-unchanged]],
~git-update-index --assume-unchanged~ was never meant to ignore changes to tracked
files (*only to spare some stats*).  So do not suggest it as a means to achieve
that.
#+end_warning

Skip all:

#+begin_src conf
    skip-all = "!git status -s | awk {'print $2'} | xargs git skip"
#+end_src

Unskip all the skipped files:

#+begin_src conf
    unskip-all = "!git skipped | xargs git update-index --no-assume-unchanged"
#+end_src

List ignored files (*marked unchanged*):

#+begin_src conf
    skipped = "!git ls-files -v | grep '^h' | cut -c 3-"
    skipped2-BAD-MAYBE = !git ls-files -v | grep '^[a-z]'
#+end_src

** Clean

**** Delete untracked files

#+begin_src conf
    nuke-untracked-files = clean -f
#+end_src

~git clean~ will *remove any files* from the tracked root directory *that are not
under Git tracking* (whereas ~git reset --hard~ will /not remove untracked files/).

#+begin_note
*WARNING -- BE CAREFUL WITH THIS!*  It is helpful to run a dry-run with ~git clean~
first, to see what it will delete.
#+end_note

Usage:
- ~git clean -n~ (dry run) to see what ~git clean -f~ will do, so you can be sure
  it's what you want.
- ~git clean -f~ (to *force removing* the *untracked files*) and
- ~git clean -d -f~ (to also *remove untracked directories* in addition to untracked
  files).

**** Soft option -- Clean branch (delete changes + untracked files)

#+begin_src conf
    clear-soft-dry-run = clean -d -n

    # THIS COMMAND MAY DELETE FILES THAT CANNOT BE RECOVERED.
    # Files and directories in .gitignore will be preserved.
    clear-soft = !git clean -d -f \
                      && git reset --hard
    # Discard current changes and throw out new files.
#+end_src

which:
- unstages changes in the index,
- discards changes in the working tree, and
- removes any new files (*all untracked changes will be lost*).

If you want to save your current branch's state before doing this (just in
case), you can do:

: git commit -a -m "Saving my work, just in case"
: git branch my-saved-work

**** Hard option -- Clean branch (delete ignored files in addition to changes + untracked files)

*NUCLEAR VERSION* which will:
- undo all your changes to *tracked* files,
- wipe out all the *ignored and untracked* files and directories, and
- start from the ~HEAD~.

#+begin_src conf
    # THIS COMMAND MAY DELETE FILES THAT CANNOT BE RECOVERED,
    # including those in .gitignore.
    clear-with-fire = !git clean -d -f -x \
                           && git reset --hard
#+end_src

** Merge

#+begin_src conf
  # Given a merge commit, find the span of commits that exist(ed).
  # Not so useful in itself, but used by other aliases.
  # Thanks to Rob Miller for the merge-span-* aliaes.
  merge-span = !"f() { echo $(git log -1 $2 --merges --pretty=format:%P | cut -d' ' -f1)$1$(git log -1 $2 --merges --pretty=format:%P | cut -d' ' -f2); }; f"

  # Find the commits that were introduced by a merge
  merge-span-log = "!git log $(git merge-span .. $1)"

  # Show the changes that were introduced by a merge
  merge-span-diff = !"git diff $(git merge-span ... $1)"

  # Show the changes that were introduced by a merge, in your difftool
  merge-span-difftool = !"git difftool $(git merge-span ... $1)"
#+end_src

** UPDATE - Pull

Starting with Git 1.7.0, ~@{u}~ is shorthand for the *current* branch's *upstream*
branch; e.g., ~origin/foo~ (or ~github/foo~, etc., since the remote doesn't have to
be called ~origin~) if the checked out branch is ~foo~.

#+begin_src conf
    # Information about the remote.
    remotes = remote
    r = remote -v
#+end_src

#+begin_note
~git pull~ is simply ~git fetch && git merge remote~.  Its ~--rebase~ option uses
~rebase~ instead of ~merge~.

That's exactly why some decide to avoid ~rebase~ (but to ~pull~ instead), because it
has bad effects if one merges from another branch and then wants to push.
#+end_note

About rebase (with visual aid):
https://itnext.io/become-a-git-pro-in-just-one-blog-a-thorough-guide-to-git-architecture-and-command-line-interface-93fbe9bdb395

*** Show incoming changes

The ~in~ command returns a list of *incoming* commits for the *current branch* --
after a ~git fetch~, to fetch down *all the data* it has for the *current remote* that
you do not --, the next time you do a merge.

#+begin_src conf
    # See changes committed by others
    in = !(git remote update -p && git log --decorate ..@{u})
#+end_src

#+begin_src conf
    in-files = log --stat ..@{u}
#+end_src

Show the changes between the last local commit and the *remote* branch:

Show a *single diffstat* (number of added and deleted lines for *all changed
files*):

#+begin_src conf
    in-what = diff --stat ...@{u}

    du = diff @{u} HEAD
    # diff with upstream branch
#+end_src

#+begin_warning
The upstream diff ~in-what~ will show the negative of unpushed (rebased) commits,
if any, with the ~..~ notation --- not with the ~...~ notation!
#+end_warning

*** Update with local modifications

#+begin_src conf
    pull = pull -v
#+end_src

#+begin_note
~git pull~ with uncommitted changes can succeed if the newly pulled changes don't
touch the locally changed files, but will fail otherwise.  Which makes a lot of
sense.
#+end_note

Git's fix is to ask you to commit (or stash) before you pull (which is fetch
followed by merge).

#+begin_src conf
    # up = "!git stash && git pull && git stash pop"
#+end_src

#+begin_warning
The above approach is *unsafe*: if there's nothing to stash, the first command
will do nothing, and then ~stash pop~ will unstash some random stuff from before.
#+end_warning

#+begin_src conf
    pull-autostash = ![ -z \"$(git status --porcelain -uno)\" ] && git pull || git stash push -m "autostash" && git pull && git stash pop
#+end_src

XXX What about ~git stash push --include-untracked~ and ~git stash pop~?

#+begin_src conf
    up = pull --rebase --autostash
    up = !git fetch && git rebase --autostash FETCH_HEAD
    up= "!git fetch $(git origin) && git branch -v -a"

    f = !git fetch --all && git rebase $(git origin)/master
#+end_src

See https://www.praqma.com/stories/git-autostash/.

: git rebase -i --autosquash --autostash

Really handy in projects that don't do merge commits.

See [[http://aanandprasad.com/git-up/][git-up]] (no longer maintained), which is (roughly) equivalent of executing the following:

: git stash
: git fetch --all
: [foreach branch]
:     git rebase --rebase-merges <branch> <remote>/<branch>
:     git merge --ff-only <branch>
: [end foreach]
: git checkout <prev_branch>
: git stash pop

#+begin_warning
Use with care: the final stash application after a successful rebase might
result in non-trivial conflicts.
#+end_warning

With *all versions* of Git, I recommend using ~git up~ instead of ~git pull~.

#+begin_src conf
    up-tmpname = "!f() { git remote update -p; git merge --ff-only @{u}; }; f"
#+end_src

It is pretty safe: it will abort the merge if it can't be done using
fast-forward.  (In other words, if the local branch has diverged from the
remote.)

See https://stackoverflow.com/questions/15316601/in-what-cases-could-git-pull-be-harmful

~remote update -p~ *fetches* all refs from all remotes, instead of just the needed
one; ~merge~ then merges the appropriate *single branch*.

#+begin_src conf
    # Rebasing non-linear changes (when the fast-forward merge is not possible).
    upr = "!f() { git remote update -p; git rebase -p @{u}; }; f"
#+end_src

#+begin_src conf
# cleanpull
# update (like svn? if we add a git reset in front?)
# sync
#+end_src

... but read "you're not using git as it was intended" on
https://news.ycombinator.com/item?id=2301765.

Before doing work (in a new branch), *ensure that the working tree is* *up-to-date*
with the ~origin~ (pull and get latest for all submodules):

#+begin_src conf
    # Get everything new.
    update = !git pull                     && git submodule update --init --recursive
    get    = !git pull --rebase            && git submodule update --init --recursive
    update = !git pull --rebase --prune $@ && git submodule update --init --recursive
#+end_src

[[https://gist.github.com/gitaarik/8735255][Git Submodules basic explanation]]

*** Update all local branches

Pull all:

#+begin_src conf
  # Do a push/pull for just one branch.
  push1 = "!git push $(git origin) $(git current-branch)"
  pull1 = "!git pull $(git origin) $(git current-branch)"

# Pull and push from the current branch.
sync = "!f(){ pull1 && push1; }; f"

    pull-all = !"OLD=$(git current-branch); \
                 for B in $(git for-each-ref refs/heads --format='%(refname)'); do \
                     git checkout ${B#refs/heads/}; \
                     git pull --ff-only; \
                 done; \
                 git checkout $OLD"
#+end_src

See http://stackoverflow.com/questions/4318161/can-git-pull-all-update-all-my-local-branches
(+ interesting comments about *rebase vs merge during a pull*!)

#+begin_src shell :tangle bin/git-up-all :shebang #!/usr/bin/env bash
REMOTES="$@";
if [ -z "$REMOTES" ]; then
    REMOTES=$(git remote);
fi
REMOTES=$(echo "$REMOTES" | xargs -n 1 echo)

CLB=$(git branch -l | awk '/^\*/{print $2}');

echo "$REMOTES" | while read REMOTE; do
    git remote update --prune $REMOTE
    echo
    git remote show $REMOTE -n \
        | awk '/merges with remote/ {print $5" "$1}' \
        | while read LINE; do
              RB=$(echo "$LINE" | cut -f1 -d" ");
              ARB="refs/remotes/$REMOTE/$RB";
              LB=$(echo "$LINE" | cut -f2 -d" ");
              ALB="refs/heads/$LB";
              NBEHIND=$(( $(git rev-list --count $ALB..$ARB 2> /dev/null) + 0));
              NAHEAD=$(( $(git rev-list --count $ARB..$ALB 2> /dev/null) + 0));
              if [ "$NBEHIND" -gt 0 ]; then
                  if [ "$NAHEAD" -gt 0 ]; then
                      echo -e "[$LB \tis $NBEHIND commit(s) behind and $NAHEAD commit(s) ahead of $REMOTE/$RB.]  Not possible to fast-forward, aborting.";
                  elif [ "$LB" = "$CLB" ]; then
                      echo -e "[$LB \tis $NBEHIND commit(s) behind of $REMOTE/$RB.  Fast-forwarding merge...]";
                      # git merge --quiet $ARB;
                      git merge --ff-only --verbose $ARB;
                  else
                      echo -e "[$LB \tis $NBEHIND commit(s) behind of $REMOTE/$RB.  Resetting local branch to remote...]";
                      # git branch -l -f $LB -t $ARB > /dev/null;
                      git branch -l -f $LB -t $ARB;
                  fi
              else
                  echo -e "$LB \tAlready up to date.";
              fi
              echo
          done
done
#+end_src

XXX Is this ~sync~?

*** Get timestamp of last pull

#+begin_src conf
    # For the latest pull (even if there's nothing new).
    last-pulled = !stat -c %y $(git root)/.git/FETCH_HEAD \
                       | cut -d'.' -f1

    # For the latest pull resulting in changes coming in from the remote master
    # branch (the timestamp won't change when git pull reports there are no
    # changes).
    last-updated = !stat -c %y $(git root)/.git/refs/heads/$(git current-branch) \
                        | cut -d'.' -f1
#+end_src

** UPDATE - Merge

Merging means to *bring the contents of another branch* (possibly from an external
repository) *into the current branch*. [...]  Merging is performed by an automatic
process that identifies changes made since the branches diverged, and then
applies all those changes together.

: Merge branch 'branch_name' into master

#+begin_src conf
    # Will only try to "merge" if your current HEAD commit is in the branch
    # you're merging in.  This will allow you to merge some commits whilst being
    # sure you won't get conflicts.
    mff = merge --ff-only
    mff = merge --ff-only @{u}

    # Avoid a fast-forward commit.
    mnf = merge --no-ff

    cvsmerge = merge --no-ff --log
#+end_src

*** Merge master

#+begin_src conf
    # Merge remote master into the current branch.
    mm = !git fetch -p \
              && git merge $(git origin)/master

    merge-to-master =  "!f(){ BRANCH_NAME=\"$(git symbolic-ref HEAD 2>/dev/null)\" || BRANCH_NAME=\"(unnamed branch)\"; \
                                  BRANCH_NAME=${branch_name##refs/heads/}; \
                                  git checkout master && git merge $BRANCH_NAME && git checkout $BRANCH_NAME; };f"
    fork-from-master = "!f(){ git checkout master && git branch $1 && git checkout $1; };f"
#+end_src

*** Undo the merge

If you tried a merge which resulted in complex conflicts and want to start over,
you can recover with ~git merge --abort~.  It will allow you to *undo the merge*,
even if it is a fast-forward merge.

*** Merge current branch into another one

On projects where we work with a staging or test branch, I regularly merge my
work in progress into it so others can test it.

#+begin_src conf
    m = "!f() { local OLD=$(git current-branch); \
                git co \"$1\" && git pu && git merge $OLD && git p && git co $OLD; }; f"
#+end_src

If you now type ~git m staging~ while on the ~feature~ branch, this will happen:

- First, the function checks out the ~staging~ branch.
- It then pulls the latest changes to the ~staging~ branch from origin.
- Then it merges ~feature~ into ~staging~.
- Next, it pushes the updated ~staging~ branch back to origin.
- Finally, it checks out the ~feature~ branch again.

Such a timesaver!

*** Dry run (do not make changes)

Naive (but slow) way:

: rm -Rf /tmp/repository
: cp -r repository /tmp/
: cd /tmp/repository
: git merge ...
: # ... If successful, do the real merge.

#+begin_warning
It won't work just cloning to =/tmp=; you need a *copy* in order *to be sure that
uncommitted changes will not conflict*.
#+end_warning

Performing a Git merge with *no commit* and *no fast-forward* will merge the two
code bases together -- it will *modify your working copy*.  This will allow you to
examine, test, and undo the merge if required.

: git merge --no-commit --no-ff $BRANCH

You can do ~git merge --abort~ after seeing that there are conflicts.

#+begin_src conf
    # Run merge test (before merge) to check for any conflicts beforehand.
    mergetest = "!f() { git merge --no-commit --no-ff \"$1\"; \
                        git merge --abort; \
                        echo \"Merge aborted\"; }; f"
#+end_src

#+begin_warning
If your repository is a live Web server, then you could be serving files with
conflicts in.  That's why you should *never* be *handling merges on a live Web
server*!  Fix up the ~master~ branch (on your development box) and then push it to
the real webserver with ~git pull --ff-only~.
#+end_warning

See if the merge is applicable to the current working tree and/or the index file
and *detects conflicts*:

#+begin_src conf
    # Check how the merge of `develop' into master will go:
    # git merge-dry-run develop
    merge-dry-run = "!f() { grep -q 'changed in both' <<< $(git merge-tree $(git merge-base FETCH_HEAD $1) FETCH_HEAD $1) \
                                && echo 'Merge conflicts!' \
                                || echo 'This branch can be automatically merged.'; }; f"
# DOESN'T work for git fetch & git merge

    # Extract the "changed in both" lines as well as the conflicting parts.
    merge-dry-run-conflicts = "!f() { git merge-tree $(git merge-base $1 $2) $1 $2 | sed -n '/+<<<<<<< .our/,/+>>>>>>> .their/p;/^changed in both/{n;N;N;s/^/#/mg;p}' | cdiff; }; f"
#+end_src

*** Branch/Integration manager

Often, during a *merge*, you know you want to take a file from one side wholesale;
that is, to select the entirety of either our or their file.

Pick a file(s) from:

- the *current branch*

#+begin_src conf
    ours = "!f() { git checkout --ours $@ && git add $@; }; f"
#+end_src

- the *branch being merged in*

#+begin_src conf
    theirs = "!f() { git checkout --theirs $@ && git add $@; }; f"
#+end_src

#+begin_warning
During a *rebase*, the commits being merged into the current branch /are/ the
commits from your original feature branch.  So ~--ours~ and ~--theirs~ will appear
to be *flipped* around.
#+end_warning

#+begin_note
Using ~git checkout~ with ~--ours~ or ~--theirs~ expects at least one argument: the
*path(s)* of the *files / directories* to checkout.  If you use ~git checkout~ without
any files, then it takes the meaning of /switching branches/.
#+end_note

*Best (and safest) way to merge* a Git local branch into =master=:

: git checkout master
: git pull $(git origin) master           # Get the latest changes from the remote.
: git merge test
: git push $(git origin) master
:
: git branch -d local_branch_name         # Delete local branch.

#+begin_warning
*Update first the branch (to merge in) of the RIGHT LOCAL CLONE.* -- if you do
have many clones on your file system.
#+end_warning

Best answer I have seen on ~git merge~ *strategies*:
https://stackoverflow.com/questions/366860/when-would-you-use-the-different-git-merge-strategies

*** Show list of files in a conflict state

List unmerged files (after a merge failure), having leftover conflict markers:

#+begin_src conf
    conflicts = diff --name-only --diff-filter=U
#+end_src

See also ~git diff --check~.

Quickly solve conflicts using an editor.

#+begin_src conf
    edit-unmerged = "!$EDITOR $(git conflicts)"
#+end_src

Then, add the conflicted files.

#+begin_src conf
    add-unmerged = "!git add $(git conflicts)"
#+end_src

** BRANCH - Branch

*** Feature Branches

#+begin_src conf
    # Create a feature branch.
    feature = "!f() { git create-branch feature/$1 develop; }; f"
    # XXX or feature-start?

    # Incorporate a finished feature on develop.
    feature-finish = "!f() { git checkout develop; \
                             git merge --no-ff feature/$1 \
                             && git delete-local-branch feature/$1; }; f"

    # XXX Also bug and refactor.

    # XXX release-start
    # XXX release-finish
#+end_src

https://medium.com/gumgum-tech/git-and-git-flow-a-guide-871d46a0ebcb

Alias configuration for our feature branches, like a simple git flow for feature
stories, or hotfix patches, etc.

Create a new feature branch:

: feature-start = '!BRANCH=$1; git checkout master; git pull; git create-branch "$BRANCH" master'

Update the feature branch:

: feature-pull = '!BRANCH=$(git current-branch); git checkout master; git pull; git checkout "$BRANCH"; git rebase master'

Share the feature branch:

: feature-push = '!BRANCH=$(git current-branch); git push -u $(git origin) "$BRANCH"'

If your team uses a different feature flow, you may want to skip including these
aliases, or you may want to edit these aliases to match your team's feature flow.

*** Git workflows

It may be helpful to do a some background reading on workflows with Git.  Here
is the gitworkflows man page:
https://www.kernel.org/pub/software/scm/git/docs/gitworkflows.html

Other doc on branching models:

http://www.draconianoverlord.com/2013/09/07/no-cherry-picking.html
http://williamdurand.fr/2012/01/17/my-git-branching-model/

*** General

See http://nuclearsquid.com/writings/git-tricks-tips-workflows/ for more
interesting stuff, such as:

- When branching off a remote branch, automatically let the local branch track
  the remote branch.

- When pushing without giving a refspec, push the current branch to its upstream
  branch. See the git config man page for more possible options.

#+begin_src conf
    # Shortcut for checkout.
    co = checkout
#+end_src

Check out the next commit in the commit history -- quite useful for demos to
jump across commits:

#+begin_src conf
    next = "!f() { git checkout $(git rev-list --topo-order HEAD..master | tail -1; }; f"
#+end_src

*** If you get the error "The following untracked working tree files would be overwritten by checkout"

#+begin_src text :tangle no
error: Your local changes to the following files would be overwritten by checkout:
        WEB-INF/config/afm-projects.xml.DEV-fni
        WEB-INF/config/context/logging/logging.xml
Please commit your changes or stash them before you switch branches.
error: The following untracked working tree files would be overwritten by checkout:
        WEB-INF/config/afm-projects.xml
Please move or remove them before you switch branches.
#+end_src

One solution is to *move the untracked files*, instead of *deleting them*.  For
example:

: cd "$(git root)"
: git checkout BRANCH_NAME 2>&1 \
:     | while read F; do \
:           [ ! -e "$F" ] || mv -v "$F" "$F.bak"; \
:       done

Another is to throw away local changes using a *forced checkout*:

: git checkout -f SOME_BRANCH

*** Website and page hosting

You can easily host websites directly in your repository hosting service.  And
open HTML files directly from the file browser.

For GitHub pages:

#+begin_src conf :tangle no
echo 'setting up gh-pages'
echo '-------------------'

echo 'Tell me your github account username: '
read USER_NAME

echo 'Now, tell me your repository name: '
read REPOSITORY

git stash \
    && git create-branch 'gh-pages' \
    && echo 'My Page' > index.html \
    && git add . \
    && git commit -a -m 'Initial commit' \
    && git remote add $(git origin) https://github.com/"$USER_NAME"/"$REPOSITORY".git \
    && git push -u $(git origin) gh-pages \
    && echo 'Complete' \
    && echo '-------------------' \
    && echo 'You can find your last changes in the stash!'
#+end_src

For Bitbucket:
https://marketplace.atlassian.com/apps/1212525/pages-for-bitbucket-server?hosting=server&tab=overview

*** Show unmerged commits between two branches

The alias ~missing~ (an idea borrowed from Bazaar) shows the unique commits in the
current branch and the specified branch.

#+begin_src conf
    # Usage: git missing [COMMIT_ISH]
    # Show the missing commits between this and another branch
    missing = "!f() { \
            git rev-list --pretty='format:%C(auto)%ad %h %s' --date=short "${1:-master}".. \
                | awk 'NR%2==0' \
                | sed -e '1 iOnly in HEAD:'; \
            printf \"\n\"; \
            git rev-list --pretty='format:%C(auto)%ad %h %s' --date=short .."${1:-master}" \
                | awk 'NR%2==0' \
                | sed -e '1 iOnly in other:'; \
        }; f"
#+end_src

**** Fork point

The *common ancestor* is the last commit that existed in both branches. Usually
this is the branch point, but it could also be a commit that was merged.

#+begin_src conf
    # Find the point at which a branch forked from another branch
    ancestor = !zsh -c 'diff --old-line-format='' --new-line-format='' <(git rev-list --first-parent "${1:-master}") <(git rev-list --first-parent "${2:-HEAD}") | head -1' -
#+end_src

#+begin_src conf
    # Find the point at which a branch forked from another branch
    ancestor2 = !sh -c 'git rev-list --boundary "${1:-HEAD}"..."${2:-master}" | grep "^-" | cut -c2-'
#+end_src

When you use three dots (...), ~git diff~ finds the merge-base between the left
and right side commit SHAs (as obtained from the names, or defaulting to =HEAD=)
and substitutes that in for the left-side SHA. The right-side SHA (as resolved
from the name) remains intact.

#+begin_src conf
    # Find the point at which a branch forked from another branch
    # Best common ancestor (when it was branched off).
    ancestor3 = "!f() { git show --summary $(git merge-base $(git origin)/$1 $(git current-branch)); }; f"

    # Also:
    # git merge-base --fork-point master
    # git merge-base --all r1 r2
#+end_src

https://stackoverflow.com/questions/1527234/finding-a-branch-point-with-git

The common ancestor is frequently used with ~diff~ to return all of the changes
that your branch introduces, while excluding the changes that you have not
merged from the remote branch.

#+begin_src conf
    # Since fork point.
    diff-ancestor = !sh -c 'git diff $(git ancestor)..'
    log-ancestor = !sh -c 'git log $(git ancestor)..'
#+end_src

*** See which changes from a branch are already present upstream

While on =feature= branch:

: git cherry -v master

#+begin_example
+ 497034f2 Listener.new now accepts a hash of options
- 2d0333ff Cache the absolute images path for growl messages
+ e4406858 Rename Listener#run to #start
#+end_example

The ~cherry~ command is useful to see which commits have been cherry-picked from
a development branch to the stable branch, for instance. This command compares
changes on the current (=feature=) branch to upstream (=master=) and indicates which
are present on both with the ~-~ sign. Changes still missing from upstream are
marked with ~+~.

*** Recover a branch after its deletion in Git

Most of the time unreachable commits are in the reflog. So, the *first thing to
try is to look at the reflog* using the command ~git reflog~ (which display the
reflog for =HEAD=).

1. Perhaps something easier if the commit was part of a specific branch still
   existing is to use the command ~git reflog name-of-my-branch~ to *find the SHA*
   for the commit at the tip of your deleted branch -- It works also with
   a remote, for example if you forced push.  Otherwise, use ~git reflog~.

2. Then, you can just ~git create-branch BRANCH SHA1~ to recreate the branch from
   there.

See https://stackoverflow.com/questions/3640764/can-i-recover-a-branch-after-its-deletion-in-git

*** Show branches and their commits

#+begin_src conf
    # "show-branch -g=N" can't be aliased for N easily, so we stop here:
    sb  = show-branch
    # pg sbt master pu -- if the last line is 'master' and not 'master~'
    # or 'master~N' then pu is a descendent of master
    sbt = show-branch --topics
    sbs = show-branch --sha1-name
#+end_src

** Stash (shelve)

A *stash* is nothing but a *(temporary) branch*.

~git stash~ makes a temporary copy of the changes in your *index* (staging area) and
*working tree*, and clears the decks so you can easily work on something else; it
reverts your local modifications, allowing you to get rid of some incomplete
changes.

#+begin_tip
Use ~git stash~ if Git refused to merge because it foresees conflicts.
#+end_tip

If you anticipate that you might have trouble merging the work you want to stash
with the work you're about to do on the clean tree, you can create a new branch
with ~git stash branch NEW_BRANCH_NAME~.

Information that is used by default if you don't provide a message:

#+begin_example
stash@{0}: WIP on BRANCH: SHA1_OF_HEAD TITLE_LINE_OF_HEAD
#+end_example

You can operate on the "stash" ref as if it were any other ref.

*** Stash push

~git stash push~ also optionally takes a message describing the contents of the
stash (much, much more useful):

#+begin_src conf :tangle no
git stash push -m "Describe what you did here"
#+end_src

#+begin_example
stash@{0}: On BRANCH: Describe what you did here
#+end_example

This command is useful in saving all changes not ready to be committed and the
user wants to have an updated repository.

#+begin_src conf
    spush = stash push
#+end_src

#+begin_src conf
    # Like sapply but shows it only.
    sshow = "!f() { \
            git stash show stash^{/$@} -p; \
        }; f"

    # Find stash with name like text.
    sapply = "!f() { \
            git stash apply stash^{/$@}; \
        }; f"

    # Like sapply but pops it off.
    spop = "!f() { \
            git stash pop stash@{$(git stash-id $@)}; \
        }; f"

    # Only accepts single word, no quotations.
    stash-id = "!f() { \
            git stash list \
                | grep $@ \
                | head -n 1 \
                | sed -n 's/stash@{\\(.*\\)}.*/\\1/p'; \
        }; f"
#+end_src

#+begin_src conf
stashall = !git add -A && git stash
# "Add" modified files, deleted files, and new untracked files.
#+end_src

#+begin_src conf
    hide = stash push --include-untracked # Hide all files, including untracked files (faster than using --all).
#+end_src

*** Take named stash

"WIP:"

#+begin_src conf
    snapshot = !git stash push -m "snapshot-$(date +%Y%m%d_%H%M)" \
                    && git stash apply "stash@{0}"
#+end_src

#+begin_src conf
    # checkpoint
    cp = !git stash push -m "$(date +%F--%T)" && git stash pop --index

    # checkpoint recover
    cpr = "!f() { \
            git fsck \
                | grep commit \
                | cut -d' ' -f3 \
                | while read HASH; do \
                      git rev-parse --verify --no-revs --quiet $HASH^2 2>/dev/null \
                          && echo $HASH \
                          | xargs git rev-list --since=${1:-1day} -1; \
                  done \
                | xargs -L 1 git log --format=%at:%h -1 \
                | sort \
                | cut -f2 -d: \
                | xargs -L 1 git log --graph --oneline --format='%Cblue%h %Cgreen(%ar) %Creset%s' -3; \
        }; f"
#+end_src

*** Show a list of all stashes

#+begin_src conf
    stashes = stash list --date=local
#+end_src

*** Show the stash

#+begin_src conf
    stash-diff = stash show -p
#+end_src

https://stackoverflow.com/questions/11269256/how-to-name-and-retrieve-a-stash-by-name-in-git:

#+begin_src conf
    sshow = "!f() { \
            git stash show stash^{/$*} -p; \
        }; f"
#+end_src

One very useful feature one may consider is to list contents of all local
stashes:

: git stashes | awk -F: '{ print "\n\n\n\n"; \
:                          print $0; \
:                          print "\n\n"; \
:                          system("git stash show -p " $1); }'

Press [Q] to exit each stash.

It helped me a lot in the past (cleaning stashes stack).

*** Show name-only

#+begin_src conf
    sshno = stash show --name-only
#+end_src

*** Apply the stash only, don't delete it from the stash list

When you're done, with ~git stash apply~ (top stash by default), you're back where
you were.  But if that doesn't work, for whatever reason, you can use any of
Git's other branch merging tools to put things back they way you want them.

#+begin_src conf
    sa = stash apply
#+end_src

https://stackoverflow.com/questions/11269256/how-to-name-and-retrieve-a-stash-by-name-in-git:

#+begin_src conf
    sapply = "!f() { \
            git stash apply stash^{/$*}; \
        }; f"
#+end_src

#+begin_src conf
    stash-unapply = !git stash show -p --no-textconv --binary | git apply -R
#+end_src

*** Stash pop

~git stash pop~ removes the most recent stash or any stash specified and applies
changes as a merge.  If merge fails, the stash is not removed from the list and
must be removed manually.

#+begin_src conf
    sp = stash pop
#+end_src

#+begin_warning
Be aware that, unlike ~git stash apply~ (though it has its use), ~git stash pop~
*deletes the applied stash* -- /only/ if the stash is cleanly applied.  If there are
conflicts, Git will not remove it (but it will still apply it)!
#+end_warning

*** Drop the stash

#+begin_src conf
    std = stash drop
#+end_src

*** Clear

: git stash clear

*** Workflows

Alternative to ~stash~ (writing a commit with a default message):

XXX See doc of git help stash for workflows...

1. Do a regular ~commit~:

   : git add -A && git commit -m 'WIP'       # Add all changes (including untracked files).

2. Do some other work...

3. Return to previous work:

   : git reset --mixed                       # Reset the previous commit (but
   :                                         # keeps all the changes from that
   :                                         # commit in the working tree).
   :
   : git reset --soft                        # Or this one???

   Or, if I merely need to modify the *previous* commit:

   : git commit -a --amend

   The ~-a~ *adds any modifications and deletions of existing files* to the commit
   but ignores brand new files.

   The ~--amend~ launches your default commit editor and lets you change the
   commit message of the *most recent* commit.

*** From git help stash

       Pulling into a dirty tree

           When you are in the middle of something, you learn that there are
           upstream changes that are possibly relevant to what you are
           doing. When your local changes do not conflict with the changes in
           the upstream, a simple git pull will let you move forward.

           However, there are cases in which your local changes do conflict with
           the upstream changes, and git pull refuses to overwrite your
           changes. In such a case, you can stash your changes away, perform
           a pull, and then unstash, like this:

               $ git pull
                ...
               file foobar not up to date, cannot merge.
               $ git stash
               $ git pull
               $ git stash pop

       Interrupted workflow

           When you are in the middle of something, your boss comes in and
           demands that you fix something immediately. Traditionally, you would
           make a commit to a temporary branch to store your changes away, and
           return to your original branch to make the emergency fix, like this:

               # ... hack hack hack ...
               $ git create-branch my_wip
               $ git commit -a -m "WIP"
               $ git checkout master
               $ edit emergency fix
               $ git commit -a -m "Fix in a hurry"
               $ git checkout my_wip
               $ git reset --soft HEAD~
               # ... continue hacking ...

           You can use git stash to simplify the above, like this:

               # ... hack hack hack ...
               $ git stash
               $ edit emergency fix
               $ git commit -a -m "Fix in a hurry"
               $ git stash pop
               # ... continue hacking ...

       Testing partial commits

           You can use git stash push --keep-index when you want to make two or
           more commits out of the changes in the work tree, and you want to
           test each change before committing:

               # ... hack hack hack ...
               $ git add --patch foo            # add just first part to the index
               $ git stash push --keep-index    # save all other changes to the stash
               $ edit/build/test first part
               $ git commit -m 'First part'     # commit fully tested change
               $ git stash pop                  # prepare to work on all other changes
               # ... repeat above five steps until one commit remains ...
               $ edit/build/test remaining parts
               $ git commit foo -m 'Remaining parts'

       Recovering stashes that were cleared/dropped erroneously

           If you mistakenly drop or clear stashes, they cannot be recovered
           through the normal safety mechanisms. However, you can try the
           following incantation to get a list of stashes that are still in your
           repository, but not reachable any more:

               git fsck --unreachable |
               grep commit | cut -d\  -f3 |
               xargs git log --merges --no-walk --grep=WIP

** PUBLISH - Push

*** Show outgoing changes: commits that are on the local branch that have not been pushed

It is useful to know if you have any *local commits* that are not in the remote
branch.

#+begin_note
It is a good idea to examine what you are about to push, before actually doing
so, because fixing mistakes before pushing is much easier. To do that, use the
command "git diff origin/master". If you want to show your unpushed commits with
their commit log messages, use "git show origin/master.." instead. If you only
have one local commit you want to push, just "git show" is enough.

> It is not clear to me how these two differ.  Does "git show origin/master.."
> output everything that "git diff origin/master" outputs, plus log messages?

Yes, that's the only real difference between them, when you have no uncommitted
changes.  (When you do have uncommitted changes, "git diff" will include them,
while "git show" will not.)
#+end_note

The ~out~ command returns a list of *unpushed* (outgoing) commits for the *current
branch*, the next time you do a push.

#+begin_src conf
    # See what is not pushed to remote branch.
    out = log --date=short @{u}..
#+end_src

#+begin_src conf
    out-files = log --stat --date=short @{u}..
#+end_src

This causes ~git log~ to show all commits reachable from =HEAD= excluding those
reachable from the upstream branch.  The ~@{u}..~ argument is equivalent to
~@{u}..HEAD~, where =HEAD= stands for the last commit in your local branch, but =HEAD=
can be omitted for shorthand purposes.

If you want to see all *unpushed* commits from *all branches*, do this:

#+begin_src conf
    # See all local commits.
    outgoing = log --branches --not --remotes --decorate
#+end_src

*** Upload your changes

#+begin_src conf
    # Get the upstream branch name.
    upstream-name = !git for-each-ref --format='%(upstream:short)' $(git symbolic-ref -q HEAD)
#+end_src

#+begin_src conf
    upstream = !git log --oneline --no-merges HEAD..${1-$(git branch -lvv | perl -ne '/^\\*.*\\[(.*?)\\]/ and print "$1\n"')}
    local = !git log --oneline --no-merges ${1-$(git branch -lvv | perl -ne '/^\\*.*\\[(.*?)\\]/ and print "$1\n"')}..HEAD
#+end_src

** PUBLISH - Find out if a change is part of a release

#+begin_src conf
    sha1-tag = "!f() { \
            git name-rev --name-only \"$@\"; \
        }; f"
#+end_src

The ~name-rev~ command indicates the *position of a commit relative to tags* in the
project. For example, ~v2.3~5~ means that this commit is located 5 commits *before*
the v2.3 tag -- we can be certain that this change is part of v2.3, then.

** Create patches

#+begin_src conf
    lll = log -u
#+end_src

*** Creating a patch

1. Make your changes and commit them.

2. Run

   : git format-patch COMMIT_REFERENCE

   to convert all commits since the referenced commit (not including it) into
   patch files.

   For example:

   : git format-patch HEAD~

*** Applying the patch

: git am *.patch

Error while applying a patch

: git am--ignore-whitespace 0001-my-awesome-change.patch

When ~git apply~ is working normally, you get no output at all:

: git apply 0001-my-awesome-change.patch

[nothing returned]

If you want to see what's going on behind the scenes, you can use the ~-v~
(verbose) flag:

: git apply -v 0001-my-awesome-change.patch

Use ~patch -p1 < filename.patch~. Whereas ~git-apply~ altogether rejects a patch
with any errors, ~patch -p1~ works hunk by hunk, applying as many individual
changes as it can. It backs up each file as =filename.ext.orig= before modifying
it and saves rejected hunks in =filename.ext.rej=. Discard the =.orig= files and
manually apply the changes left in the =.rej=. This is an easy strategy for small
patches.

*Applying Patches* with different line endings error on Cygwin:

: patch -t -N -r - -p1 -i 0001-my-awesome-change.patch

*** Apply patches from URL

#+begin_src conf
    # Apply a patch to files and/or to the index from URL.
    apply-url = "!f() { \
            curl -s $1 2>nul \
                | git apply ${@:2}; \
        }; f"
#+end_src

: git apply-url http://example.org/sample.patch args

#+begin_src conf
    # Apply a series of patches from an URL.
    am-url = "!f() { \
            curl -s $1 2>nul \
                | git am ${@:2}; \
        }; f"
#+end_src

: git am-url http://example.org/sample.patch args

*** Apply a patch interactively

#+begin_src conf
    # Interactive apply patch.
    ipatch = "!f() { \
            git apply $1; \
            git add -p; \
        }; f"
#+end_src

: git ipatch mypatchfile

*** Patch shortcuts

#+begin_src conf :tangle no
# Copy a patch URL to the clipboard, then run one of these commands to download
# the patch and apply it. Hat tip to @chrisjlee for making me reconsider curl.

# Apply
alias cap='curl $(pbpaste) | git apply -v'

# Apply and stage
alias cape='curl $(pbpaste) | git apply -v --index'

# Apply with `patch'
alias capp='curl $(pbpaste) | patch -p1'

# Reverse apply
alias carp='curl $(pbpaste) | git apply -Rv'

# Reverse apply and stage
alias carpe='curl $(pbpaste) | git apply -Rv --index'

# Verify patch
alias cav='curl $(pbpaste) | git apply -v --check'

# Verify patch with `patch'
alias capv='curl $(pbpaste) | patch -p1 --dry-run'
#+end_src

** PUBLISH - Prepare a release

See https://github.com/aiidateam/aiida-core/wiki/How-to-make-a-new-release

*** ChangeLog

Generate the ChangeLog (for your [[https://keepachangelog.com/][CHANGELOG.md]]) with all commit messages since
the last tag.

A properly formed Git commit subject line should always be able to complete the
following sentence:

: If applied, this commit will YOUR_SUBJECT_LINE_HERE

How to write a good commit message + A changelog generation:
https://dev.to/gaelthomas/a-beginner-s-guide-to-git-how-to-write-a-good-commit-message-2j49
https://dev.to/chrissiemhrk/git-commit-message-5e21
https://dev.to/helderburato/patterns-for-writing-better-git-commit-messages-4ba0

#+begin_src conf
    # Detailed list of changes.
    changelog1 = !git log --oneline --no-merges ${1-$(git last-tag)}..HEAD
    changelog = !sh -c 'git log --no-merges --pretty=format:\"* %s\" $(git last-tag)...' -
    changelog-org = !sh -c 'git log --no-merges --pretty=format:\"- %s\" $(git last-tag)...' -
#+end_src

XXX git log --pretty=format:"- %s" 2019.10.10...HEAD displays too many entries on mcpflow repo

# Use it like this:
#
# #+begin_src shell :tangle no
# git changelog FIRST_TAG_NAME LAST_TAG_NAME
# #+end_src

See also
- https://github.com/github-changelog-generator/github-changelog-generator
- https://github.com/github-changelog-generator/github-changelog-generator/wiki/Alternatives

**** Today

Quickly see what you've done today (list commits that aren't merges, on *all
branches*):

#+begin_src conf
    today = log --since=midnight --author=\"$(git config user.name)\" --no-merges --all --pretty='%C(green)%ad%C(auto) - %s' --date=format:'%Y-%m-%d %a %H:%M'
    today2 = !git log --all --since=00:00:00 --oneline --no-merges --author=${1-$(git config user.email)}
    today-all = log --since=midnight --no-merges --all

    yesterday = log --since='1 day ago midnight' --until=midnight --author=\"$(git config user.name)\" --no-merges --all --pretty='%C(green)%ad%C(auto) - %s' --date=format:'%Y-%m-%d %a %H:%M'
    this-week = log --since=1.weeks --author=\"$(git config user.name)\" --no-merges --all --pretty='%C(green)%ad%C(auto) - %s' --date=format:'%Y-%m-%d %a %H:%M'
#+end_src

Show changes for a daily standup meeting:

#+begin_src conf
    # Summarize your own changes since 24h, suitable for a daily standup meeting.
    log-standup = log --since=yesterday --author=\"$(git config user.email)\" --pretty=short

    standup = "!git log --branches \
                        --since=$(if [ "$(date +%a)" = "Mon" ]; then \
                                      echo "friday"; \
                                  else \
                                      echo "yesterday"; \
                                  fi) \
                        --author=$(git config --get user.email) \
                        --format=format:'%C(green) %ad %C(yellow)%h %Creset %s %C(green bold)%d' \
                        --date=local"
# XXX git standup W donne un décompte avec une ligne trop peu !
#+end_src

*** Release assets

Generate =zip= archived source code from the given Git tag.

I use this when zipping the current branch with the name of the zip file as the
current tag.  Useful for uploading to Elasticbeanstalk.

#+begin_src conf
    current-tag = tag --points-at HEAD
    zip = "!f() { \
            git archive --format=zip -o $(git current-tag).zip HEAD; \
        }; f"
#+end_src

#+begin_src conf
    export-branch = !git format-patch --stdout $1 > ~/$(git current-branch).diff
#+end_src

Save a repo (for example, ~HEAD~ or ~master~ -- or any other branch to archive, if
you've already checked it out) as a tarball:

#+begin_src conf
    export-zip = archive -o latest.zip
    export-tgz = archive -o latest.tar.gz -9
#+end_src

Note that the /output format/ is inferred by the extension of the output file.

#+begin_src conf
    # Usage: git export-commit [COMMIT_ISH]
    export-commit = "!f() { \
            git changed-files ${1:-HEAD} \
                | tr '\\n' '\\0' \
                | xargs -0 zip -9 $(git repo-slug)-commit-$(git current-branch-without-slash)-${1:-$(git commit-hash)}.zip; \
        }; f"
#+end_src

XXX This does not handle spaces in file names

To see the contents of the zipped file (without extraction), use ~unzip -l FILE~.

#+begin_src conf
    # View raw commit.
    email-patch = XXX git format-patch $(git current-branch).patch

    # Since oldest ancestor...
    plain-diff = !git branch-diff > $(git current-branch).diff
#+end_src

Patch = this

: From 69936b7cc23c9ae78cec84baa30c599c1ad5990a Mon Sep 17 00:00:00 2001
: From: Brett Viren <brett.viren@gmail.com>
: Date: Fri, 2 Oct 2020 10:30:17 -0400
: Subject: [PATCH] Move doc to index.org and generate index.html, README.org
:  holds short links.
:
: This is meant to demo serving the refcard via GH pages.  The
: README.org probably deserves more attention!
:
: Content modified:
:
: - Switched to online SETUPFILE.  Maybe better to carry a copy of readtheorg?
:
: - I had problems related to id:<hash> and so switch a reference to use
:   the headline text.
:
: - Pointed UP and HOME to links related to the refcard.
: ---
:  README.html | 4118 ---------------------------------------------------
:  README.org  | 1673 +--------------------
:  index.html  | 3308 +++++++++++++++++++++++++++++++++++++++++
:  index.org   | 1672 +++++++++++++++++++++
:  4 files changed, 4984 insertions(+), 5787 deletions(-)
:  delete mode 100755 README.html
:  mode change 100755 => 100644 README.org
:  create mode 100644 index.html
:  create mode 100755 index.org

+ diff.

#+begin_src conf
    patch-for-this = "!git diff -p $(git hash-object -t tree /dev/null)"
#+end_src

** PUBLISH - Tag

When tagging releases in a version control system, the tag for a version should
be ~X.Y.Z~ (*without* prefix ~v~).  The advantages of ~X.Y.Z~ are that gitweb or GitHub
can automatically offer a tarball or zip download of the form
=packagename-$tag.tar.gz= (and it's quite established that a tarball should be
named =package-X.Y.Z.tar.gz=).

Savoir quels sont les commits de ma branche courante depuis le dernier tag, afin
de savoir ce qu'embarquera la « prochaine release » de mon projet.

#+begin_src conf
    # le dernier tag, ainsi que la liste des commits ayant eu lieu depuis sur la
    # branche courante.
    unreleased = !git log --oneline $(git last-tag)...HEAD \
                      && git last-tag
#+end_src

** Debugging

Sometimes it's nice to see what is going on under the hood. Try this alias:

#+begin_src conf
    debug = "!set -x; GIT_TRACE=2 GIT_CURL_VERBOSE=2 GIT_TRACE_PERFORMANCE=2 GIT_TRACE_PACK_ACCESS=2 GIT_TRACE_PACKET=2 GIT_TRACE_PACKFILE=2 GIT_TRACE_SETUP=2 GIT_TRACE_SHALLOW=2 git"
#+end_src

Just insert ~debug~ between ~git~ and whatever would usually follow; for example:

: git debug changed

** Abbreviations

Basic shortcuts.

#+begin_src conf
    cp = cherry-pick -x
    pick = cherry-pick -s

    # cherry-pick - apply the changes introduced by some existing commits; useful for moving small chunks of code between branches.
    cp = cherry-pick

    # cherry-pick without making a commit, and when when recording the commit, append a line that says "(cherry picked from commit ...)"
    cp-nx = cherry-pick --no-commit -x
#+end_src

This command has some useful parameters:
- -e to edit git message
- -x to add a line "Cherry-picked commit" in the commit message
- --no-commit or -n to apply the commit changes in the unstaged area (unstead of
  creating a commit in the branch)

#+begin_src conf
    h = help
#+end_src

** Show the path to root directory of Git repo

#+begin_src conf :tangle no
    # Get the path cleaned up.
    root = !pwd -P
#+end_src

#+begin_note
This works because Shell aliases are always executed in the top-level directory.
#+end_note

#+begin_src conf
    root = rev-parse --show-toplevel
    root-relative = rev-parse --show-prefix
#+end_src

** Sync

Fetch Git objects from upstream and update local branches.

- If the local branch is outdated, fast-forward it;
- If the local branch contains unpushed work, warn about it;
- If the branch seems merged and its upstream branch was deleted, delete it.

#+begin_src conf
    # Pull then push current branch.
    sync = !git pull && git push
#+end_src

#+begin_src conf
    sync = !git update && git co master && git pull && git commit @{-1}
#+end_src

That's rather basic -- it doesn't actually rebase my branch that I'm on.

Let's do a slightly different command: ~resync~

#+begin_src conf
    # git resync -> sync repository and rebase current branch.
    resync = !sh -c 'git checkout master \
                         && git fetch \
                         && git reset --hard $(git origin)/master \
                         && git rebase master'
#+end_src

** Cherrypick style recording

Ask interactively which patch hunk to commit, and then do the commit:

#+begin_src conf
    # Show record of pending changes, letting you choose which patch hunks to commit.
    commit-interactive = !sh -c '(git add -p -- $@ && git commit) || git reset' --
    record = !git commit-interactive
#+end_src

It will not only do ~git add -p~ (with an optional file list), but it will also
immediately do the ~commit~. Upon abandonment of either the add or the commit, it
will ~reset~ the index.

** Dangling

- Dangling blob = Change(s) that made it to the staging area/index but never got
  committed. One thing that is amazing with Git is that once it gets added to
  the staging area, you can always get it back because these blobs behave like
  commits!!

- Dangling commit = A commit that isn't linked to any branch or tag either
  directly or by any of its ancestors. You can get these back too!

#+begin_src conf
    lost1 = "!git fsck | awk '/dangling commit/ {print $3}' | git show --format='SHA: %C(yellow)%h%C(reset)  %s' --stdin | awk '/SHA/ {sub(\"SHA: \", \"\"); print}'"
    lost2 = "!git fsck | awk '/dangling commit/ {print $3}' | git show --format='SHA1: %C(yellow)%h%Creset %f' --stdin | awk '/SHA1/ {sub(\"SHA1: \", \"\"); print}'"

    zopa = !git log --graph --decorate --pretty=oneline --abbrev-commit --all $(git fsck --no-reflogs | grep commit | cut -d\\  -f3)
#+end_src

* Download repository

** Easily launch a temporary one-off Git server from any local repository, to enable a peer-to-peer Git workflow

#+begin_src conf
    serve = "daemon --verbose --export-all --base-path=.git --reuseaddr --strict-paths .git/"
    serve = "-c daemon.receivepack=true daemon --base-path=. --export-all --reuseaddr --verbose"
#+end_src

1. Run git serve. "Ready to rumble," it will report. Git is bad-ass.
2. Find out your IP address. Say it's 192.168.1.123.
3. Say "hey Jane, I'm not ready/able to push these commits up to origin, but you
   can fetch my commits into your clone by running git fetch
   git://192.168.1.123/"
4. Press ctrl+c when you don't want to serve that repo any longer.

* What if

... I'm working on =master= adding a simple feature. After a few minutes I realize
it was not so simple and it should have been better to work into a new branch.

http://stackoverflow.com/questions/2569459/git-create-a-branch-from-unstaged-uncommited-changes-on-master

* If you made a mistake

Absolutely read https://github.com/blog/2019-how-to-undo-almost-anything-with-git!

* If you get errors...

Many situations may cause "errors":

- merge conflicts (two people editing the same part of the same file)

- unmerged changes (another person committed a change before you did, so you
  need to merge their changes first)

- attempting to recover from a situation such as an accidental merge, and making
  the situation worse.

https://explainxkcd.com/wiki/index.php/1597:_Git

** Method 1

It is POSSIBLE that a safe way to recover from your problems is as follows:

: git stash
: git reset --hard HEAD
: git pull --ff-only
: git stash apply

Of course, if any of the commands but the last fails, stop and ask for advice
again. If the last one reports merge conflicts, fix them by hand and run ~git add~
on each file after you fixed it. DO NOT use C-x v v after fixing a merge
conflict, since that runs both git add and git commit, and you are not ready for
the latter until all merge conflicts are dealt with.

In any case, do run git status before finally doing git commit. If all succeeds,
you can clean up with:

: git stash drop

** Alternative

If your =master= branch is busted, rename it to something else so that it's out of
the way:

: git rename-local-branch master master-busted

Create a new branch =master= that tracks the origin:

: git branch --track master $(git origin)/master

Check it out (be careful, this will discard all your local changes):

: git checkout -f master

Make sure the =master= is up-to-date:

: git pull

** A GitHub test repository to experiment with conflicts

You can experiment with resolving a Git conflict with this repository:
https://github.com/brianleetest/testGit/blob/master/README.md

* GitHub tasks

# https://github.com/abo-abo/oremacs/blob/github/etc/org/wiki/git.org

** Force push

: git push --force $(git origin) master

*** Doc about push failure

If a push fails, that does not necessarily indicate a "bad state" -- it simply
represents that your history is different than what the remote server has, and
that the tip of the branch you are pushing to cannot simply be "fast-forwarded"
to your commit.

After a failed push, you are in no different state than you were before the push
(aside from a possibly puzzled mental state).

In your case, since you just want to commit and push in one operation, you
likely want to run ~git pull --rebase~, which would get those changes and then
automatically re-commit your work on top of them, as if you had those changes
all along.  You could then push.  So, something like:

#+begin_src shell :tangle no
# Commit all changes and attempt to push, pulling in changes if necessary and
# re-pushing; on failure, restore to previous state with changes uncomitted.
git commit -am Foo \
    && {
        git push \
            || {
                { git pull --rebase || handle-pull-conflicts; } \
                      && git push;
            }
    } \
    || {
        git reset --soft HEAD^
        echo 'Commit failed.'
    }
#+end_src

But what if rebasing fails?  Then you are left resolving a conflict before you
can attempt the push operation again.  I do not know how you would want to
handle this.  ~handle-pull-conflicts~ might simply perform a ~git rebase --abort~
and exit with a non-zero status, or it may open a UI/shell to help resolve
changes.  If you are pushing after every change, this amounts to correcting
a single commit, so it might be worth having VC maintain the state here, allow
you to correct your commit, and then the vc-next-action would be to run ~git
rebase --continue~ after adding the files that conflicted.

This will be how the majority of Git users will resolve rejected pushes.

Does that make sense?

  [Aside: ~git pull~ without ~--rebase~ performs a ~git fetch && git merge
  whatever-branch-you-are-tracking~, which has the unfortunate side-effect of
  creating a merge commit if histories are different; this muddies up history.
  ~git pull --rebase~ performs ~git fetch && git rebase
  whatever-branch-you-are-tracking~.  The difference in the two styles of
  conflicts here is that, with rebasing, since you are re-committing each and
  every changeset, you may get multiple conflicts on any number of commits,
  whereas a merge will give you a single conflict that must be resolved at once.
  The benefit of rebasing is that it gives you a clean history and does not
  produce an unnecessary merge conflict which you would then push to origin,
  akin to leaving a bag of poop on origin's doorstep.]

For other users, it may represent a wholly different problem.  For example, if
I were to push to GNU ease.js' repo and get that message, that would be
a problem, since that means that someone has committed to my repository without
my permission.  An automatic pull and re-push would be bad in this case, since
that makes it look like I'm okay with that.

A failed push could also mean that you are tracking the wrong branch, or pushing
to the wrong repository.  Git allows you to set a "tracking branch", which can
be anything---a local branch, a remote branch, or a branch in an entirely
different repository, local or remote.  Further, you can override the tracking
branch by specifying which remote to push to as part of the ~push~ command.

In your case, you'd always want to respect the tracking branch and assume that
there are no problems pushing, since you use only one remote, and the tracking
branch is always a branch of the same name on origin.

A failed push could also mean that someone rudely rewrote history on the remote
branch (using ~git push --force~) and someone needs a talkin' to.

* References

- https://github.com/tj/git-extras
- https://hub.github.com/hub.1.html
- http://stackoverflow.com/questions/2423777/is-it-possible-to-create-a-remote-repo-on-github-from-the-cli-without-ssh

- [[https://girliemac.com/blog/2017/12/26/git-purr/][Git Commands Explained with Cats!]]
- [[https://git.wiki.kernel.org/index.php/Aliases][Git SCM Wiki - Aliases]]
- [[https://ochronus.com/git-tips-from-the-trenches/][Git tips from the trenches]]
# - [[file:~/Public/Repositories/emacs/admin/notes/git-workflow][Emacs Git workflow]]

* Git clients

- [[https://jonas.github.io/tig/][Tig]]
- [[https://www.gitkraken.com/][GitKraken]]

* Contributing

** Issues

Report issues and suggest features and improvements on the [[https://github.com/fniessen/git-leuven/issues/new][GitHub issue tracker]].

** Patches

I love contributions!  Patches under any form are always welcome!

** Donations

If you use the git-leuven project (or any of [[https://github.com/fniessen/][my other projects]]) and feel it is
making your life better and easier, you can show your appreciation and help
support future development by making today a [[https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=VCVAS6KPDQ4JC&lc=BE&item_number=git%2dleuven&currency_code=EUR&bn=PP%2dDonationsBF%3abtn_donate_LG%2egif%3aNonHosted][donation]] through PayPal.  Thank
you!

Regardless of the donations, git-leuven will always be free both as in beer and
as in speech.

** Follow me

I have an [[https://twitter.com/f_niessen][f_niessen]] account on Twitter.  You should follow it.

* License

Copyright (C) 2013-2021 Fabrice Niessen.

Author: Fabrice Niessen \\
Keywords: git aliases

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see http://www.gnu.org/licenses/.

#+html: <a href="http://opensource.org/licenses/GPL-3.0">
#+html:   <img src="http://img.shields.io/:license-gpl-blue.svg" alt=":license-gpl-blue.svg" />
#+html: </a>
#+html: <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=VCVAS6KPDQ4JC&lc=BE&item_number=git%2dleuven&currency_code=EUR&bn=PP%2dDonationsBF%3abtn_donate_LG%2egif%3aNonHosted">
#+html:   <img src="https://www.paypalobjects.com/en_US/i/btn/btn_donate_LG.gif" alt="btn_donate_LG.gif" />
#+html: </a>
