#+TITLE:     Awesome Git aliases and time-saving commands
#+AUTHOR:    Fabrice Niessen
#+EMAIL:     (concat "fniessen" at-sign "pirilampo.org")
#+DESCRIPTION: Git configs & aliases collection
#+KEYWORDS:  Git, configuration, aliases

#+LANGUAGE:  en
#+OPTIONS:   H:4 num:nil toc:nil

#+SETUPFILE: ~/org/theme-readtheorg.setup

#+EXPORT_EXCLUDE_TAGS: noexport
#+PROPERTY:  header-args :tangle .gitconfig :eval no

#+name: current-time
#+begin_src emacs-lisp :eval yes :results value silent :tangle no :exports none
(format-time-string "%Y%m%d.%H%M")
#+end_src

# - http://doc.bazaar.canonical.com/beta/en/user-reference/tags-help.html
# - https://manned.org/bzr/307858cd
# - https://documentation.help/Bazaar-help/revisionspec-help.html
# - https://www.mercurial-scm.org/wiki/GitConcepts#Command_equivalence_table

Welcome to git-config-enhancements-leuven!  This repository contains a curated
collection of configuration settings and aliases to enhance your Git workflow.
Whether you're a beginner or a seasoned Git user, you'll find time-saving
shortcuts and customization options to boost your productivity.  Browse the
contents, try them out, and feel free to contribute your own enhancements. Let's
make Git even better together!

* Table of Contents                                                   :TOC_1_gh:
- [[#foreword][Foreword]]
- [[#overview][Overview]]
- [[#global-options][Global options]]
- [[#------------------------------------------------------------------------------][------------------------------------------------------------------------------]]
- [[#aliases][Aliases]]
- [[#repository][Repository]]
- [[#instructions][Instructions]]
- [[#source-files][Source Files]]
- [[#commits][Commits]]
- [[#branches][Branches]]
- [[#tags][Tags]]
- [[#compare-revisions-commits-branches-or-tags][Compare Revisions (commits, branches or tags)]]
- [[#releases][?Releases]]
- [[#graph][?Graph]]
- [[#contributors][?Contributors]]
- [[#pull-requests][Pull requests]]
- [[#pipelines][Pipelines]]
- [[#deployments-to-different-environments][Deployments (to different environments)]]
- [[#issues][Issues]]
- [[#wiki][Wiki]]
- [[#downloads][Downloads]]
- [[#settings][Settings]]
- [[#-------------------------------------------------------------------------------1][------------------------------------------------------------------------------]]
- [[#run-on-all-repositories][Run on All repositories]]
- [[#sort-out][Sort out]]
- [[#download-repository][Download repository]]
- [[#what-if][What if]]
- [[#if-you-made-a-mistake][If you made a mistake]]
- [[#if-you-get-errors][If you get errors...]]
- [[#github-tasks][GitHub tasks]]
- [[#references][References]]
- [[#git-clients][Git clients]]
- [[#contributing][Contributing]]
- [[#license][License]]

* Foreword

- This is Git.  It tracks collaborative work on projects through a beautiful
  distributed graph theory model.

- Cool.  How do we use it?

- No idea.  Just memorize these Shell commands and type them to sync up.  If you
  get errors, save your work elsewhere, delete the project, and download a fresh
  copy.

  If that doesn't fix it, =git.txt= contains the phone number of a friend of mine
  who understands ~git~.  Just wait through a few minutes of /'It's really pretty
  simple, just think of branches as...'/ and eventually you'll learn the
  commands that will fix everything.

From [[https://xkcd.com/1597/][xkcd]].

See also [[https://girliemac.com/blog/2017/12/26/git-purr/][Git Commands Explained with Cats!]]

* Overview

The following configures interesting global settings for Git. These are stored
in the =.gitconfig= file located in the user home directory.

* Preferences

Customizing Git.

#+begin_src conf :noweb yes
# .gitconfig, Time-stamp: <<current-time()>>
#+end_src

#+begin_src conf
[checkout]
    # Preserve timestamps of checked out files.
    preserveTimestamps = true
#+end_src

** User

Setting your user name and e-mail address is important because Git stores the
committer and author of a change in every commit.

#+begin_src conf
[user]
    # Override with your name and email in the file .gitconfig_local.
    name = John Doe
    email = john.doe@example.com

[github]
    # Override with your GitHub username in the file .gitconfig_local.
    user = jdoe
#+end_src

You should "override" the above with your personal details in the file
=.gitconfig_local=.

** Auto-Prune

On *fetch* / pull, automatically remove local branches that no longer exist on the
remote:

#+begin_src conf
[fetch]
    # Remove remote-tracking references that no longer exist on the remote.
    prune = true
#+end_src

** Default Branch Name

Using ~master~ as the name for the initial branch.

#+begin_src conf
[init]
    # Set the default branch for new repositories to main.
    defaultBranch = main
#+end_src

This default branch name is subject to change. To configure the initial branch
name to use in all of your new repositories, which will suppress this warning,
call:

Names commonly chosen instead of ~master~ are ~main~, ~trunk~ and ~development~. The
just-created branch can be renamed via:

: git branch -m NAME

** External Merge Tool

How to resolve merge conflicts in Git?  Try ~git mergetool~.

#+begin_src conf
[merge]
    # Show a three-way diff in case of conflicts.
    conflictstyle = diff3
#+end_src

- For small changes, ~git diff~ and ~vc-diff~ are perfect.
- For medium changes, ~magit~ is perfect.
- For large changes, [[https://www.deltawalker.com/][DeltaWalker]] (39.95 USD) is perfect.

Firstly, here is what the parameters (used below) mean:

- ~$LOCAL~ is the file in the *current branch* (e.g. ~master~).

- ~$REMOTE~ is the file in the *branch being merged* (e.g. ~BRANCH_NAME~).

- ~$MERGED~ is the *partially merged file* with the merge conflict information in
  it.

- ~$BASE~ is the *common ancestor* of ~$LOCAL~ and ~$REMOTE~, this is to say the file as
  it was (before both changes) when the branch containing ~$REMOTE~ was originally
  created.

*** Emacs as a Git mergetool

Ediff or Emerge?  Or Magit???

#+begin_src conf :tangle no
[merge]
    tool = ediff

[mergetool "ediff"]
    cmd = emacsclient -c -a \"\"  --eval \"(ediff-merge-files-with-ancestor \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$BASE\\\" nil \\\"$MERGED\\\")\"
    keepBackup = false
#+end_src

*** Meld as Git mergetool

*How do I set up and use Meld as my git mergetool?*
See https://stackoverflow.com/questions/34119866/setting-up-and-using-meld-as-your-git-difftool-and-mergetool.

See ~auto-merge~ in
https://stackoverflow.com/questions/11133290/git-merging-using-meld (first and
second solution).

Use [[https://meldmerge.org/][Meld]] as Git ~mergetool:~

#+begin_src conf
[merge]
    # Use meld as the merge tool.
    tool = meld
#+end_src

I suggest you use either:

#+begin_src conf :tangle no
[mergetool "meld"]
    cmd = meld "$LOCAL" "$MERGED" "$REMOTE" --output "$MERGED"
#+end_src

or:

#+begin_src conf :tangle no
[mergetool "meld"]
    cmd = meld "$LOCAL" "$BASE" "$REMOTE" --output "$MERGED"
#+end_src

The choice is whether to use ~$MERGED~ or ~$BASE~ in between ~$LOCAL~ and ~$REMOTE~.

Either way, Meld will display 3 panes with:

- ~$LOCAL~ in the left pane,
- ~$REMOTE~ in the right pane and
- either ~$MERGED~ or ~$BASE~ in the middle pane.

In BOTH cases, *the middle pane is the file that you should edit to resolve the
merge conflicts*.  The difference is just in which starting edit position you'd
prefer:

- ~$MERGED~ for the file which contains the partially merged file with the merge
  conflict information or

- ~$BASE~ for the shared commit ancestor of ~$LOCAL~ and ~$REMOTE~.

#+begin_note
Since both cmd lines can be useful, I keep them both in my =.gitconfig= file. Most
of the time I use the ~$MERGED~ line and the ~$BASE~ line is commented out, but the
commenting out can be swapped over if I want to use the ~$BASE~ line instead.
#+end_note

#+begin_src conf
[mergetool "meld"]
    # Run meld with the required arguments.
    cmd = meld --diff "$LOCAL" "$MERGED" "$REMOTE" --diff "$BASE" "$LOCAL" --diff "$BASE" "$REMOTE" --output "$MERGED"
    # cmd = meld --diff "$LOCAL" "$BASE" "$REMOTE" --diff "$BASE" "$LOCAL" --diff "$BASE" "$REMOTE" --output "$MERGED"
    # Don't keep backup files.
    keepBackup = false
#+end_src

** External Diff Tool

Use [[https://meldmerge.org/][Meld]] as Git ~difftool:~

#+begin_src conf
[diff]
    tool = meld

[difftool]
    # Set prompt to false to avoid asking for confirmation before launching the diff tool.
    prompt = false

[difftool "meld"]
    # Set the command to launch "meld" with the two input files as arguments.
    cmd = meld "$LOCAL" "$REMOTE"
#+end_src

** External Editor

You may edit your commit messages in your preferred external *text editor*.

Supported editors include:
- Atom
- *Emacs*
- IntelliJ
- Notepad++
- Sublime
- VS Code

#+begin_src conf
[core]
    # Set Emacsclient as the default editor.
    editor = emacsclient
    # editor = notepad++.exe -multiInst -notabbar -nosession -noPlugin
#+end_src

** Delete ".orig" files

Clean the byproducts of the merge conflict process:

: find . -name "*.orig" -delete

** Pager Support

Some Git commands can produce a lot of output, and Git will attempt to use
a pager to make those commands more pleasant.

To set the pager that should be used, set the application variable ~pager~.

*** Less

#+begin_note
When the ~LESS~ environment variable is unset, Git sets it to ~-FRSX~.  If the ~LESS~
environment variable is set, Git does not change it at all.

We use ~-R~ in the command itself to be sure to *interpret the color codes* when Git
is run from /Windows/ Emacs (~C-x v l~), with /no/ value for the ~LESS~ /environment
variable/.
#+end_note

#+begin_src conf
    # Set Git pager to ignore ^M and use less with custom flags.
    # (git-grep to ignore ^M)
    pager = tr -d '\\r' | less -REX
#+end_src

Stop viewing non-printable characters (for example, ISO Latin 1 accents in
a UTF-8 terminal) in reverse video and hexadecimals: see ~LESSBINFMT~.

Stop viewing ~^M~ symbols in diff:

#+begin_src conf
    # Set whitespace configuration to only warn about carriage return at the end of the line.
    whitespace = cr-at-eol
    # whitespace = fix,-indent-with-non-tab,trailing-space,space-before-tab,cr-at-eol
#+end_src

*** Diff-so-fancy extension

Improve the ~git diff~ output using a tool like:
- [[https://github.com/so-fancy/diff-so-fancy][diff-so-fancy]] or
- [[https://github.com/dandavison/delta][delta]].

#+begin_src conf
    # Set Git pager to use less with custom flags and diff-so-fancy.
    pager = diff-so-fancy | LESS= less --tabs=4 -FRX
#+end_src

~less~ options:
- ~-F~ to exit immediately if the output is less than one screen,
- ~-R~ for colors to persist, and
- ~-X~ for not clearing the screen.

#+begin_tip
The diff-so-fancy ruler was 1 char too long.  It turned out I had an option in
~$LESS~ that enabled the status column, and thus added a space at the beginning
of every line.  I was able to resolve it by clearing the ~LESS~ environment
variable in the ~core.pager~ config.

Also, the diff-so-fancy ruler was not displayed in Unicode.  It turned out I had
set ~LC_CTYPE~ to "".  I had to either unset ~LC_CTYPE~ entirely or set it to
something with UTF-8 in it.

See https://github.com/so-fancy/diff-so-fancy/issues/364.
#+end_tip

** AutoCRLF

[[https://help.github.com/en/github/using-git/configuring-git-to-handle-line-endings][GitHub suggests]] that you should make sure to only use LF (~\n~) as a newline
character in Git-handled repositories.

- *Checkout Windows-style, commit Unix-style line endings*

  Git will convert LF to CRLF when checking out text files onto your file
  system.  When committing text files, CRLF will be converted to LF.  *For
  cross-platform projects*, this is the *recommended setting on Windows*
  (~core.autocrlf~ is set to ~true~) because it ensures that your repository can be
  used on other platforms while retaining CRLF in your working tree.

  #+begin_src conf :tangle no
      # Configure Git to ensure line endings in files you checkout are correct
      # for Windows.  For compatibility, line endings are converted to Unix
      # style when you commit files.
      autocrlf = true
  #+end_src

  This /turns all LF back into CRLF when writing out into the working tree/.

- *Checkout as-is, commit Unix-style line endings*

  Git will /not perform any conversion when checking out text files/.  When
  committing text files, CRLF will be converted to LF.  *For cross-platform
  projects*, this is the *recommended setting on Unix* (~core.autocrlf~ is set to
  ~input~) to prevent CRLF from getting written into the repository.

  #+begin_src conf :tangle no
      # Configure Git to ensure line endings in files you checkout are correct
      # for Linux and macOS.
      autocrlf = input
  #+end_src

  When you read files back out of the object database and write them into the
  working tree, they will still have LF to denote the end of line.

- *Checkout as-is, commit as-is*

  Git will not perform any conversions when checking out or committing text
  files.  Choosing this option is *not recommended for cross-platform projects*
  (~core.autocrlf~ is set to ~false~).

  #+begin_src conf :tangle no
      autocrlf = false
  #+end_src

  This is the default, but most people are encouraged to change this
  immediately.

  The result of using ~false~ is that Git doesn't ever mess with line endings on
  your file. You can check in files with LF or CRLF or CR or some random mix of
  those three and Git does not care. This can make diffs harder to read and
  merges more difficult.

** Proxy configuration

#+begin_src conf :tangle no
[http]
    proxy = http://proxy-guest.example.com:8080
#+end_src

#+begin_src conf :tangle no
[alias]
    # Proxy.
    set-proxy = !git config --global http.proxy http://proxy-guest.example.com:8080 \
                && git config --global https.proxy https://proxy-guest.example.com:8080
    rmv-proxy = !git config --global --unset http.proxy \
                && git config --global --unset https.proxy
#+end_src

* Global options

** Core

#+begin_src conf
[core]
#+end_src

Performance:

#+begin_src conf
    # Enable parallel filesystem operations.
    preloadindex = true
#+end_src

*Enable file system caching.*  File system data will be read in bulk and cached in
memory for certain operations.  This provides a significant performance boost.

#+begin_src conf
    # Enable file system caching to avoid UAC issues.
    fscache = true
#+end_src

Clean up reflog?

#+begin_src conf
[gc]
    # Optimize for repositories with many files.
    auto = 256
#+end_src

** Help

#+begin_src conf
[help]
    # Enable autocorrect for mistyped commands.
    autocorrect = 1
#+end_src

** Log

Get a better date format; for example:

: 2021-12-03

instead of:

: Fri Dec 3 14:26:38 2021 +0100

#+begin_src conf
[log]
    # Use short date format for log messages.
    date = short
#+end_src

Print out the ref names (tags or branches) of any commits that are shown.

#+begin_src conf
    # Use short format for ref names (e.g. branch or tag names).
    decorate = short
#+end_src

** Diff

#+begin_src conf
[diff]
    # Treat file renames as copies.
    renames = copies

    # Set the limit of similarity for considering a file rename.
    renameLimit = 30000
#+end_src

Using the patience diff algorithm to compare large swathes of repetitive text
(hello, xml!) often produces a much more readable diff that will reveal context
and therefore hopefully bugs/typos etc.

Here's a quick snippet of a diff to show it helping. Bare LCS-based diff:

#+begin_src diff :tangle no
 def thing1 {
     something += 1
+}
+
+def somethingelse {
+    something += 1
 }

 def thing2 {
     something += 2
 }
#+end_src

With ~patience~ becomes:

#+begin_src diff :tangle no
 def thing1 {
     something += 1
 }

+def somethingelse {
+    something += 1
+}
+
 def thing2 {
     something += 2
 }
#+end_src

Same end result but much easier to read.

#+begin_src conf
    # Use the patience diff algorithm for generating patches.
    algorithm = patience
#+end_src

Git diff will use ~(i)ndex~, ~(w)ork tree~, ~(c)ommit~ and ~(o)bject~ instead of ~a~ / ~b~
/ ~c~ / ~d~ as prefixes for patches:

#+begin_src conf
[diff "zebra"]
    # Use dimmed zebra coloring to highlight moved lines in a diff.
    colorMoved = dimmed_zebra

[diff "header"]
    # Include mnemonic prefixes in diff hunk headers.
    mnemonicprefix = true

    # Don't show any prefix in diff hunk headers.
    noprefix = true
#+end_src

** Apply

#+begin_src conf
[apply]
    # Don't detect whitespace errors when applying a patch.
    whitespace = nowarn
#+end_src

** Status

If you are using submodules, it might be useful to turn on the submodule summary.

#+begin_src conf
[status]
    submoduleSummary = true
#+end_src

** Pull

Git pull allows you to integrate with and fetch from another repository or local
Git branch.

Choose the default behavior of ~git pull~:

- *Fast-forward if possible (or merge)*

  This is the *default* behavior of ~git pull~: fast-forward the current branch to
  the fetched branch when possible, otherwise create a merge commit.

  #+begin_src conf :tangle no
  [pull]
      rebase = merges
  #+end_src

- *Fast-forward only*

  Fast-forward to the fetched branch.  Fail if that is not possible.

- *Rebase*

  Rebase the current branch onto the fetched branch.

  #+begin_src conf :tangle no
  [pull]
      rebase = true
  #+end_src

  If there are no local commits to rebase, this is equivalent to a fast-forward.

rebase with auto-abort
: git rebase foo || git rebase --abort

See https://www.gitkraken.com/learn/git/problems/git-pull-rebase!!!

At this point, let us remind you of [[https://git-scm.com/book/en/v2/Git-Branching-Rebasing#The-Perils-of-Rebasing][the perils of rebasing]].

** Push

Push *only* the *current working branch* (sane pushing -- instead of pushing all
branches), with an added safety: only if it is /tracking/ a remote upstream branch
with the /same name/.

#+begin_src conf
[push]
    default = simple
#+end_src

(~simple~ is the default in Git 2.x)

** Merge

#+begin_src conf
[merge]
    stat = true
    summary = true

    # Include summaries of merged commits in newly created merge commit messages.
    log = true
#+end_src

** Rebase

Set ~rebase.stat = true~, so the ~diffstat~ output is still shown when they pull.

#+begin_src conf
[rebase]
    stat = true
#+end_src

** Grep

https://git-scm.com/docs/git-grep

#+begin_src conf
[grep]
    lineNumber = true

    # # Allow extended regular expressions
    # extendedRegexp = true

    fullName = true
#+end_src

** Color

Enable colors in terminal:

#+begin_src conf
[color]
    ui = auto
    branch = auto
    diff = auto
    status = auto
    interactive = auto
#+end_src

*** Branch

#+begin_src conf
[color "branch"]
    current = cyan bold
    local = green bold
    remote = red bold
    upstream = red bold
    plain = yellow reverse
#+end_src

*** Diff

See http://git-scm.com/docs/git-config for the ~slot~ list.

#+begin_src conf
[color "diff"]
    plain = "#888888"
    meta = 11
    frag = magenta bold
    func = "#cc99cc"
    old = red bold
    new = green bold
    commit = yellow bold
    whitespace = red reverse
#+end_src

Diff-so-fancy extension:

#+begin_src conf
[diff-so-fancy]
    useUnicodeRuler = true

[color "diff-highlight"]
    oldNormal = red bold
    oldHighlight = red bold 52
    newNormal = green bold
    newHighlight = green bold 22
#+end_src

*** Status

#+begin_src conf
[color "status"]
    header = normal
    added = green bold
    changed = yellow bold
    untracked = cyan
    branch = cyan bold
    nobranch = bold ul blink 12
    unmerged = red reverse bold
#+end_src

- added = modified
- changed = updated

*** Grep

The first color given is the foreground; the second is the background.", e.g
~match 10 22~ -- see ~man 1 git-config~ at "CONFIGURATION FILE" > "Values" >
"color".

#+begin_src conf
[color "grep"]
    context = "#888888"
    filename = yellow bold
    function = red
    linenumber = magenta bold
    match = green reverse bold
    matchContext = yellow reverse bold
    matchSelected = yellow bold blue
    separator = red bold
    selected = white
#+end_src

** Format

#+begin_src conf
[format]
    pretty = format:%C(green)%ad%C(reset) %C(yellow)%h%C(auto)%d%C(reset) %s %C(bold blue)<%an>%C(reset)

# https://dev.to/megamattmiller/the-git-aliases-that-get-me-to-friday-1cmj
[custom.formats]
    ls = "[%C(auto,yellow)%<|(10)%h%C(reset)] [%C(auto,bold blue)%<(15trunc)%cn%C(reset)]  %C(auto)%d% C(reset)%s"
    find = "[%C(yellow)%<|(20)%h%C(reset)] [%C(bold blue)%<(10)%cn%C(reset)]  %C(auto)%d %C(reset)  %s"
    graph = "%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset) %C(yellow)%d%C(reset)%n %C(white)%s%C(reset)%n %C(dim white)- %an <%ae> %C(reset) %C(dim white)(committer: %cn <%ce>)%C(reset)"
#+end_src

See
- https://devhints.io/git-log-format and
- https://git-scm.com/docs/pretty-formats (XXX)

* Aliases

Aliases are an easy way to create shortcuts for commonly-typed commands, or to
set defaults for commands.

#+begin_src conf
[alias]
#+end_src

If you forget your aliases and don't want to open =.gitconfig= just to check, type
~git aliases~.

#+begin_src conf
    # Usage: git aliases
    # List all Git aliases in alphabetical order.
    aliases = "!git config -l \
                  | grep alias \
                  | cut -c 7- \
                  | sort \
                  | sed 's/=/ = /'"
#+end_src

* Repository

For *free private repositories*, see https://bitbucket.org/.

** Initialize a new repository

Set email addresses for you:

#+begin_src conf
    work-profile = config user.email \"john@work.com\"
#+end_src

Then, in the working copy:

#+begin_src conf
    # Usage: git init-repository
    # Initialize a new Git repository with an initial commit.
    init-repository = !git init \
                && (ls -1A | grep -q . || touch .gitignore) \
                && git add . \
                && git commit -m \"Initial commit\"
#+end_src

The command is checking whether the output of ~ls~ command is not empty, and if it
is, it will create a =.gitignore= file.

#+begin_tip
Since Git doesn't add *empty directories*, if you want to keep them in the
repository, a sort of conventional hack is to create a file called =.gitkeep= in
these directories.  (The file could be called anything; Git assigns no special
significance to this name.)
#+end_tip

** Drop the revision history for a project

If you accidentally put the wrong tree under version control, simply delete the
=.git= directory.

: find . -name '.git' -exec rm -rf {} \;

** Clone an existing repository

Clone an existing repository including all submodules.

#+begin_src conf
    cl = clone --recursive
#+end_src

For *passwordless Git pull* (permanently authenticating with Git repositories),
1. *use SSH* when cloning, and
2. *add* your *public key* to the remote server.

*** I'm having an SSH issue

The error (when cloning, pulling or pushing)

: SSL certificate problem: Unable to get local issuer certificate

occurs when a *self-signed certificate cannot be verified*.

- For a one-time fix, you can use the ~env~ command to create an environment
  variable of ~GIT_SSL_NO_VERIFY=TRUE~:

  : env GIT_SSL_NO_VERIFY=TRUE git COMMAND ARGUMENTS

- If you don't want to do this all the time, you can disable Git SSL
  verification:

  #+begin_src conf :tangle no
  [http]
      sslVerify = false
  #+end_src

#+begin_warning
Please be advised disabling SSL verification globally *might be considered
a security risk* and should be implemented only temporary.
#+end_warning

*** Clone to only the latest commit in the repository's history

The ~--depth 1~ option is useful when you only need the latest version of
a repository and don't need the entire history.

This can be the case when:
- you're cloning a large repository and only need the latest code to work with,
  or
- you're cloning a repository for temporary purposes, such as testing.

It makes the clone operation faster and lighter.

** Create and add your SSH public key to a repository hosting service

https://docs.gitlab.com/ee/gitlab-basics/create-your-ssh-keys.html

It is best practice to use Git over SSH (instead of Git over HTTP).  In order to
use SSH, you will need to:

*** Create an SSH key pair on your local computer

Generate a new ED25519 (should always be favored) SSH key pair:

: ssh-keygen -t ed25519 -C "email@example.com"

Or, if you want to use RSA:

: ssh-keygen -t rsa -b 4096 -C "email@example.com"

*** Add the key to the repository hosting service

*** Testing that everything is set up correctly

** Remote repo integrations

Fetch URL: git@bitbucket.org-something:user/slug

#+begin_src conf
    # origin = !echo "${$(git config --get clone.defaultRemoteName):-origin}"
    origin = !echo "origin"
#+end_src

#+begin_src conf
    # Usage: git repo-owner
    # Get the owner of the remote Git repository.
    repo-owner = "!f() { \
        git remote show $(git config --get remote.origin.url) -n \
            | grep 'Fetch URL:' \
            | sed -E 's#^.*[/:](.*)/.*$#\\1#' \
            | sed 's#\\.git$##'; \
    }; f"
#+end_src

#+begin_src conf
    # Usage: git repo-slug
    # Get the name of the remote repository.
    repo-slug = "!f() { \
        git remote show $(git config --get remote.origin.url) -n \
            | awk -F/ '/Fetch URL:/{print $NF}' \
            | sed 's#\\.git$##'; \
    }; f"
#+end_src

Updating Git aliases for different *default branch* names (~master~, ~main~, etc.):

#+begin_src conf
    # Usage: git default-branch
    # Get the name of the default branch (main or master).
    default-branch = "!f() { \
        if git show-ref --verify --quiet refs/heads/main; then \
            echo \"main\"; \
        else \
            echo \"master\"; \
        fi \
    }; f"
    #+end_src

The more straightforward variant:

    #+begin_src conf :tangle no
    default-branch = "!git symbolic-ref refs/remotes/origin/HEAD \
        | sed 's@^refs/remotes/origin/@@'"
#+end_src

occasionally produces the following output:

: fatal: ref refs/remotes/origin/HEAD is not a symbolic ref

*** Create a new repository in GitHub

By default, the GitHub API creates a repository as *public*.

#+begin_src conf :tangle no
    # Usage: git create-repository-gh OWNER REPO_NAME
    create-repository-gh = "!f() { \
        REPO_OWNER=\"$1\"; \
        REPO_SLUG=\"$2\"; \
        curl -u \"$REPO_OWNER\" https://api.github.com/user/repos -d \"{\\\"name\\\":\\\"$REPO_SLUG\\\"}\"; \
    }; f"
#+end_src

* Instructions

Start working with your repository.

** Create a README

Create a =README.md= file into your repository.

: echo "# ${$(git repo-slug):-Repository name}\n\nDescription" >> README.md
: git add README.md
: git commit -m "Add README.md"
:
: git push -u $(git origin) master

** Create a .gitignore

You can also create a =.gitignore= file into your repository.

* Source Files

** Search for files

Search files (by file path) in the current branch.

#+begin_src conf
    # Usage: git search-for-files PATTERN
    # List all files in the current branch matching a case-insensitive search pattern.
    search-for-files = !git ls-tree -r --name-only HEAD | grep -i --color=auto

    # Alias of 'search-for-files'.
    find-files = !git search-for-files
#+end_src

Search files in all branches.

#+begin_src conf
    # Usage: git search-for-files-all PATTERN
    # Search for a file in all branches.
    search-for-files-all = "!f() { \
        for BRANCH_NAME in $(git for-each-ref refs/heads --format='%(refname)'); do \
            printf \"\n$(tput bold)$BRANCH_NAME:$(tput sgr0)\n\"; \
            git ls-tree -r --name-only $BRANCH_NAME | nl -bn -w3 | grep --color=auto \"$1\"; \
        done; \
    }; f"

    # Alias of 'search-for-files-all'.
    find-files-all = !git search-for-files-all
#+end_src

** Search for code

*Code search* looks through all lines of code of all the files (by the *file
contents*) from the current directory (and its subdirectories).

https://confluence.atlassian.com/bitbucketserver/search-for-code-in-bitbucket-server-814204781.html
https://help.github.com/en/github/searching-for-information-on-github/searching-code

*** Search code for exact matches

Find all instances of the specified string in code in the repository (or *in the
specified path*).

#+begin_src conf
    # Usage: git search-for-code PATTERN [TREE]
    # Search for a string in files, ignoring binary files and highlighting matches.
    search-for-code = "grep -i -I --line-number --break --heading -C 1"

    # Alias of 'search-for-code'.
    ack = !git search-for-code
#+end_src

Find all instances of the specified string in code files *with a certain file
extension*.

#+begin_src conf
    search-for-code-in-extension = "XXX"
#+end_src

*** Find files that contain multiple terms, not necessarily on the same line

Match any of these patterns, but print matches only from files that have /all/ of
them (files must have lines that match each of them):

: git grep -i -I --line-number --break --heading -C 1 -e REGEXP -e REGEXP --all-match

: git grep -i -I --line-number --break --heading -C 1 -e Compares -e solv --all-match
does not work in BitBucket!!!???

See also https://askubuntu.com/questions/1019678/find-multiple-word-patterns-in-files

*** Pattern in current directory (and its subdirectories)

The advantages of ~git grep~ are not only its *speed*, and the fact it only searches
your project files (i.e. no files in =.git=), but also that is allows you to
interface with your repository's Git database; for example, for searching:

- files registered in the index, rather than the working tree,
- for your regexp in some files from another branch (XXX does not work? XXX).

#+begin_note
It doesn't search files that are not revisioned (untracked, excluded/ignored,
etc.).
#+end_note

Example:

: git grep "foo" -- '*.java'

More readable output, *with grouping* (like Ripgrep, ~rg~, or ~ack~):

#+begin_src conf
    # Usage: git git-search <search-term>
    # Search for a string in all Git-tracked files.
    grep-all = "!f() { \
        git rev-list --all \
          | xargs git grep $1; \
    }; f"
    # IN ALL COMMITS, NOT IN ALL BRANCHES???!!! LOTS OF DUPLICATES!!!
#+end_src

Print the name of each *file with matches*:

#+begin_src conf
    # Usage: git gno PATTERN [TREE]
    # Search for a pattern in all tracked filenames, ignoring case and binary
    # files.
    gno = "grep -i -I --name-only"
#+end_src

** Undo local changes

See https://docs.gitlab.com/ee/topics/git/numerous_undo_possibilities_in_git/
and http://gitimmersion.com/lab_14.html.

*** Before you staged (in unstaged state)

*Undo* the local changes *in the working tree*: roll a file back to its last
committed version, removing all the changes detected by Git.

#+begin_tip
It can also recover *deleted files* -- if the deletion has not been committed.
#+end_tip

If you decide that the changes you have made since the last commit ought to be
thrown away, the alias to use is ~unmodify~;

#+begin_src conf
    # Usage: git unmodify TREE_ISH...
    # Undo changes made to the working directory of the current branch by
    # overwriting them with the last committed version.
    unmodify = checkout --
    undelete = checkout --
    undo-changes = checkout --
#+end_src

#+begin_note
The two dashes there (~--~, canonically called the "bare double dashes" or the /end
of options/ character) ensure that the checkout command know that we are trying
to roll back a file and not /change branches/ (the typical usage of the checkout
command).
#+end_note

When you grab a file from a previous time, it sits *in your index*, modified.

*** Before you committed (in staged state)

If you accidentally include a file in the next commit (using ~git add~), you can
use the ~unstage~ alias to tell Git to forget about it (remove it from the staging
area).

: git add foo.html
: (oops - didn't mean that)
: git unstage foo.html
: (foo.html left on disk, but excluded from the next commit)

#+begin_src conf
    # Usage: git unstage [FILENAME...]
    # Unstage the changes to a file that were previously added to the Git
    # staging area.
    unstage = reset HEAD --
#+end_src

~unstage~ is the opposite of ~git add~.

** Selecting files

#+begin_src conf
    # Usage: git staged-files
    # List files that are staged (added, modified, or deleted) and ready to be committed.
    staged-files = diff --cached --name-only
#+end_src

#+begin_src conf
    # Usage: git added-files
    # List files that have been added but not yet committed.
    added-files = diff --cached --name-only --diff-filter=A
#+end_src

#+begin_src conf
    # Usage: git modified-files
    # List files that have been modified in the working tree.
    modified-files = diff --name-only --diff-filter=M
    #+end_src

#+begin_src conf
    # Usage: git deleted-files
    # List files that have been deleted in the working directory.
    deleted-files = ls-files -d
#+end_src

How to restore a deleted file in a Git repository?

: git deleted-files | xargs git checkout --

List untracked files.

#+begin_src conf
    # Usage: git untracked-files
    # List files thare are not tracked by Git.
    untracked-files = ls-files --others --exclude-standard
#+end_src

List untracked *files ignored* by a =.gitignore= statement somewhere.  This one is
a MUST have:

#+begin_src conf
    # Usage: git ignored-files
    # List files that are ignored according to your '.gitignore' rules.
    ignored-files = ls-files --others --ignored --exclude-standard
#+end_src

#+begin_src conf
    # Usage: git tracked-files
    # List all tracked files in the repository, sorted by last modification time.
    tracked-files = ls-files -t
    #+end_src

*** Tell if a file is being tracked

#+begin_src conf
    # Usage: git check-file-status FILENAME
    # Check the status of a file (tracked, not tracked, or does not exist).
    check-file-status = "!f() { \
        if [ -e \"$1\" ]; then \
            if git ls-files --error-unmatch \"$1\" >/dev/null 2>&1; then \
                printf \"$1: tracked\\n\"; \
            else \
                printf \"$1: not tracked\\n\"; \
            fi; \
        else \
            printf \"$1: does not exist\\n\"; \
        fi; \
    }; f"
#+end_src

#+begin_note
~[[~ has fewer surprises and is generally safer to use. But it is not portable --
it's a *Bashism*, POSIX doesn't specify what it does.

For example, you can do

: [[ -e $b ]]

to test whether a file exists.

But with ~[~, you have to quote ~$b~, because it splits the argument and expands
things like ~"a*"~ (where ~[[~ takes it literally).

: [ -e "$b" ]

That has also to do with how ~[~ can be an external program and receives its
argument just normally like every other program (although it can also be
a builtin, but then it still has not this special handling).
#+end_note

** Ignoring files

*** Add ignore entry to the repository

- Ignore exact filename: filename
- Ignore everything beneath: folder
- Ignore all files with this extension: pattern
- Ignore custom pattern: pattern

Add any directories, files, or patterns you don't want to be tracked by version
control.

Quickly add a file or directory to =.gitignore=:

#+begin_src conf
    # Add file or pattern to .gitignore.
    ignore = "!f() { \
        if [ ! -e .gitignore ]; then \
            touch .gitignore; \
        fi; \
        echo \"$1\" >> .gitignore; \
    }; f"

    # Ignore all untracked files by adding them to .gitignore.
    ignore-untracked = "!git status \
                | grep -P \"^\\t\" \
                | grep -vF .gitignore \
                | sed \"s/^\\t//\" \
                >> \"${GIT_PREFIX}.gitignore\""
#+end_src

*Note that adding the .gitignore and the file specification will have no effect
on files that are already being tracked.* If you're already tracking these,
you'll have to stop tracking them.

*** ~assume-unchanged~ command

Ignore/unignore changes to *tracked file(s)* only locally, without =.gitignore=:

#+begin_src conf
    # Mark a file as unchanged and hide it from the Git status.
    skip = update-index --assume-unchanged

    # Revert the hidden status of a file, allowing it to be tracked again by Git.
    unskip = update-index --no-assume-unchanged
#+end_src

XXX Have a look at Git lock = skip-worktree

It has to be configured for each project member individually.

#+begin_warning
As stated in [[http://stackoverflow.com/questions/23097368/git-ignore-vs-exclude-vs-assume-unchanged][git ignore vs. exclude vs. assume-unchanged]],
~git-update-index --assume-unchanged~ was never meant to ignore changes to tracked
files (*only to spare some stats*).  So do not suggest it as a means to achieve
that.
#+end_warning

Skip all:

#+begin_src conf
    # Mark all changed files as unchanged and hides them from the Git status.
    skip-all = "!git status -s \
                | awk {'print $2'} \
                | xargs git skip"
#+end_src

Unskip all the skipped files:

#+begin_src conf
    # Revert the hidden status of all files, allowing them to be tracked again by Git.
    unskip-all = "!git skipped \
                | xargs git update-index --no-assume-unchanged"
#+end_src

List ignored files (*marked unchanged*):

#+begin_src conf
    # List files marked as "assume unchanged" in the Git repository.
    skipped = "!git ls-files -v \
                | grep '^h' \
                | cut -c 3-"
#+end_src

** Clean

*** Delete all untracked files

To delete all files (and directories) unknown to Git, you can run ~git
clean-untracked~.

Only unknown files, not ignored files, are deleted.

It won't remove staged changes, like modified files still uncommitted.

#+begin_src conf
    # Usage: git clean-untracked
    # Remove all untracked files and directories (that are not ignored by Git).
    clean-untracked = clean -f -d -X
    # THIS COMMAND MAY DELETE FILES THAT CANNOT BE RECOVERED.
#+end_src

It will preserve files and directories that are listed in =.gitignore=.

*WARNING -- BE CAREFUL WITH THIS!*

To check what ~git clean-untracked~ will delete, and be sure it's what you
want, use ~git clean-untracked-dry~.

#+begin_src conf
    # Usage: git clean-untracked-dry
    # Show what files and directories would be removed by the clean-untracked
    # alias without actually removing them.
    clean-untracked-dry = clean -n -d -X
#+end_src

If you want to save your current branch's state before doing this (just in
case), you can do:

: git commit -a -m "Saving my work, just in case"
: git branch my-saved-work

*** Delete all untracked files and also ignored files

*PLAY WITH FIRE VERSION* which will wipe out all the *ignored and untracked* files
and directories:

#+begin_src conf
    # Usage: git clean-all
    # Delete all untracked files and directories, including those that are
    # ignored by Git.
    clean-all = clean -f -d -x
    # THIS COMMAND MAY DELETE FILES THAT CANNOT BE RECOVERED.
#+end_src

#+begin_note
~git clean~ will *remove any files* from the tracked root directory *that are not
under Git tracking* (whereas ~git reset --hard~ will /not remove untracked files/).
#+end_note

To check what ~git clean-all~ will delete, and be sure it's what you want, use ~git
clean-all-dry~.

#+begin_src conf
    # Usage: git clean-all-dry
    # Show what files and directories would be removed by the clean-all alias
    # without actually removing them.
    clean-all-dry = clean -n -d -x
#+end_src

*** Delete only ignored files

Remove (only) ignored files that are still on the repository:

: git ignored | xargs rm

*** Hg shelve untracked files

*** Hg ignore untracked files

*** Hg remove untracked files

*** Forget all missing files

forget = select files that have been deleted
https://stackoverflow.com/questions/2412239/how-to-do-mercurials-hg-remove-for-all-missing-files

remove files which have been deleted
https://www.commandlinefu.com/commands/view/3502/git-remove-files-which-have-been-deleted

stage manually deleted files
: git status | grep deleted | sed 's/deleted://g' | sed 's/[#| ]//g' | xargs git rm

** Stash (shelve)

Temporarily set aside some changes from the current tree.

Shelve allows you to temporarily put changes you've made "on the shelf", ie. out
of the way, until a later time when you can bring them back from the shelf with
the `unshelve' command. The changes are stored alongside your working tree, and
so they aren't propagated along with your branch nor will they survive its
deletion.

If shelve -list is specified, previously-shelved changes are listed.

Shelve is intended to help separate several sets of changes that have been
inappropriately mingled. If you just want to get rid of all changes and you
don't need to restore them later, use revert. If you want to shelve all text
changes at once, use shelve -all.

If filenames are specified, only the changes to those files will be
shelved. Other files will be left untouched.

If a revision is specified, changes since that revision will be shelved.

You can put multiple items on the shelf, and by default, `unshelve' will restore
the most recently shelved changes.


bzr unshelve [SHELF_ID]
Restore shelved changes.

--apply
Apply changes and remove from the shelf.

--delete-only
Delete changes without applying them.

--dry-run
Show changes, but do not apply or remove them.

--keep
Apply changes but don't delete them.

--preview
Instead of unshelving the changes, show the diff that would result from unshelving.


https://fossil-scm.org/home/help?cmd=stash




A *stash* is nothing but a *(temporary) branch*.

~git stash~ makes a temporary copy of the changes in your *index* (staging area) and
*working tree*, and clears the decks so you can easily work on something else; it
reverts your local modifications, allowing you to get rid of some incomplete
changes.

#+begin_tip
Use ~git stash~ if Git refused to merge because it foresees conflicts.
#+end_tip

If you anticipate that you might have trouble merging the work you want to stash
with the work you're about to do on the clean tree, you can create a new branch
with ~git stash branch NEW_BRANCH_NAME~.

Information that is used by default if you don't provide a message:

#+begin_example
stash@{0}: WIP on BRANCH: SHA_1_OF_HEAD TITLE_LINE_OF_HEAD
#+end_example

You can operate on the "stash" ref as if it were any other ref.

*** Stash push

~git stash push~ also optionally takes a message describing the contents of the
stash (much, much more useful):

: git stash push -m "Describe what you did here"

: stash@{0}: On BRANCH: Describe what you did here

This command is useful in saving all changes not ready to be committed and the
user wants to have an updated repository.

#+begin_src conf
    # Usage: git stash-push
    # Stash changes in the working directory for later retrieval.
    stash-push = stash push
#+end_src

#+begin_src conf
    # Usage: git stash-all
    # Stage all changes and untracked files, then creates a stash.
    stash-all = !git add -A \
                && git stash
#+end_src

#+begin_src conf
    # Usage: git stash-untracked
    # Stash changes, including untracked files, for later retrieval.
    stash-untracked = stash push --include-untracked
#+end_src

*** Take named stash

"WIP:"

#+begin_src conf
    # Usage: git snapshot
    # Create a snapshot stash with a timestamp and immediately apply it.
    snapshot = !git stash push -m "snapshot-$(date +%Y%m%d_%H%M)" \
                && git stash apply "stash@{0}"
#+end_src

#+begin_src conf
    # Usage: git checkpoint
    # Create a new temporary stash with a timestamp and restore staged changes.
    checkpoint = !git stash push -m "$(date +%F--%T)" \
                && git stash pop --index

    # Usage: git checkpoint-recover [TIME_INTERVAL]
    # Display a formatted log of recent version changes with timestamps and commit messages.
    # Example: git checkpoint-recover 1week
    checkpoint-recover = "!f() { \
        git fsck \
            | grep commit \
            | cut -d' ' -f3 \
            | while read HASH; do \
                  git rev-parse --verify --no-revs --quiet $HASH^2 2>/dev/null \
                      && echo $HASH \
                      | xargs git rev-list --since=${1:-1day} -1; \
              done \
            | xargs -L 1 git log -1 --format=%at:%h \
            | sort \
            | cut -f2 -d: \
            | xargs -L 1 git log -3 --format='%Cblue%h %Cgreen(%ar) %Creset%s' --graph; \
    }; f"
#+end_src

*** Show a list of all stashes

#+begin_src conf
    # Usage: git stashes
    # List stashes with their short creation dates.
    stashes = stash list --date=short
#+end_src

: {0}: On feature/2023-08-04-request-notification: autostash

*** Show the stash

#+begin_src conf
    # Usage: git stash-view
    # Show the changes introduced by the latest stash in a unified diff format.
    stash-view = stash show -p
    # Instead of unshelving the changes, show the diff that would result from
    # unshelving.
#+end_src

https://stackoverflow.com/questions/11269256/how-to-name-and-retrieve-a-stash-by-name-in-git:

#+begin_src conf
    # Show only stash with name like text.
    stash-show = "!f() { \
        git stash show stash^{/$@} -p; \
    }; f"

    stash-show = "!f() { \
        git stash show stash^{/$*} -p; \
    }; f"
#+end_src

One very useful feature one may consider is to list contents of all local
stashes:

: git stashes | awk -F: '{ print "\n\n\n\n"; \
:                          print $0; \
:                          print "\n\n"; \
:                          system("git stash show -p " $1); }'

Press [Q] to exit each stash.

It helped me a lot in the past (cleaning stashes stack).

*** Show name-only

#+begin_src conf
    stash-shno = stash show --name-only
#+end_src

*** Apply the stash only, don't delete it from the stash list

When you're done, with ~git stash apply~ (top stash by default), you're back where
you were.  But if that doesn't work, for whatever reason, you can use any of
Git's other branch merging tools to put things back they way you want them.

#+begin_src conf
    # Usage: git stash-apply [STASH_INDEX]
    # Apply a specific stash to the working directory.
    stash-apply = "!f() { \
        if [ -z \"$1\" ]; then \
            git stash apply; \
        else \
            git stash apply stash@{$1}; \
        fi \
    }; f"
    # Apply changes but don't delete them.
#+end_src

https://stackoverflow.com/questions/11269256/how-to-name-and-retrieve-a-stash-by-name-in-git:

#+begin_src conf
    # Find stash with name like text.
    stash-apply = "!f() { \
        git stash apply stash^{/$@}; \
    }; f"

    stash-apply = "!f() { \
        git stash apply stash^{/$*}; \
    }; f"
#+end_src

#+begin_src conf
    # Revert the changes introduced by the most recent stash.
    stash-revert = !git stash show -p --no-textconv --binary \
                | git apply -R
#+end_src

*** Restore shelved changes

#+begin_src conf
    # Usage: git find-stash-id [SEARCH_STRING]
    # Find the stash ID by searching stash descriptions for a specific string.
    find-stash-id = "!f() { \
        git stash list \
            | grep $@ \
            | head -n 1 \
            | sed -n 's/stash@{\\(.*\\)}.*/\\1/p'; \
    }; f"
    # Only accepts single word, no quotations.

    # Usage: git pop-stash [STASH_INDEX_OR_ID]
    # Appliy and remove the specified stash by index or ID.
    stash-pop = "!f() { \
        git stash pop stash@{$(git find-stash-id $@)}; \
    }; f"
#+end_src

~git unstash~ removes the most recent stash or any stash specified and applies
changes as a merge.  If merge fails, the stash is not removed from the list and
must be removed manually.

#+begin_src conf
    # Usage: git unstash [STASH_INDEX]
    # Apply the most recent stash and removes it from the stash stack.
    # Apply and remove a specific stash from the stash stack.
    unstash = "!f() { \
        if [ -z \"$1\" ]; then \
            git stash pop; \
        else \
            git stash pop stash@{$1}; \
        fi \
    }; f"
#+end_src

#+begin_warning
Be aware that, unlike ~git stash apply~ (though it has its use), ~git unstash~
*deletes the applied stash* -- /only/ if the stash is cleanly applied.  If there are
conflicts, Git will not remove it (but it will still apply it)!
#+end_warning

*** Drop the stash

#+begin_src conf
    # Usage: git stash-remove [STASH_INDEX]
    # Remove a specific stash from the stash stack without applying changes.
    stash-remove = stash drop
#+end_src

*** Clear

#+begin_src conf
    # Usage: git stashes-clear
    # Remove all stashes from the stash stack.
    stashes-clear = "!git stash list \
                   | cut -d: -f1 \
                   | xargs -r -I {} git stash-remove {}"
#+end_src

*** Workflows

Alternative to ~stash~ (writing a commit with a default message):

XXX See doc of git help stash for workflows...

1. Do a regular ~commit~:

   : git add -A && git commit -m 'WIP'       # Add all changes (including untracked files).

2. Do some other work...

3. Return to previous work:

   : git reset --mixed                       # Reset the previous commit (but
   :                                         # keeps all the changes from that
   :                                         # commit in the working tree).
   :
   : git reset --soft                        # Or this one???

   Or, if I merely need to modify the *previous* commit:

   : git commit -a --amend

   The ~-a~ *adds any modifications and deletions of existing files* to the commit
   but ignores brand new files.

   The ~--amend~ launches your default commit editor and lets you change the
   commit message of the *most recent* commit.

*** From git help stash

       Pulling into a dirty tree

           When you are in the middle of something, you learn that there are
           upstream changes that are possibly relevant to what you are
           doing. When your local changes do not conflict with the changes in
           the upstream, a simple git pull will let you move forward.

           However, there are cases in which your local changes do conflict with
           the upstream changes, and git pull refuses to overwrite your
           changes. In such a case, you can stash your changes away, perform
           a pull, and then unstash, like this:

               $ git pull
                ...
               file foobar not up to date, cannot merge.
               $ git stash
               $ git pull
               $ git stash pop

       Interrupted workflow

           When you are in the middle of something, your boss comes in and
           demands that you fix something immediately. Traditionally, you would
           make a commit to a temporary branch to store your changes away, and
           return to your original branch to make the emergency fix, like this:

               # ... hack hack hack ...
               $ git create-branch my_wip
               $ git commit -a -m "WIP"
               $ git checkout master
               $ edit emergency fix
               $ git commit -a -m "Fix in a hurry"
               $ git checkout my_wip
               $ git reset --soft HEAD~
               # ... continue hacking ...

           You can use git stash to simplify the above, like this:

               # ... hack hack hack ...
               $ git stash
               $ edit emergency fix
               $ git commit -a -m "Fix in a hurry"
               $ git stash pop
               # ... continue hacking ...

       Testing partial commits

           You can use git stash push --keep-index when you want to make two or
           more commits out of the changes in the work tree, and you want to
           test each change before committing:

               # ... hack hack hack ...
               $ git add --patch foo            # add just first part to the index
               $ git stash push --keep-index    # save all other changes to the stash
               $ edit/build/test first part
               $ git commit -m 'First part'     # commit fully tested change
               $ git stash pop                  # prepare to work on all other changes
               # ... repeat above five steps until one commit remains ...
               $ edit/build/test remaining parts
               $ git commit foo -m 'Remaining parts'

       Recovering stashes that were cleared/dropped erroneously

           If you mistakenly drop or clear stashes, they cannot be recovered
           through the normal safety mechanisms. However, you can try the
           following incantation to get a list of stashes that are still in your
           repository, but not reachable any more:

               git fsck --unreachable |
               grep commit | cut -d\  -f3 |
               xargs git log --merges --no-walk --grep=WIP

* Commits

** Create a commit

#+begin_src conf
    # Usage: git ci -m "MESSAGE"
    # Alias for "git commit".
    ci = commit
#+end_src

A guide on commit messages:
https://dev.to/yvonnickfrin/a-guide-on-commit-messages-d8n

A useful template for good commit messages (see
https://medium.com/compass-true-north/writing-good-commit-messages-fc33af9d6321):

Implementing a Strong Code-Review Culture
https://www.youtube.com/watch?v=PJjmw9TRB7s

#+begin_src text :tangle .git_commit_template.txt
# |<------   50-character subject line   ------->|<------------------->|
# If applied, this commit will...
# [Add / Fix / Remove / Update / Refactor / Document] [summary]


# |<-----   Optional 72-character wrapped extended description   ----->|
# This should answer:
# - Why is this change necessary?  (goals, use cases, stories, etc.?)
# - How does this change address the issue?  (implementations, algorithms, etc.?)
# - What side effects does this change have?


# Include a link to the ticket, if any.
# Closes #ISSUE_NUMBER


# --- COMMIT END ---
# Emoji can be
#    :star:              Add new feature ...
#    :bug:               Fix bug ...
#    :x:                 Remove ...
#    :hammer_and_wrench: Update ...
#    :recycle:           Refactor code ...
#+end_src

# https://dev.to/sublimegeek/semantic-commit-messages-with-emojis-3p8h
# https://gist.github.com/rxaviers/7360908
# https://www.webfx.com/tools/emoji-cheat-sheet/

# https://gist.github.com/zakkak/7e06725ebd1336bfebebe254de3de825

# https://help.github.com/en/github/managing-your-work-on-github/closing-issues-using-keywords
# https://confluence.atlassian.com/bitbucket/resolve-issues-automatically-when-users-push-code-221451126.html
# https://docs.gitlab.com/ee/user/project/issues/managing_issues.html#default-closing-pattern

and you'll be guided into writing concise commit subjects in the imperative
mood -- a good practice. See rule 5 of Chris Beam's "How to write a commit
message" for the inspiration of this tip and more reasoning on the use of the
imperative mood.

You can automatically *close an issue* by using a supported keyword in commit
message, such as ~Closes #10~.  (You should always include the ~#~ if you want to
ensure that links back to the issue resolve.)

For a list of supported keywords, see:
- https://docs.github.com/en/free-pro-team@latest/github/managing-your-work-on-github/linking-a-pull-request-to-an-issue#linking-a-pull-request-to-an-issue-using-a-keyword
- https://support.atlassian.com/bitbucket-cloud/docs/resolve-issues-automatically-when-users-push-code/

See also https://gitlab.com/emacs-stuff/git-commit-insert-issue for better Emacs
support.

#+begin_src conf
[commit]
    template = ~/.git_commit_template.txt
#+end_src

This is a handy table for labels [[https://github.com/angular/angular/blob/master/CONTRIBUTING.md][Angular's commit standards and guidelines]]:

| Label    | Description                                                                                            |
|----------+--------------------------------------------------------------------------------------------------------|
| feat     | A new feature                                                                                          |
| fix      | A bug fix                                                                                              |
| style    | Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc) |
| refactor | A code change that neither fixes a bug nor adds a feature                                              |
| perf     | A code change that improves performance                                                                |
| test     | Adding missing or correcting existing tests                                                            |
| chore    | Changes to the build process or auxiliary tools and libraries such as documentation generation         |
| doc      | Documentation only changes                                                                             |

** Get a commit hash

#+begin_src conf
[alias]

    # Usage: git last-commit-hash
    # Show abbreviated hash of the last commit.
    # Examples:
    #   git last-commit-hash          find hash of last commit
    #   git last-commit-hash develop  find hash of last commit in develop
    last-commit-hash = log -1 --pretty=format:'%h'
#+end_src

** Get a commit detail

List all the changed files *in a commit* (also in a /merge commit/):

#+begin_src conf
    # Usage: git changed-files [COMMIT]
    # Show all files modified in each commit, including merge commits.
    # Examples:
    #   git changed-files             list files modified in last commit
    #   git changed-files bada55      list files modified in this commit
    changed-files = show --pretty="format:" --name-only -m
#+end_src

** Get the diff of a commit

#+begin_src conf
    download-email-patch = XXX git format-patch $(git current-branch).patch

    # Usage: git download-commit-plain-diff [COMMIT]
    # Create a diff file for the changes in a commit or range of commits.
    download-commit-plain-diff = "!f() { \
        git diff ${1:-HEAD}~ ${1:-HEAD} > ${1:-HEAD}.diff; \
    }; f"
#+end_src

** Diff

Use a generic rev syntax (rev-parse) to transparently allow complex rev
expressions.

#+begin_src conf
    # Usage: git difftool-rev [REVISION]
    # Launch a diff tool for a specific revision or branch.
    difftool-rev = "!f() { \
        REV=$(git rev-parse \"${*:-HEAD}\"); \
        git difftool $REV~1 $REV; \
    }; f"
#+end_src

This allows doing nice things like:

: git difftool-rev :/some nasty bug

Diff the last commit for a given file:

#+begin_src conf
    # Usage: git file-diff-last-modification FILENAME
    # Show the diff of the last commit that modified a specific file using
    # a diff tool.
    file-diff-last-modification = "!f() { \
        PROJECT_ROOT_DIR=$(git root); \
        echo Finding full file path of $1 in $PROJECT_ROOT_DIR; \
        FILEPATH=$(find $PROJECT_ROOT_DIR -type f -name $1); \
        echo full file path $FILEPATH; \
        LAST_MODIFIED_COMMIT_HASH=$(git rev-list -1 HEAD $FILEPATH); \
        echo last commit file modified $LAST_MODIFIED_COMMIT_HASH; \
        git difftool $LAST_MODIFIED_COMMIT_HASH^ $FILEPATH; \
    }; f"

    file-diff-last-modification2 = "!f() { \
        PROJECT_ROOT_DIR=$(git rev-parse --show-toplevel); \
        echo Finding full file path of $1 in $PROJECT_ROOT_DIR; \
        FILEPATH=$(git ls-files --full-name -- $1); \
        echo Full file path $FILEPATH; \
        LAST_MODIFIED_COMMIT_HASH=$(git log -1 --pretty=format:%H -- $FILEPATH); \
        echo Last commit file modified $LAST_MODIFIED_COMMIT_HASH; \
        git difftool $LAST_MODIFIED_COMMIT_HASH^ $FILEPATH; \
    }; f"
#+end_src

Usage (no matter where you are in the repo):

: git file-diff-last-modification File.cpp

This opens your configured ~difftool~ with the changes to =File.cpp= in the last
commit it was touched.

*** Performing directory diffs (Comparing folders)

The following command makes it similar to the =git-meld.pl= script here:
https://github.com/wmanley/git-meld:

#+begin_src conf
    # Usage: git dir-diff
    # Open Meld with directory comparison for all modified files.
    dir-diff = difftool -t meld --dir-diff
#+end_src

** Get the references the commit has been pushed to (which branches and tags?)

List all the *branches and tags* (XXX) that contain a specific commit.

#+begin_src conf
    # Usage: git find-branches-containing COMMIT_HASH
    # List references that contain a specific commit hash.
    find-branches-containing = branch -a --contains
#+end_src

Filter the list of *branches* to only those which have the given *commit ID* among
their ancestors.

This also includes *remote tracking branches* in the list, that is "local
branches that have a direct relationship to a remote branch".

#+begin_src conf
    # List local branches that point to the current HEAD commit.
    where2 = for-each-ref --format="%(refname:short)" --points-at HEAD refs/heads
#+end_src

List all *tags* that contain a specific commit ID:

#+begin_src conf
    # Usage: git find-tags-containing COMMIT_HASH
    # Find tags containing commit.
    find-tags-containing = "!f() { \
        git tag -l --contains $1 \
            | sort -r; \
    }; f"
#+end_src

** Check if one commit is an ancestor of another

#+begin_src conf
    # Usage: git is-ancestor COMMIT_1 COMMIT_2
    # Check if one commit is an ancestor of another.
    is-ancestor = !$HOME/bin/git-is-ancestor
#+end_src

** Search for commits

#+begin_note
Just for the record -- searching anything "in a branch" is not possible due to
the principle of branches.  Branch is only a pointer to a single commit, which
is considered to be "the last commit of the branch", and commits itself do not
"belong to a branch" anyhow else.

Therefore, Git cannot determine "which branch was which" before merge commits.
#+end_note

: curl --request GET --header "PRIVATE-TOKEN: YOUR_ACCESS_TOKEN" https://gitlab.example.com/api/v4/search?scope=commits&search=bye
: curl --request GET --header "PRIVATE-TOKEN: YOUR_ACCESS_TOKEN" https://gitlab.example.com/api/v4/groups/3/search?scope=issues&search=file

*** Search within Commit Messages

You can find commits that contain particular words in the commit message. For
example, ~fix typo~ matches commits containing the words ~fix~ *and* ~typo~.

If you want to find all commits (*across all branches*, showing names and status
of changed files) where *log message* matches a specified pattern (regular
expression), use ~find~.

#+begin_src conf
    # Error with 2 search strings!!!
    search-for-commits-all-1 = "log -i --all --grep"
#+end_src

You may want to add history to search through the whole repository, by adding
~rev-list~ to your ~git log~:

#+begin_src conf
    # Only one search string is read!
    search-for-commits-all-2 = "!f() { \
        git log --grep \"$1\" -i $(git rev-list --all); \
    }; f"
#+end_src

# #+begin_tip
# If you only add options to one single ~git~ command, there is no benefit to the
# function wrapper.  On the contrary, you can't add other options.
# #+end_tip

To find commits that match *either* of patterns (implicit *OR* semantic), you can
use:

: git log --grep=FOO --grep=BAR

Here's the alias which simply loops over each argument and calls ~git
log --grep~. Equivalent of calling ~git log --grep A --grep B --grep C ...~:

#+begin_src conf
    # Usage: git search-for-commits-bitbucket-or KEYWORD...
    # Search for commit messages that match one or more search patterns (Filter
    # by message).
    search-for-commits-or-bitbucket = "!f() { \
        for l in \"$@\"; do \
            git log --grep \"$l\" -i --format=\"%at:%C(green)%ad%C(reset) %C(yellow)%h%C(auto)%d%C(reset) %s %C(bold blue)<%an>%C(reset)\" --color=always; \
            printf \"\\n\"; \
        done | sort -r; \
    }; f"
    # XXX Wrong sorting if all on the same date (wth "testing failure" on PFlow)
    # XXX Add all, date short...
#+end_src

: testing failure

To find /commit/ that has *both* line matching first and line matching second
somewhere, use the *AND* semantic:

: git log --grep=FOO --grep=BAR --all-match

#+begin_src conf
    # Usage: git search-for-commits-gitlab-and PATTERN...
    # Search for commits that match one or more search patterns in commit
    # messages OR DIFF CONTENTS??? (Filter by message).
    search-for-commits-and-gitlab = "!f() { \
        CMD=\"git log --all-match -i\"; \
        for PATTERN in \"$@\"; do \
            CMD=\"$CMD --grep '$PATTERN'\"; \
        done; \
        eval $CMD; \
    }; f"
#+end_src

: curl -H "Accept: application/vnd.github.cloak-preview" \
:     https://api.github.com/search/commits\?q\=repo:fniessen/org-html-themes+local+css \
:     | jq '.items[] | {commit}'

Add ~--name-status~ to show only names and status of *changed files*.

Show the *last commit* whose *message matches a regexp*:

: # Show the LATEST commit which has the text "fix: font" in its message.
: git log :/"fix: font"
: git show :/"fix: font"
:
: # Show the LATEST merge commit.
: git show :/^Merge

*** Search by Author

#+begin_src conf
    # Usage: git author-commits [AUTHOR_EMAIL]
    # Show commit history for a specific author.
    author-commits = "!f() { \
        git log --author=${1-$(git config --get user.email)} -i --no-merges --all; \
    }; f"
#+end_src

*** Search on File Changes

**** Search string (added/removed) in code

If you want to find all commits where a *string* was *added or removed* in the /file
contents/ (to be more exact: where its *number of occurrences changed* in the
source file), i.e. search the /commit contents/, use ~-S~.

You can dig up commits that have, for example,
- removed calls to a specific function, or
- added a certain CSS classname.

#+begin_warning
If the number of times "foo" appears in the file is the same before and after
a commit, it will not match using ~-S "foo"~.
#+end_warning

In other words, to find the following commit:

#+begin_src diff :tangle no
@@ -4211,9 +4211,10 @@ public class MovesHandler extends EventHandlerBase {
      */

     private boolean actionsNotCompleted(final EventHandlerContext context, final String mo_id) {
         final Object found_mo_id =
                 selectDbValue(context, "activity_log", "activity_log_id", "mo_id=" + mo_id
-                    + " AND status NOT IN ('COMPLETED-V','REJECTED','CANCELLED')");
+                    + " AND status NOT IN ('COMPLETED-V','CLOSED','REJECTED','CANCELLED')");
         return (found_mo_id != null);
     }
#+end_src

you *need to search on 'CLOSED'*.  Searching on 'COMPLETED-V' would not bring back
that commit!

: git log --since="1 week ago" --all -S "foo"

The alias ~search-for-diff-contents~ lets you view the Git log filtered by
a specific string.

Prettier ~whatchanged~ with full diffs based on text search:

#+begin_src conf
    # Usage: git search-for-diff-contents SEARCH_TERM
    # Search for commits that add or remove a specific term in the repository's diff contents.
    search-for-diff-contents = "!f() { \
        git log -S \"$1\"; \
    }; f"
#+end_src

The alias ~search-changes-for-term~ allows you to view the Git log with a specific
search term within the entire codebase, including commit messages, file changes,
and diffs.

#+begin_src conf
    # Usage: git search-changes-for-term SEARCH_TERM
    # Search for changes that introduced or removed a specific term in the repository.
    search-changes-for-term = log -p -S
#+end_src

#+begin_src conf
    # Usage: git show-commits-for-string STRING FILENAME
    # Show commits that add or remove a specific string in a file.
    # Example: git show-commits-for-string CLOSED '*.java'
    show-commits-for-string = "!sh -c 'git log -p -S \"$1\" \"$2\"' -"
#+end_src

By default, ~-S~ accepts a string, but can be modified to accept a *regexp* with
~--pickaxe-regex~.

**** Search regexp (added/removed/changed?) in code

String contained in added/removed lines from diff contents.

With the ~-G~ option, the commit is shown in the log if your *regexp* search matches
any *line* that was added, removed, or changed.

: git log --since="1 week ago" --all -G "foo"
: git log --since="1 week ago" --all --full-history -G "foo"

** Open a repository in a web browser

#+begin_src conf
    browse-commits = "!f() { \
        URL=$(git config --get remote.$(git origin).url); \
        xdg-open ${URL/.git}/commits; \
    }; f"
#+end_src

For Cygwin:

: alias xdg-open='cygstart'

** Push

** Undo changes (Oh Shit, Git!?!)

See also:
- https://ohshitgit.com/
- https://i.pinimg.com/originals/5b/af/1b/5baf1bab9f2285b4d9df6e9a959411e9.png
- https://docs.gitlab.com/ee/topics/git/numerous_undo_possibilities_in_git/
- http://gitimmersion.com/lab_16.html

*** Undo local changes which were not pushed to remote repository (after you committed)

*** Undo changes after they are pushed to remote repository

**** Without history modification (preferred way)

git revert?

**** With history modification (requires coordination with team and force pushes)

*** Remove sensitive data from a repository

If you commit sensitive data, such as a password or SSH key into a Git
repository, you can remove it from the history. To entirely remove unwanted
files from a repository's history you can use:
- either the ~git filter-branch~ command
- or the BFG Repo-Cleaner open source tool.

** REVERT - Undo mistakes

*** Change your last commit

This will help when we need to change the most recent commit.

#+begin_warning
~git commit --amend~ is a dangerous operation.  Someone might forget that the
current commit has already been pushed, and amend it anyway.  What will they do
then?

Try to push the result, see a message about non-fast-forward pushes being not
allowed, then go along the "If pushing fails" section (pull, resolve, commit,
push), and we'll have two similar commits in the history.
#+end_warning

#+begin_verse
The key to understanding that is that Git does not rewrite history, it creates
new history and calls that reality.  The commits in this history have different
IDs (because the ID is the content plus the ID of its parent, changing just one
commit means everything after it must change).  If you push this new history
(with --force) everyone else will have the old divergent history.  All their
work will be on top of this divergent history.  They have to do the surgery to
put their work on your new history.

When users do a "git pull", git doesn't store that you did a rebase (it would be
nice if it did) so it assumes something has gone wrong and refuses to pull.  Git
gets a human to look at the divergence and decide what to do with it.
Unfortunately, most people don't know what to do with a divergent repository.

And yes, this applies to amended commits.

This is a common question answered on Stack Overflow.
https://stackoverflow.com/questions/8939977/git-push-rejected-after-feature-branch-rebase

This answer isn't specifically about rebase, but it illustrates how Git creates
new history.
https://stackoverflow.com/questions/27692954/change-mail-address-in-each-commit/27709938#27709938
#+end_verse

Modify the *last* commit, amending with the same message -- without your editor
prompting you for the message you've already entered!

#+begin_src conf
    # Append the staged changes to the last commit (keeping the pre-existing
    # commit message).
    recommit = commit -v --amend --reuse-message HEAD
#+end_src

Oh, you made a typo!

#+begin_src conf
    # Usage: git reword "NEW_COMMIT_MESSAGE"
    # Amend the previous commit message.
    amend = commit --amend -m
#+end_src

or use:

: git commit --amend

to open your commit editor and reword the message.

#+begin_src conf
    # Usage: git amend-author NAME EMAIL
    # Amend the last commit with a new author.
    amend-author = "!f() { \
        git commit --amend --author=\"$1 <$2>\" --reuse-message HEAD; \
    }; f"
#+end_src

After discovering these options, I find I am less fearful of making premature
commits, since they are easily fixed. (But not after pushing, of course.)

#+begin_warning
*NEVER AMEND a commit* that you've *ALREADY PUSHED* to a remote repository.
https://stackoverflow.com/questions/17176859/amending-a-pushed-commit-message
#+end_warning

Solution for *amending older commits*:
https://stackoverflow.com/questions/3042437/change-commit-author-at-one-specific-commit
(see 1st and 2nd answers!)

My new favorite alias lets you amend to a specific commit, *no* need to be the
*latest* one.

#+begin_src conf
    # Edit history.
    recommit2 = "!f() { \
        TARGET=$(git rev-parse \"$1\"); \
        git commit --fixup=$TARGET ${@:2} \
            && GIT_EDITOR=true git rebase --interactive --autostash --autosquash $TARGET~; \
    }; f"
    # See https://blog.filippo.io/git-fixup-amending-an-older-commit/

    # Checkout the commit in question, and amend its message.
    reword2 = "!f() { \
        OLD_BRANCH=$(git current-branch); \
        git checkout $1; \
        git commit --amend; \
        git checkout $OLD_BRANCH; \
    }; f"
#+end_src

*** Undo changes to one (or more) file(s) in a commit -- instead of reverting the entire commit

: git show COMMIT_HASH -- PATH/TO/FILE | git apply --reverse

*** Throw away a commit

http://www.vogella.com/tutorials/Git/article.html#resetcommits
http://git-scm.com/book/en/v2/Git-Tools-Reset-Demystified
http://git-scm.com/2011/07/11/reset.html

~git reset~ is a simple way to undo changes that haven't been shared with anyone
else.

See  Undo 'git add' before commit .

**** Soft option -- Do not touch the index file or the working tree at all

#+begin_src conf
    # Usage: git uncommit
    # Undo the most recent commit and keep the changes staged for commit again.
    uncommit = reset --soft HEAD~1
#+end_src

If you make a commit and really didn't mean to, use the ~uncommit~ alias to undo
it like this:

: git uncommit

~uncommit~ *undoes the last commit*, and *puts the changes* in the commit *into your
index* -- leaving the content of your working tree exactly as it is.  It's like
going back in time to the moment right before you committed.

That's really handy if you make a commit and accidently provide the wrong commit
message. For example:

: git commit -m "Fix bug #11"
: (damn - wrong bug number)
: git uncommit
: git commit -m "Fix bug #1"

#+begin_note
~uncommit~ here means to do just the reverse of ~commit~.
#+end_note

This can be a useful technique in resuming work on an unfinished changeset.

**** Mixed option -- Do not touch the working tree (but regenerate the index)

Reset the previous commit, but *puts* all *the changes* from that commit *in the
working tree*:

#+begin_src conf
    # Usage: git uncommit-unstage
    # Undo the most recent commit and keep the changes made in the commit as
    # unstaged changes in the working directory.
    uncommit-unstage = reset --mixed HEAD~1
#+end_src

#+begin_note
~--mixed~ with paths is deprecated; use ~git reset -- <paths>~ instead.
#+end_note

This is a useful technique if your pull fails to merge the new stuff from
upstream: ~git reset HEAD~1~, pull again, fix the conflicts, then commit your
changes again.

This can also be a useful technique to slice a single big commit to different
small commits to haste review process.

**** Hard option -- Regenerate both the index and working tree

Remove the last commit, *delete changes in your staging area and in your working
directory* (resetting every file to its committed state):

#+begin_src conf
    # Usage: git undo
    # Undo the most recent commit and delete any changes made to the code since
    # then.
    undo = reset --hard HEAD~1
#+end_src

If you reset work that you /never committed/, it is gone for good.  Too bad!  This
is quite a dangerous command (~git reset --hard~ is one of the few Git commands
which deletes information with no backout), and must be used with *EXTREME
CAUTION*.

#+begin_warning
This command will *overwrite all CHANGED tracked files* in the working tree!
(/Untracked files/ are out of scope.)
#+end_warning

#+begin_tip
If you have changes in your working tree or staging area, you'll probably want
to stash them before doing the above.
#+end_tip

#+begin_note
See the functionality of the partly overlapping ~git checkout .~ command (note
that it will only erase all your unstaged changes: the *files in your staging
index will be untouched*), by comparing [[https://wiki.mozilla.org/Cjku/git#git-reset_and_git-checkout][git reset and git checkout]].
#+end_note

Use ~git reset --hard @{u}~ to make sure the integration branch is up-to-date
before merging.

Other scenarios:
- Overtime working, did lots of stupid things.  You want to run away from what
  had been done...
- Recover context before a stale merge.

*** Revert a commit

If you make an unwanted change but it doesn't make sense to uncommit it (because
that code has been pushed to a remote repository say), you can use ~revert~ to
effectively reverse the commit in question. For example:

: git commit "Fix bug #5"
: git push
: (hmm - bad fix)
: git revert 2a5daf3f

This creates a patch that is the opposite of commit ~2a5daf3f~ and commits it to
your repository.

If you want to revert that commit without committing it (putting the reversion
into your index), use:

: git revert -n COMMIT

*** Merge multiple commits into a single commit

Consolidate changes made in multiple commits into a single commit to present
a polished and cohesive history, showcasing your attention to detail and
effective skills -- so that people think you are smart.

#+begin_src conf
    # Usage: git squash NUMBER_OF_COMMITS_TO_UNDO
    # Create a new commit that undoes the changes introduced by a specified
    # number of previous commits.
    squash = "!f() { \
        local num_unpushed=$(git rev-list @{u}..HEAD --count); \
        if [ $1 -le $num_unpushed ]; then \
            git reset --soft HEAD~$1 \
                && git commit --edit -m\"$(git log --reverse --format=%B HEAD..HEAD@{1})\"; \
        else \
            printf >&2 \"Error: Cannot squash %d commits. There are only %d unpushed commits.\\n\" $1 $num_unpushed; \
        fi \
    }; f"
#+end_src

https://bitbucket.org/blog/git-squash-commits-merging-bitbucket

*** Revert a faulty merge

https://mirrors.edge.kernel.org/pub/software/scm/git/docs/howto/revert-a-faulty-merge.txt

*** How to undo almost anything with Git

Absolutely read
https://github.com/blog/2019-how-to-undo-almost-anything-with-git!

* Branches

Terminology:

- Branch ::
     A branch is a set of check-ins with the same value for their "branch"
     property.

- Leaf ::
     A leaf is a check-in with no children in the same branch.

- Closed Leaf ::
     A closed leaf is any leaf with the closed tag. These leaves are intended to
     never be extended with descendants and hence are omitted from lists of leaves
     in the command-line and web interface.

- Open Leaf ::
     A open leaf is a leaf that is not closed.

- Fork ::
     A fork is when a check-in has two or more direct (non-merge) children in
     the same branch.

- Branch Point ::
     A branch point occurs when a check-in has two or more direct (non-merge)
     children in different branches. A branch point is similar to a fork, except
     that the children are in different branches.

(from http://chiselapp.com/user/paulfitz/repository/fossil/doc/trunk/www/branching.wiki)

** Branching model

Consistent *naming conventions* (from the [[https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow][Gitflow]] Git workflow):

- =main= or =master= (used for *production releases*)

  It should be the most stable branch. Merges commits from develop, release and
  hotfix branches.

- =develop= (used as integration branch for *"next release" development*)

  It has the newest features and fixes. Merges commits from feature and bugfix
  branches.

- prefix =feature/MSW-709-add-support-for-webm= (for new *features*, such as Jira
  *stories*)

  These branches are short lived as they only exist while a specific feature is
  being developed. Usually does not merge any commits unto it, unless there is
  another feature derived from it.

- prefix =bugfix/= (typically used to fix Release branches, such as Jira *bugs*)

  Used to fix bugs found that either exist in develop but have not made it into
  production, or that do exist in production but can wait until the next
  release. These branches merge into develop.

- prefix =release/2018-12-24= (used for preparing and testing *release* tasks)

- prefix =hotfix/fix-123-for-production= (used to *urgently fix* bugs on *production*,
  that have high impact)

  Used to fix pressing issues that are found in production. Hotfix branches
  merge directly to the main branch.

Alternatives:
- https://about.gitlab.com/blog/2014/09/29/gitlab-flow/
- https://trunkbaseddevelopment.com/ (and
  https://dev.to/alediaferia/git-tips-for-trunk-based-development-1i1g)

** Create a branch

Create a new branch (maximum 40-character name advised), and then switch to it:

#+begin_src conf
    create-branch = checkout -b
#+end_src

#+begin_note
To create a branch from a specific commit:

: git create-branch bugfix 7e09ef09

Otherwise you're in a "detached head" state, which can have odd results.
The branch method is at least a little more stable.
#+end_note

#+begin_note
I usually branch off from the commit before the offending
commit and stay there until things are resolved (unless I'm able to
resolve it myself).

Or I branch off the main branch and revert the offending commit until things are
resolved, ie. like so

: git checkout master
: git create-branch sb-master
: git revert sha1-of-offending-commit
#+end_note

** Current branch

Name of current branch (not so useful in itself, but used in other aliases):

#+begin_src conf
    # Usage: git current-branch
    # Show the current branch name (v2.22+).
    current-branch = branch --show-current
#+end_src

#+begin_note
In the "detached HEAD" state, that is when ~HEAD~ is not attached to a branch
name, there is *no branch name*. You can't get something that doesn't exist.
#+end_note

#+begin_src conf
    # Usage: git current-branch-without-slash
    # Show the current branch name (without slash).
    current-branch-without-slash = "!f() { \
        git current-branch \
            | tr '/' '-'; \
    }; f"
#+end_src

** Publish a branch

Push the ~CURRENT_BRANCH~ branch to the =origin= remote and set up tracking:

#+begin_src conf
    # Usage: git publish
    # Push the current branch to the upstream branch with the same name.
    push-upstream = !git push -u $(git origin) $(git current-branch)
    # push-upstream = !git push -u $(git remote show origin | grep 'Fetch URL' | cut -d':' -f2- | sed 's/\.git$//') $(git rev-parse --abbrev-ref HEAD)

    # Alias of 'push-upstream'.
    publish = !git push-upstream
    #+end_src

Then:
1. [[id:a7039f6e-825c-484c-8739-f3e32a9c45fc][Create a pull request]].
2. Your team lead will review the code & merge it to the main branch.

** List branches

*** Show all branches

*List all branches* (both local remote-tracking and local branches), showing SHA-1
and commit subject line for each head, along with the name of the upstream
branch (if any).

(Sort by Last updated)

: git for-each-ref --format="%(refname:short) %(upstream:track)" refs/heads

fco="!f() { git branch -a -vv --color=always --format='%(refname)' | sed "s_refs/heads/__" | sed "s_refs/remotes/__" | fzf --query="$@" --height=40% --ansi --tac --color=16 --border | awk '{print $1}' | xargs git checkout; }; f"
(fuzzy checkout a git branch)

#+begin_src conf
    # Usage: git branches
    # Show all branches with their corresponding upstream branches and commit hashes.
    branches = branch -a -vv
#+end_src

#+begin_src conf
    # Usage: git br
    # Show detailed information about all local branches, sorted by commit date.
    br = for-each-ref refs/heads \
                --sort=-committerdate \
                --format='%(color:green)%(committerdate:short)%(color:reset) %(HEAD) %(color:green bold)%(refname:short)%(color:reset) %(color:red bold)%(upstream:track)%(color:reset) %(color:yellow)%(objectname:short)%(color:reset) %(contents:subject) %(color:bold blue)<%(authorname)>%(color:reset)'
#+end_src

#+begin_src conf
    # Usage: git remote-branches
    # List all remote branches sorted by most recent commit.
    remote-branches = "!sh -c 'git fetch; \
                       for BRANCH_NAME in $(git branch -r | grep -v HEAD); do \
                           echo $(git show -s --format=\"%Cred%ci %C(green)%h %C(yellow)%cr %C(magenta)%an %C(blue)\" $BRANCH_NAME | head -n 1) \\\t$BRANCH_NAME; \
                       done | sort -r'"
#+end_src

#+begin_src conf
    # Usage: git branch-desc BRANCH_NAME
    # Edit the description of a branch.
    branch-desc = "!f() { \
        git branch --edit-description \"$1\"; \
    }; f"
#+end_src

#+begin_src conf
    # Usage: git branch-upstream
    # List local branches and their upstream branches.
    branch-upstream = for-each-ref --format='%(refname:short) <- %(upstream:short)' refs/heads
#+end_src

*** Show my branches

#+begin_src conf
    # Usage: git my-branches
    # Show all local branches created by the current user.
    my-branches = !git for-each-ref --format='%(authorname) %(refname:short)' refs/heads | grep -E \"^$(git config --get user.name)\"
#+end_src

*** Show active branches

List branches that are *not merged*.

#+begin_src conf
    br-active = "!f() { \
        git branch --no-merged \
            | grep -v '\\*'; \
    }; f"

    # Usage: git branches-active
    # Show only branches that are unmerged.
    branches-active = "!f() { \
        git branch -a -vv --no-merged \
            | grep -v '\\*'; \
    }; f"
#+end_src

*** Show merged branches

List branches whose tips are reachable from the specified commit (~HEAD~ if not
specified).

#+begin_src conf
    br-merged = "!f() { \
        git branch --merged \
            | grep -v '\\*'; \
    }; f"

    # Usage: git branches-merged
    # Show only branches that are merged.
    branches-merged = "!f() { \
        git branch -a -vv --merged \
            | grep -v '\\*'; \
    }; f"
#+end_src

*** Show stale branches

"Stale branches" are Git branches *without commits* for the last few months.  This
generally indicates old, unmaintained branches for unreleased, incomplete
features.

For GitHub, such period of inactivity is *3 months* (see
https://help.github.com/articles/viewing-branches-in-your-repository/).

** Switch branches

Checkout [[http://nvie.com/posts/a-successful-git-branching-model/][*common branches*]] (useful if you have feature branches):

#+begin_src conf
    main = checkout main
    master = checkout master
    develop = checkout develop
#+end_src

** Update branches

*** Update your current local branch with changes from the remote main

To manually *sync* a *branch* (merge ~main~ into your branch), run the following
command:

: git merge origin/main

**** Merging

If a feature branch hasn't been touched in months, and is behind the main
branch, you can sync (merge) the branch with the ~main~ branch, to *catch your
branch up* to all the latest changes on the ~main~ branch.

#+begin_src conf
    # Usage: git sync-main-merge
    # Fetch and merge the latest changes from the remote "main" branch into the current local branch.
    sync-main-merge = !git remote update -p \
                && git merge $(git origin)/$(git default-branch)
#+end_src

#+begin_src conf
    sync-main-merge2 = "!f() { \
        git remote update -p; \
        default_branch=$(git default-branch); \
        current_branch=$(git current-branch); \
        git merge origin/$default_branch; \
        merge_status=$?; \
        if [ $merge_status -eq 0 ]; then \
            echo \"Branch synced: '$current_branch' successfully synced with '$default_branch'\"; \
        else \
            git merge --abort 2>/dev/null; \
            echo \"Unable to sync branch: You can't merge until you resolve all merge conflicts.\"; \
        fi \
    }; f"
#+end_src

XXX Outputs:

- *Branch synced:* 'branch_name' successfully synced with 'main'
- *Unable to sync branch:* You can't merge until you resolve all merge conflicts.

**** Rebasing

#+begin_src conf
    # Fetch and rebase the current local branch onto the latest changes from the remote "main" branch.
    sync-main-rebase = !git remote update -p \
                && git rebase $(git origin)/$(git default-branch)
#+end_src

*** Update your local branch with changes from the remote branch

#+begin_src conf
    pull = pull -v
#+end_src

#+begin_note
~git pull~ with uncommitted changes can succeed if the newly pulled changes don't
touch the locally changed files, but will fail otherwise.  Which makes a lot of
sense.
#+end_note

Git's fix is to ask you to commit (or stash) before you pull (which is fetch
followed by merge).

#+begin_warning
The following approach:

: up = "!git stash && git pull && git stash pop"

is *unsafe*: if there's nothing to stash, the first command will do nothing, and
then ~stash pop~ will unstash some random stuff from before.
#+end_warning

#+begin_src conf
    # Usage: git pull-autostash
    # Auto-stash changes, pull, and restore stashed changes.
    pull-autostash = pull --rebase --autostash
    pull-autostash2 = "!f() { \
        if [ -n \"$(git status --porcelain -uno)\" ]; then \
            git stash push -m \"autostash\"; \
        fi; \
        git pull; \
        git stash pop; \
    }; f"
#+end_src

XXX What about ~git stash push --include-untracked~ and ~git stash pop~?

#+begin_src conf
    # Pull with rebase and auto-stash, updating your local branch with remote changes.
    up-rebase = pull --rebase --autostash

    # Update remote-tracking branches comprehensively, then rebase your current branch using fetched changes.
    up-rebase2 = !git remote update -p && git rebase --autostash FETCH_HEAD
#+end_src

See https://www.praqma.com/stories/git-autostash/.

: git rebase -i --autosquash --autostash

Really handy in projects that don't do merge commits.

*** Update your local branch with changes from the remote branch

**** Fast-forward merging

With *all versions* of Git, I recommend using ~git sync-ff-upstream~ instead of
~git pull~.

#+begin_src conf
    # Usage: git sync-ff-upstream
    # Update local branch with fast-forward from upstream.
    sync-upstream-ff = "!f() { \
        git remote update -p; \
        git merge --ff-only @{u}; \
    }; f"
    # (Keep your local branch in sync with the remote branch without creating
    # merge commits.)
#+end_src

It is pretty safe: it will abort the merge if it can't be done using
fast-forward.  (In other words, if the local branch has diverged from the
remote.)

See https://stackoverflow.com/questions/15316601/in-what-cases-could-git-pull-be-harmful

**** Rebasing

~remote update -p~ *fetches* all refs from all remotes, instead of just the needed
one; ~merge~ then merges the appropriate *single branch*.

#+begin_src conf
    # Update remote-tracking branches and rebase the current local branch onto the upstream branch it tracks.
    sync-upstream-rebase = "!f() { \
        git remote update -p; \
        git rebase -p @{u}; \
    }; f"
    # Rebasing non-linear changes (when the fast-forward merge is not possible).
#+end_src

... but read "you're not using Git as it was intended" on
https://news.ycombinator.com/item?id=2301765.

*** Synchronize all local branches with their corresponding remote branches

See [[http://aanandprasad.com/git-up/][git-up]] (no longer maintained), which is (roughly) equivalent of executing the following:

: git stash
: git fetch --all
: [foreach branch_name]
:     git rebase --rebase-merges <branch_name> <remote>/<branch_name>
:     git merge --ff-only <branch_name>
: [end foreach]
: git checkout <old_branch>
: git stash pop

#+begin_warning
Use with care: the final stash application after a successful rebase might
result in non-trivial conflicts.
#+end_warning

#+begin_src conf
    # Iteratively synchronize all local branches with their corresponding remote branches using fast-forward merges.
    sync-all-branches = "!f() { \
        local old_branch=$(git current-branch); \
        for branch_ref in $(git for-each-ref refs/heads --format='%(refname)'); do \
            local branch_name=${branch_ref#refs/heads/}; \
            if [ \"$branch_name\" != \"$old_branch\" ]; then \
                echo \"Switching to branch: $branch_name\"; \
                git checkout $branch_name && \
                git pull --ff-only; \
                echo; \
                echo; \
            fi; \
        done; \
        git checkout $old_branch; \
    }; f"
#+end_src

See http://stackoverflow.com/questions/4318161/can-git-pull-all-update-all-my-local-branches
(+ interesting comments about *rebase vs merge during a pull*!)

** Close a branch

Manage branches that you no longer plan on working with.

: git checkout badbranch
: git rename-branch badbranch badbranch-CLOSED

This renames the branch, and keeps your coworkers happy.

#+begin_note
Such a closed branch is still considered active and will be displayed by
default.
#+end_note

** Delete a branch

*** Delete a local branch

Delete a *local* branch:

#+begin_src conf
    # Delete a local branch.
    delete-local-branch = branch -d
#+end_src

#+begin_note
The ~-d~ (~--delete~) option only deletes the branch if it has already been fully
merged in its upstream branch.

You could also use ~-D~, which is an alias for ~--delete --force~, which deletes the
branch "irrespective of its merged status."
#+end_note

*** Delete local branches that have been merged

~delete-local-merged-branches~ *removes* (in bulk) *all* the *local branches* that have
been *merged to the current branch* that you are in.

XXX https://haacked.com/archive/2014/07/28/github-flow-aliases/

#+begin_src conf
    # Delete local branches that have been merged into the default branch.
    bclean = "!f() { \
        DEFAULT_BRANCH=$(git default-branch || echo 'main'); \
        git branch --merged ${1-$DEFAULT_BRANCH} \
            | grep -v " ${1-$DEFAULT_BRANCH}$" \
            | xargs git delete-local-branch; \
    }; f"
#+end_src

It deletes every branch that's been merged into the specified branch except the
branch.

#+begin_src conf
    # Delete fully merged branches.
    delete-local-merged-branches = "!f() { \
        git branch --no-color --merged \
            | grep -v '\\*' \
            | egrep -v \"(master|main|develop)\" \
            | xargs -n 1 git delete-local-branch; \
    }; f"

    # # https://stackoverflow.com/questions/6127328/how-can-i-delete-all-git-branches-which-have-been-merged
    # sweep = '!git branch --merged $([ $1 != "-f" ] && git rev-parse master) | \
    #           egrep -v "(^\*|^\s*(master|main|develop)$)" | \
    #           xargs git delete-local-branch'
#+end_src

Not "fully merged" means the branch you are about to delete contains commits
that are not reachable from any of:
- its upstream branch, or
- ~HEAD~ (current branch).
In other words, when you might lose commits.

#+begin_tip
In the event that you accidentally delete ~main~, get it back with:

: git create-branch main $(git origin)/main
#+end_tip

See http://haacked.com/archive/2014/07/28/github-flow-aliases/.

See
https://www.oreilly.com/library/view/git-pocket-guide/9781449327507/ch05.html
for the distinction between "merged" and "fully merged" branches!

- https://stackoverflow.com/questions/6127328/how-can-i-delete-all-git-branches-which-have-been-merged
- https://github.com/arc90/git-sweep

#+begin_src conf
    # Delete branches safely merged into the main branch, skipping main and *
    # (current) branches.
    cleanup-branches = !git branch --merged $(git default-branch) \
                            | grep -vE '^\\* | $(git default-branch)$' \
                            | xargs -r git delete-local-branch
    # On OSX, 'xargs' does not have '-r' argument, so it fail. If you remove
    # '-r', it will run at least once, making this not safe operation.
#+end_src

*** Delete a remote branch

Delete a *remote* branch:

#+begin_src conf
    # Usage: git delete-remote-branch BRANCH_NAME
    # Delete a remote branch.
    delete-remote-branch = !git push $(git origin) --delete

    # Usage: git unpublish
    # Delete the current branch from the remote repository.
    unpublish = !git delete-remote-branch $(git current-branch)
#+end_src

*** Delete a branch locally and on the ~origin~ remote

#+begin_src conf
    delete-branch = "!f() { \
        git delete-local-branch $1 \
            && git delete-remote-branch $1; \
    }; f"
#+end_src

*** Delete all orphaned branches (that no longer exist at remote)

Once you delete the branch from the remote, you can *remove all orphaned
remote-tracking branches that you have locally*, in =.git/refs/remotes/origin=, but
are *no more present in the remote repository* ~origin~ with:

: git remote prune $(git origin)

Use the ~--dry-run~ flag to only see what branches will be pruned, but not
actually prune them:

: git remote prune $(git origin) --dry-run

#+begin_src conf
    # Usage: git prune-all
    # Prune deleted branches from all remotes.
    prune-all = !git remote \
                | xargs -n 1 git remote prune
    # 'git remote prune' does not understand '--all'.

    # There's no way to tell git remote update to prune orphaned branches?
#+end_src

#+begin_tip
If you want this to be run automatically every time you fetch/pull:

: git config --global fetch.prune true
#+end_tip

or prune individual remote tracking branches with:

: git delete-local-branch BRANCH_NAME

*Remove orphaned branches in your local repository* that *no longer exist in the
remote* one (by deleting the local ones that show they are "gone" in ~git
branch -vv~):

#+begin_src conf
    # Usage: git prune-local-branches
    # Prune local branches that have been removed from the remote repository.
    prune-local-branches = "!f() { \
        git branch -vv \
            | grep ': gone]' \
            | awk '{print $1}' \
            | xargs git delete-local-branch; \
    }; f"
    #+end_src

Delete local branches that are tracking remote branches that are gone.

** Rename a branch

Sometimes we name a branch poorly or maybe we thought the name was "good" but
not meaningful to the work we are doing.

To rename a branch *locally*:

- If we are on the branch we want to rename, we can just

  : git rename-local-branch NEW_BRANCH_NAME

- If we are on another branch, we have to use

  : git rename-local-branch OLD_BRANCH_NAME NEW_BRANCH_NAME

#+begin_src conf
    # Usage: git rename-local-branch [OLD_BRANCH_NAME] NEW_BRANCH_NAME
    # Rename a local branch.
    rename-local-branch = branch -m
#+end_src

To rename a branch *locally and remotely*:

1. Rename the branch locally,
2. Push the new branch and set local branch to track the new remote, and
3. Delete the old branch.

#+begin_src conf
    # Usage: git rename-branch OLD_BRANCH_NAME NEW_BRANCH_NAME
    # Rename both a local and remote branch.
    rename-branch = "!f() { \
        git rename-local-branch $1 $2 \
            && git push --set-upstream $(git origin) $2 \
            && git delete-remote-branch $1; \
    }; f"
#+end_src

** What if

... I'm working on the main branch adding a simple feature. After a few minutes I realize
it was not so simple and it should have been better to work into a new branch.

http://stackoverflow.com/questions/2569459/git-create-a-branch-from-unstaged-uncommited-changes-on-master

* Tags

Tags give the ability to *mark a specific commit* in your repository history as
being important.

** Create a tag

While Git supports annotated and lightweight tags, you can only *create*
- *lightweight tags* via /GitHub/ interface (for releases), and
- *annotated tags* in /Bitbucket/ and in /GitLab/.

*Lightweight tags* are just pointers to specific commits.  They *don't include any
further information*.

*Annotated tags* are *regular objects* in the repository, which means they have an
author, a date, a message, and can be referred because they have their own SHA-1
key.

If knowing *who* tagged *what* and *when* is relevant for you, then use /annotated
tags/. If you *just want to tag a specific point in your development*, no matter
who and when did that, then /lightweight tags/ are good enough.

#+begin_note
/Annotated tags/ are meant for *release* while /lightweight tags/ are meant for
private or temporary object labels.
#+end_note

Create an /annotated tag/:

: git tag -a TAG_NAME -m 'TAG_MESSAGE'

Create a /lightweight tag/ (/no message!/):

: git tag TAG_NAME

Create a date/time tag with a suffix, e.g: 2021.01.12_15.25_PREVIOUS:

#+begin_src conf
    # Usage: git tag-with-date [SUFFIX]
    # Tag the current commit with the current date and a custom suffix.
    tag-with-date = "!sh -c 'git tag $(date \"+%Y.%m.%d_%H.%M\")_\"$0\"'"
#+end_src

** See the commits for a tag

See the list of all the commits for that tag.

: git ls TAG_NAME

** Push a tag to your repository

#+begin_src conf
    # Usage: git publish-tag TAG_NAME [REMOTE_NAME]
    # Publish a Git tag to a remote repository.
    publish-tag = "!sh -c 'git push ${2:-$(git origin)} $1' -"

    # Usage: git unpublish-tag TAG_NAME [REMOTE_NAME]
    # Remove a published Git tag from a remote repository.
    unpublish-tag = "!sh -c 'git push ${2:-$(git origin)} :refs/tags/$1' -"
#+end_src

Push all your tags (a regular push won't push a tag):

#+begin_src conf
    push-tags = push --tags
#+end_src

: git push --tags                         # Only tags.
: git push --tags $(git origin) master    # Code and tags.

** List the repository tags

List tags using (better) version sorting (not going from =v0.1= to =v0.10=):

#+begin_src conf
    # List tags.
    tags = tag -l --sort=v:refname

    # Show a list of tag names and the commits they reference.
    tags-show-ids = show-ref --tags
#+end_src

: # Show annotated and lightweight tags.
: git show-ref -d --tags \
:     | cut -b 42- \
:     | sort \
:     | sed 's/\^{}//' \
:     | uniq -c \
:     | sed 's/2\ refs\/tags\// a /' \
:     | sed 's/1\ refs\/tags\//lw /'
: # 2. Remove the commit-id.
: # 4. Remove ^{} markings.
: # 5. Count identical lines.
: # 6. 2 identicals = annotated.

Show the last tag /in the current branch/:

#+begin_src conf
    last-tag = describe --tags --abbrev=0
#+end_src

Show the latest tag /in all branches/:

#+begin_src conf
    last-tag-all = !git describe --tags $(git rev-list --tags --max-count=1)
#+end_src

** Rename a tag

Change the tag name but keep it on the same commit.

#+begin_src conf
    # Usage: git rename-tag OLD_TAG_NAME NEW_TAG_NAME
    # Rename a tag (locally and remotely).
    rename-tag = "!f() { \
        git tag $2 $1; \
        git tag -d $1; \
        git push $(git origin) $2; \
        git push $(git origin) :refs/tags/$1; \
    }; f"
#+end_src

** Clear a tag

If you have defined a tag and no longer want it defined, use the ~delete-tag~
alias to remove it.

#+begin_src conf
    # Delete local and remote tags.
    delete-tag = "!f() { \
        [ -z $1 ] \
            && echo \"No tags given as an argument!\" \
            || (git tag -l $1 | \
                xargs -I % echo \"git tag -d % \
                               && git push --delete $(git origin) %\" | \
                sh); \
    }; f"
#+end_src

For example:

: git tag v2.0-beta-4
: (oops, we're not releasing a 4th beta)
: git delete-tag v2.0-beta-4

Delete similar tags:

: git delete-tag 'v2.0-*'

** Remove all tags

#+begin_src conf :tangle no
    # Delete all local and remote tags.
    delete-all-tags = "!f() { \
        for TAG_NAME in $(git tags); do
            git tag -d $TAG_NAME
            git push $(git origin) :$TAG_NAME
        done;
    }; f"
#+end_src

* Compare Revisions (commits, branches or tags)

*See what's changed* between two revisions.

Easily determine which changes:
- are on the "compare" side (= merge /source/) but
- are /not/ on the "base" side (= merge /destination/).

#+begin_note
Diff using three-dot (~...~) notation.

When you use three dots (...), ~git diff~ finds the merge-base between the left
and right side commit SHA-1s and substitutes that in for the left-side
SHA-1. The right-side SHA-1 remains intact.
#+end_note

You can see:
- a list of commits,
- a list of changed files,
- a diff, and
- any pull requests merged between the two versions.

** Commits

#+begin_src conf
    # Usage: git compare-commits REV_BASE REV_COMPARE
    compare-commits = "!f() { \
        git log $1...$2; \
    }; f"
#+end_src

** Files changed

List all the changed *files between 2 commits*:

#+begin_src conf
    # Usage: git compare-changed-files REV_BASE REV_COMPARE
    # Show changed files between two commits.
    compare-changed-files = "!f() { \
        git diff --stat $1...$2; \
    }; f"
#+end_src

** Diff

View all diffs.

- Inline diff (unified, single view)

  #+begin_src conf
    # Usage: git compare REV_BASE REV_COMPARE
    #      = git diff REV_BASE...REV_COMPARE
    # Example: git compare master@{1day} master
    compare = "!f() { \
        git diff $1...$2; \
    }; f"
    # https://github.com/fniessen/git-leuven/compare/master@%7B1day%7D...master
  #+end_src

- Side-by-side diff (split view)

*** Compare files from two different branches

: git diff BRANCH_1..BRANCH_2 -- PATH/TO/FILE

If either side is ~HEAD~, it may be omitted (e.g. ~master..~ compares ~master~ to
~HEAD~).

** Merged pull requests

** Example comparisons

*** Show unmerged commits between two branches

The alias ~missing~ (an idea borrowed from Bazaar) shows the unique commits in the
current branch and the specified branch.

#+begin_src conf
    # Usage: git missing [COMMIT_ISH]
    # Show the missing commits between this and another branch
    missing = "!f() { \
        printf \"$(tput bold)Only in HEAD:$(tput sgr0)\n\"; \
        git log "${1:-$(git default-branch)}"..; \
        printf \"\n\"; \
        printf \"$(tput bold)Only in other:$(tput sgr0)\n\"; \
        git log .."${1:-$(git default-branch)}"; \
    }; f"
#+end_src

TODO: Remove hard-coded master

*How to find all the commits made only on a specific branch?*  Assuming that your
branch was created off of ~master~, then /while on the specific branch/ (that is,
you have that branch checked out):

: git missing $(git ancestor)
: git log --no-merges master..
: git log HEAD --not master
: git cherry -v master

to show commits (that you've done since you forked) that haven't made it to
~master~ yet.

#+begin_example
+ 497034f2 Listener.new now accepts a hash of options
- 2d0333ff Cache the absolute images path for growl messages
+ e4406858 Rename Listener#run to #start
#+end_example

The ~cherry~ command is useful to see which commits have been cherry-picked from
a development branch to the stable branch, for instance. This command compares
changes on the current (=feature=) branch to upstream (=master=) and indicates which
are present on both with the ~-~ sign. Changes still missing from upstream are
marked with ~+~.

**** History of a branch: List all commits on only one side of the branches

: git log --cherry-pick --left-right --graph master...BRANCH_NAME

It is a list of commits reachable from ~BRANCH_NAME~ that are not reachable from
~master~. This gives you the information you want, but if and only if you have
never merged ~BRANCH_NAME~ back to ~master~, and have never merged ~master~ into
~BRANCH_NAME~ since you created it. If you have merged, then this history of
differences will collapse.

**** Branch point

The *most recent common ancestor* is the last commit that existed in both
branches. Usually this is the branch point, but it could also be a commit that
was merged.

#+begin_src conf
    # Find the point at which a branch forked from another branch (when it was branched off).
    # Find the most recent common ancestor between the current branch and the default branch.
    ancestor = !git merge-base ${1:-$(git default-branch)} \
                               ${2:-$(git current-branch)}
    # BUG: Does not work between 2 specific branches -- well without arguments
#+end_src

https://stackoverflow.com/questions/1527234/finding-a-branch-point-with-git

The most recent common ancestor is frequently used with ~diff~ to return all of
the changes that your branch introduces, while excluding the changes that you
have not merged from the remote branch.

#+begin_src conf
    # Since branch point.
    log-ancestor = !sh -c 'git log $(git ancestor)..'
    diff-ancestor = !sh -c 'git diff $(git ancestor)..'
#+end_src

*** How do I find a list of files committed to a Git branch (since branching)?

Show all the changed files in a Git branch *since it was forked*:

#+begin_src conf
    # Usage: git missing-files [COMMIT_ISH]
    # Show the changed files between this and (the fork point from) another branch
    # Examples:
    #   git missing-files             list changed files between this and master
    #   git missing-files feature/7   list changed files between this and the 'feature/7' branch
    missing-files = "!f() { \
        git diff --stat ${1:-$(git default-branch)}...; \
    }; f"
#+end_src

XXX

#+begin_src shell :tangle no
for file in $(git missing-files | awk '{print $1}'); do
    if [ -f "$file" ]; then
        echo "Results in $file:"
        grep "DI" "$file"
        echo
    fi
done
#+end_src

#+begin_src shell :tangle no
grep_in_command_results() {
    local cmd="$1"
    local pattern="$2"
    local files=$(eval "$cmd" | awk '{print $1}')

    echo cmd: $cmd
    echo pattern: $pattern
    echo files: $files

    for file in $files; do
        if [ -f "$file" ]; then
            echo "Results in $file:"
            grep "$pattern" "$file"
        fi
    done
}
#+end_src

does not work because the output of 'git status' is different when redirected to
a file or to a pipe!

XXX

See the added / copied / deleted / modified / renamed files in a branch:

: git diff forked_from_branch...my_forked_branch --name-status --diff-filter=ACDMR

Available filters for ~--diff-filter~ are:

- A :: Added
- C :: Copied
- D :: Deleted
- M :: Modified
- R :: Renamed

* xGraph

Graphical history viewers

See example at https://gitlab.com/procps-ng/procps/-/network/master

[[https://jonas.github.io/tig/][Tig]]

To see real *timeline* of who is working on what and when:

#+begin_src conf
    # 50 most recent commits.
    # XXX this is a summary?
    graph = log -50 --branches --tags --remotes --date-order --format=format:'%C(yellow)%h %C(reset) %<(75,trunc)%s <%cn> (%cr) %C(red)%d' --graph

    # Show log as a graph
    glog = log --all --graph
#+end_src

https://fossil-scm.org/home/help?cmd=leaves

#+begin_src conf
    releases = log --no-merges --all --simplify-by-decoration --graph
#+end_src

#+begin_src conf
    hist = log --graph

    hist-full = log --pretty=format:'%C(green)%cr%C(reset) %C(yellow)%h%Creset %C(yellow)%d%Creset %s %C(bold blue)<%an>%Creset%n' --graph --name-status
#+end_src

Directed Acyclic Graph:

#+begin_src conf
    # Draw Git revisions graph with graphviz.
    graphviz = "!f() { \
        echo 'digraph git {' ; \
        git log -25 --pretty='format:  %h -> { %p }' \"$@\" \
            | sed 's/[0-9a-f][0-9a-f]*/\"&\"/g' ; \
        echo '}'; \
    }; f"
#+end_src

Use [[https://graphviz.org/][Graphviz]] for display.

This produces output that can be displayed using ~dotty~, for example:

: git graphviz HEAD~100..HEAD~60 | dotty /dev/stdin
: git graphviz --first-parent master | dotty /dev/stdin

See https://tortoisegit.org/docs/tortoisegit/tgit-dug-revgraph.html

* xContributors

Show authors of commits in the repository, /excluding merge commits/.

#+begin_src conf
    contributors-name  = shortlog -n -s --no-merges --
    contributors-email = shortlog -n -s -e --no-merges --
#+end_src

#+begin_note
The ~--~ signals the /end of options/, that the rest of the parameters are limiters.
#+end_note

#+begin_src conf
    whois = "!sh -c 'git log -1 --author=\"$1\" -i --pretty=\"format:%an <%ae>\n\"' -"
#+end_src

* Pull requests

A pull request (PR), sometimes called merge request, is a review request. You
are asking someone to check the changes on a branch before merging into another
branch.

XXX See https://github.com/github/hub/

** Create a pull request
:PROPERTIES:
:ID:       a7039f6e-825c-484c-8739-f3e32a9c45fc
:END:

You'll be asked to select a "From" branch and a "To" branch.

You need to enter a PR summary.  The description is optional.

Create a pull request against the default branch:

#+begin_src conf
    pull-request-bb = "!f() { \
        USER_NAME=$1; \
        curl --user $USER_NAME https://bitbucket.org/$(git repo-owner)/$(git repo-slug)/pull-requests/new?source=$(git current-branch)&t=1; \
    }; f"
#+end_src

#+begin_src conf :tangle no
function pr () {
  if ["$1" == ""]
  then
      echo "Please provide the name of the branch to create a pull request against."
  else
      local REPO=$(git remote -v | grep -m 1 "(push)" | sed -e "s/.*github.com[:/]\(.*\)\.git.*/\1/")
      local BRANCH=$(git name-rev --name-only HEAD)
      echo "... creating pull request for branch \"$BRANCH\" in \"$REPO\""
      open https://github.com/$REPO/compare/$1...$BRANCH
  fi
}
#+end_src

Add a comment in GitHub pull request:

: curl -s -H \"Authorization: token $GITHUB_TOKEN\" -X POST -d '{\"body\": \"$TEXT_PR\"}' \"https://api.github.com/repos/$REPOSITORY_NAME/issues/$GHPRBPULLID/comments\""

** List pull requests

List pull requests in the current repository.

- Pull Requests assigned to me
- Pull Requests I've created

- *Open*
- *Merged*
- Closed
- All

Git aliases for pull requests and other useful stuff
https://gist.github.com/metlos/9368527

For GitHub
: git ls-remote $(git origin) 'refs/pull/*'

#+begin_src conf
    pr-list = XXX
#+end_src

** 1. Check out a pull request locally

XXX https://gitlab.com/help/user/project/merge_requests/index.md#checkout-merge-requests-locally

Sometimes, just reading the code of a pull request might not be enough to verify
if it should be merged.  Maybe you want to add something, or some tests are
failing, and you want to run them locally on your computer.

*Check out* the head of a *pull request* (given the pull request number) as a *local
branch*:

#+begin_src conf
    # For GitHub.
    pr-checkout-gh = "!f() { \
        git fetch $(git origin) pull/$1/head:pr/$1 \
            && git checkout pr/$1; \
    }; f"
    # https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/checking-out-pull-requests-locally

    # For GitLab.
    pr-checkout-gl = "!f() { \
        git fetch $(git origin) merge-requests/$1/head:pr/$1 \
            && git checkout pr/$1; \
    }; f"
    # https://about.gitlab.com/blog/2016/12/08/git-tips-and-tricks/#add-an-alias-to-checkout-merge-requests-locally
#+end_src

Now you can check out a particular pull request.  For example:

: git pr-checkout 5

will fetch the *pull request* #5 into a *local* ~pr/5~ *branch* and check it out.

** 2. Review the changes locally

** Push changes to a pull request

: #!/bin/bash
: TMP_FILE=$(mktemp)
: REPO_SLUG=$(git remote -v | grep '^upstream' | head -n 1 | perl -lne 's/github.com:?\/?(.*)\/([^.]*)([.]git| )// or next; print $1,"/",$2')
: PR_NUMBER=$(git rev-parse --abbrev-ref HEAD | cut -d/ -f 2)
: curl -s https://api.github.com/repos/$REPO_SLUG/pulls/$PR_NUMBER > $TMP_FILE
: trap "{ rm -f $TMP_FILE; }" EXIT
: HEAD_REF=$(cat $TMP_FILE | jq -r '.head.ref')
: HEAD_SLUG=$(cat $TMP_FILE | jq -r '.head.repo.full_name')
: git push -f git@github.com:$HEAD_SLUG HEAD:$HEAD_REF

For more details on pushing changes to a PR, please see [[https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/allowing-changes-to-a-pull-request-branch-created-from-a-fork][the official article]].

** 3. Merge the branch and fix any conflicts that come up

#+begin_note
We generally don't like $Revision:$, $Date:$, $Log$, and friends like
timestamps, because they're sources of gratuitous *merge conflicts*.
#+end_note

: git fetch $(git origin)
: git checkout "$(git origin)/master"
: git merge --no-ff "1-change-encoding-of-read-sql-file"

XXX See https://gitlab.com/help/user/project/merge_requests/squash_and_merge

** Merge pull request

If everything is OK, you can merge the pull request.

#+begin_src conf
    # For GitHub.
    mpr = "!f() { \
        declare OLD_BRANCH=\"$(git current-branch)\"; \
        declare BRANCH_NAME=\"${2:-$OLD_BRANCH}\"; \
        if [ $(printf \"%s\" \"$1\" | grep '^[0-9]\\+$' > /dev/null; printf $?) -eq 0 ]; then \
            git fetch $(git origin) refs/pull/$1/head:pr/$1 \
                && git checkout -B $BRANCH_NAME \
                && git rebase $BRANCH_NAME pr/$1 \
                && git checkout -B $BRANCH_NAME \
                && git merge --ff-only pr/$1 \
                && git delete-local-branch pr/$1; \
        fi \
    }; f"

    # Merge given pull request into the current branch.
    # The commit message will have the same for as if done using the
    # merge button on github.com
    # Example:
    #   git merge-pr $(git origin) 5
    merge-pr = "!sh -c '\
        USER_AND_REPO=$(git remote show $1 | grep \"Fetch URL:\" | sed -E \"s/.*github.com[:\\/]([a-zA-Z_\\-]+)\\/([a-zA-Z_\\-]+)\\.git$/\\1 \\2/\"); \
        USER=$(echo $USER_AND_REPO | cut -d\" \" -f1); \
        REPO=$(echo $USER_AND_REPO | cut -d\" \" -f2); \
        TMP_FILE=$(mktemp); \
        curl -si https://api.github.com/repos/$USER/$REPO/pulls/$2 > $TMP_FILE; \
        PULL_AUTHOR=$(cat $TMP_FILE | awk \"{if (/ *\\\"head\\\"/) head=\\\\$1; if (/ *\\\"login\\\": \\\"/) value=\\\\$2}{if (head && value) print value; if (head && value) exit}\" | sed -E \"s/\\\"([^\\\"]+)\\\".*/\\1/\"); \
        PULL_REF=$(cat $TMP_FILE | awk \"{if (/ *\\\"head\\\"/) head=\\\\$1; if (/ *\\\"ref\\\": \\\"/) label=\\\\$2}{if (head && label) print label; if (head && label) exit}\" | sed -E \"s/\\\"([^\\\"]+)\\\".*/\\1/\"); \
        PULL_TITLE=$(cat $TMP_FILE | grep \"\\\"title\\\": \" | sed \"s/^ *\\\"title\\\": \\\"//\" | sed \"s/\\\",$//\"); \
        rm $TMP_FILE; \
        git fetch $1 pull/$2/head; \
        git merge --no-ff -m \"Merged pull request #$2 from $PULL_AUTHOR/$PULL_REF\n\n$PULL_TITLE\" FETCH_HEAD; \
        ' -"
#+end_src

This is actually quite useful if you are a maintainer of a project on
GitHub.

There are two ways you can call it:

- ~git mpr 123~

  This will merge pull request number 123 on top of the current branch.

- ~git mpr 123 master~.

  This will merge pull request number 123 on top of the branch called master.

If you are using GitHub, you can easily merge a pull request using the web
interface, but if you want a bit more control over how you are merging the pull
requests (for example, I'm using the ~git merge --ff-only~ option, while GitHub
will use ~git merge --no-ff~), or you just want to merge a bunch of pull requests
without leaving your terminal -- this function will help you.

** 4. Push the result of the merge to the remote

: git push $(git origin) "master"

** Clean up old branch

Delete the *from* branch after PR is merged (or ignored -- if it was created
b accident or if it's irrelevant):

#+begin_src conf
    pr-clean = "!f() { \
        git delete-local-branch pr/$1; \
    }; f"
#+end_src

** Show in a web browser

Open a pull request page in a web browser.

#+begin_src conf
    pr-show = XXX <pr-number>
#+end_src

** Who?

Extra script (called [[https://github.com/mislav/dotfiles/blob/master/bin/git-overwritten][git-overwritten]]) which shows blame information about
original authors of lines changed or removed in a given branch:

: git overwritten feature $(git origin)/master

This is useful when opening pull requests per GitHub Flow; you'll want your pull
request reviewed by colleagues but you might not be sure who to ping. With
git-overwritten you'll get the names of people who wrote the lines you just
changed, so you'll know who to @-mention when opening a pull request.

> So, given a patch (or a branch) together with a "base revision", you'd get
> a list of code chunks modified by that patch, then run "annotate" on the
> base revision, and look for those code chunks, collecting the names of
> corresponding authors.

Sounds like git-guilt (which I've just read about today), might be
relevant: https://bitbucket.org/tpettersen/git-guilt

** Find the pull request that introduced a commit

Related pull request:

#+begin_src conf
    related-pr-of-commit = "!sh -c 'git log --merges --ancestry-path $1..master \
                | tail -n 1 ' -"
#+end_src

Example:

: $ git related-pr-of-commit 22689a1
: 1c6b5c4 Merge branch '5-resolve-it' into 'master'

In this case, the commit comes from pull request 5.

** Saved replies

GitHub allows to [[https://github.blog/2016-03-29-saved-replies/][save replies]]. You can set them in [[https://github.com/settings/replies][your GitHub settings]].  Here
are a couple of commonly used replies:

Missing changelog

#+begin_src text :tangle no
This still lacks a changelog entry. Please see [the changelog folder](../tree/master/changelog) for instructions.
Hence, I added the "pending changelog" label.
#+end_src

Missing spec PR

#+begin_src text :tangle no
This still needs a PR to the [specification](https://github.com/dlang/dlang.org/tree/master/spec) at [dlang.org](https://github.com/dlang/dlang.org). Hence, I added the label "missing spec PR".

Please refer to the [dlang.org CONTRIBUTING guide](https://github.com/dlang/dlang.org/blob/master/CONTRIBUTING.md) for instructions to build dlang.org locally. If you use Windows, don't worry, you can do your changes "blindly" and preview them at DAutoTest.
#+end_src

Phantom Zone

#+begin_src text :tangle no
This PR entered the Phantom Zone
-----------------------------------------------


This PR has entered the [Phantom Zone](http://forum.dlang.org/post/ouuutodvhmnghzbeoqen@forum.dlang.org) as it still needs to have the reviewers' concerns addressed and rebased.

Reason for entering the Phantom Zone
----------------------------------------------------

This PR is nice, and normally I would revive such a PR if the author was no longer active. I would also revive it if it were an important bug fix or something of higher priority.  This PR, however, is just a refactoring, so I'm going to put it in the [Phantom Zone](http://forum.dlang.org/post/ouuutodvhmnghzbeoqen@forum.dlang.org) and close it for now.

How do I get this PR out of the Phantom Zone
-------------------------------------------------------------

Easy: Address the comments -> open a new PR (mention this one + short summary in the description).
#+end_src

* Releases

You can create a release to package software, along with release notes and links
to binary files, for other people to use.

Releases are based on *Git tags*: tags are used to mark *release* versions, with the
*version number* as the *tag name*.

We recommend naming tags that fit within [[https://semver.org/][semantic versioning]], i.e. having the
form ~v<major>.<minor>.<patch>~:

- *Major* release (from ~v0.8.1~ to ~v1.0.0~) for bug fixes and new features that
  break backwards compatibility,
- *Minor* release (from ~v0.8.1~ to ~v0.9.0~) for bug fixes and new features that
  maintain backwards compatibility, and
- *Patch* release (from ~v0.8.1~ to ~v0.8.2~) only for bug fixes.

# https://stackoverflow.com/questions/21639437/git-flow-release-branches-and-tags-with-or-without-v-prefix

#+begin_note
It's common practice to prefix your version names with the letter ~v~.
#+end_note

Tag and push changes to the repository:

#+begin_src conf
    # Usage: git release VERSION
    # Release a new version of your project.
    release = "!f() { \
        git tag -a v$1 -m \"Release version $1\" \
            && git push $(git origin) --tags \
            && git push $(git origin); \
    }; f"
#+end_src

#+begin_src conf
    # Usage: git manifest
    # Print a list of version controlled files for the current revision.
    manifest = ls-files
#+end_src

* Pipelines

Testing.

#+begin_src conf
    # Check if any file in repo has whitespace errors
    # As described in http://peter.eisentraut.org/blog/2014/11/04/checking-whitespace-with-git/
    check-whitespace = diff-tree --check $(git hash-object -t tree /dev/null) HEAD
    whitespace-violations = "!git diff --check $(git hash-object -t tree /dev/null)"

    # Check if any file in repo has windows line endings
    # Currently do not work as alias, works from comand line directly. There is a problem with \r
    check-eol = grep --files-with-matches $'\\r' HEAD
#+end_src

* Deployments (to different environments)

#+begin_src conf
rsync-deploy =
#+end_src

(see structure of actions in BitBucket)

See https://bitbucket.org/blog/wordpress-continuous-deployment

#+begin_src conf
# Deploy a branch to review server (https://review-feature-1.example.com).
deploy-review =

# Deploy master to staging server (https://staging.example.com).
deploy-staging =

# Deploy master to production server (https://example.com).
deploy-prod =

  # # Deploy
  # staging = !git push heroku-staging $(git current-branch):master -f && git track 'Deployed to staging ' # push current branch to staging, can add more comments after
  # dev = !git push heroku-dev $(git current-branch):master -f && git track 'Deployed to dev ' # push current branch to dev
  # deploy = !git push heroku $(git current-branch):master -f && git track 'Deployed to production ' # push current branch to production

# shipit = push heroku master

 # deploy='git push production master && terminal-notifier-notify -title "Deploy" -message "Deploy complete"'
 # stage='git push staging $(git current-branch):master'
#+end_src

* Issues

Status (and status values that are allowed on a ticket).

- Open
  + New
  + Accepted
  + Test

- Closed
  + Invalid
  + Closed

** Create Issue

Open an issue in the current repository:
- Enter a summary
- Write an optional description

#+begin_src conf
# title
# description
# assignee
# kind
# priority
    create-issue = XXX
#+end_src

Issue template:

#+begin_src text :tangle .issue_template.txt
### Expected behavior
### Actual behavior
### Steps to reproduce the behavior
#+end_src

See https://github.com/devspace/awesome-github-templates
and https://jwong.co.uk/blog/2018/09/01/useful-github-features/#emoji-organising

** Create Pull Requests

#+begin_src conf
    create-issue-pull-request = XXX
#+end_src

Title of pull request:

: WIP: Resolve "Title of issue"

Once merged:

: Resolve "Title of issue"

** List All Issues

See https://blog.bennycornelissen.nl/post/github-from-your-terminal/

#+begin_src conf
    # issues = "!f() { USER_NAME=$1; \
    #     curl --user $USER_NAME \
    #         https://api.bitbucket.org/2.0/repositories/$(git repo-owner)/$(git repo-slug)/issues \
    #         | jq -C --compact-output '.values | .[] | [.id, .title, .type, .priority, .state, .votes, .assignee.display_name, .created_on, .updated_on]' \
    #         | sed -r 's/(....)-(..)-(..)T(..):(..):(..).(............)/\\1-\\2-\\3/g' \
    #         | sed \"s/new/NEW/\" \
    #         | sed \"s/NEW/$(tput setaf 2) -- NOUVEAU -- $(tput sgr0)/\" \
    #         | sed \"s/NEW/\$(tput setaf 3) -NOUV- \$(tput sgr0)/\" \
    #         | sed \"s/open/OPEN/\" \
    #         | sed \"s/closed/CLOSED/\"; }; f"
# --data-urlencode 'priority >= \"major\"'
#+end_src

#+begin_src conf :tangle no
    issues = "!f() { \
        USER_NAME=$1; \
        curl --user $USER_NAME 'https://api.bitbucket.org/2.0/repositories/$(git repo-owner)/$(git repo-slug)/issues?pagelen=100' \
            | jq --compact-output '.values | .[] | [.id, .title, .type, .priority, .state, .votes, .assignee.display_name, .created_on, .updated_on]' \
            | sed \"s#\"open\"#$(tput setaf 2)&$(tput sgr0)#\" \
            | sed \"s#\"closed\"#$(tput setaf 1)&$(tput sgr0)#\"; \
    }; f"
#+end_src

Set color to red or green, depending on issue state.

: # Works!  Need to put quotes around the URL!
: curl -u $USER_NAME -X GET 'https://api.bitbucket.org/2.0/repositories/$(git repo-owner)/$(git repo-slug)/issues?pagelen=100' \
:     | jq --compact-output '.values | .[] | [.id, .title, .type, .priority, .state, .votes, .assignee.display_name, .created_on, .updated_on]'
: # curl -s -S

See also [[https://cran.r-project.org/web/packages/jsonlite/vignettes/json-apis.html][Fetching JSON data from Github REST API]].

** List Open Issues

#+begin_src conf
    issues-open = !git issues | grep "open"
#+end_src

** List My Issues (assigned to me)

#+begin_src conf
    issues-assigned-to-me = !git issues | grep "$(git config --get user.name)"
#+end_src

** List Issues I've created

#+begin_src conf :tangle no
    issues-created-by-me = "!f() { \
        REPO_OWNER=\"YourUsername\"; \
        REPO_SLUG=\"YourRepository\"; \
        API_URL=\"https://api.github.com/repos/$REPO_OWNER/$REPO_SLUG/issues?creator=$REPO_OWNER\"; \
        curl -s \"$API_URL\" | jq -r '.[] | \"#\( .number ) - \( .title )\"'; \
    }; f"
#+end_src

** Show Issue

Show an existing issue specified by NUMBER.

#+begin_src conf
    # Usage: git show-issue ISSUE_NUMBER
    show-issue = "!f() { \
        REPO_OWNER=\"YourUsername\"; \
        REPO_SLUG=\"YourRepository\"; \
        ISSUE_NUMBER=\"$1\"; \
        URL=\"https://github.com/$REPO_OWNER/$REPO_SLUG/issues/$ISSUE_NUMBER\"; \
        open \"$URL\"; \
    }; f"
#+end_src

** Open Issues in a web browser

#+begin_src conf
    browse-issues = "!f() { \
        URL=$(git config --get remote.$(git origin).url); \
        xdg-open ${URL/.git}/issues/$1; \
    }; f"
#+end_src

#+begin_src conf
    # List JIRA issue keys from commit messages.
    issue-keys = "!f() { \
        echo 'Printing JIRA issue keys'; \
        git log \"$@\" \
            | egrep -o '[A-Z]+-[0-9]+' \
            | sort -u; \
    }; f"
#+end_src

* Wiki

#+begin_src conf
    browse-wiki = "!f() { \
        URL=$(git config --get remote.$(git origin).url); \
        xdg-open ${URL/.git}/wiki; \
    }; f"
#+end_src

* Downloads

Download repository, tag or branch.

#+begin_src conf
    # Put everything in the current repo in a Zip archive.
    download-repository = "!f() { \
        git archive ${1:-HEAD} --format=zip -o $(basename $(git root))-commit-$(git rev-parse ${1:-HEAD}).zip; \
    }; f"
# XXX Test it with tag or branch.
#+end_src

* Repository settings

** SSH keys

List the user's public SSH keys:

: # For GitHub.
: curl -O https://github.com/fniessen.keys

: # For BitBucket.
: curl https://api.bitbucket.org/2.0/users/fniessen/ssh-keys | jq '.values'

* ------------------------------------------------------------------------------

* Run on All repositories

The alias ~all-repos~ proves especially useful in ensuring that all my work is
committed.

There are instances when I work on a project, only to set it aside temporarily
without committing the changes. To ensure that I haven't overlooked any
uncommitted work, I rely on ~git all-repos status --short~ to rapidly assess
repositories that contain pending changes.

#+begin_src conf
    # Print repository name, execute command, and separate output.
    print-repo-info = "!f() { \
        printf '\\033[1m'; \
        basename $(git rev-parse --show-toplevel); \
        printf '\\033[0m'; \
        git "$@"; \
        printf '\\n'; \
        printf '\\n'; \
    }; f"

    # Run commands for each repository in the current directory.
    all-repos = "!f() { \
        ls -R -d */.git \
            | sed s#/.git## \
            | xargs -I{} git -C {} print-repo-info "$@"; \
    }; f"
#+end_src

See also ~git-repos~:
http://osiux.com/2015-01-14-sincronizar-repositorios-git-repos.html

** SHOW - find all "unpushed" commits for all projects in a directory

: git all-repos outgoing

See https://stackoverflow.com/questions/12499195/git-how-to-find-all-unpushed-commits-for-all-projects-in-a-directory

** git-pull-all-repos and git-push-all-repos

#+begin_src conf
    # Usage: git pull-all-repos
    # Pull the changes in all Git repositories of the current directory.
    pull-all-repos = !$HOME/bin/git-pull-all-repos
#+end_src

#+begin_src conf
    # Usage: git push-all-repos
    # Push the changes in all Git repositories of the current directory.
    push-all-repos = !$HOME/bin/git-push-all-repos
#+end_src

* Sort out

Define:

#+begin_src conf
    # Execute shell command and show output.
    exec = '!exec '
#+end_src

so that you can do things like ~git exec make~.  This works because Shell aliases
are always executed in the top-level directory.

Clean up your commits before publishing.  Before you push your commits to the
repository, it's good to revise them.  You can run the git interactive rebase to
squash your commits or modify commit messages.  The goal is to publish only
clean and relevant commits, no experiments or fixing typos.

#+begin_src conf
    # Interactive rebase with the given number of latest commits
    ireb = "!f() { \
        git rebase -i HEAD~$1; \
    }; f"
#+end_src

#+begin_src conf
    # Start an interactive rebase of all the commits you haven't pushed
    # yet. Handy for collapsing a bunch of work-in-progress snapshots into
    # logical commits before pushing, without having to worry about accidentally
    # squashing a commit someone else has already referred to.
    work-in-progress = rebase -i @{u}
#+end_src

** SHOW - Check the status of your files

Give the status in the *short format* (preceded by a line showing the /branch name/
and /tracking info/).

#+begin_src conf
    # Usage: git st
    # Display the current status of the repository with branch names.
    st = status -s -b
#+end_src

In the following example:

#+begin_example
M  README
 M lisp/mail/rmail.el
MM ChangeLog
#+end_example

- =README= is changed and *staged for commit* (it's *in the index*),
- =lisp/mail/rmail.el= is changed but *not staged for commit*, and
- =Changelog= is changed and staged for commit, then *changed again* and the new
  change is *not staged for commit*.

#+begin_note
Staging for commit is typically done by ~git add~.
#+end_note

** SHOW - View your changes

#+begin_src conf
    # Usage: git diff-latest [FILE]
    # Show differences between the latest commit and the current working state.
    # Examples:
    #     git diff-latest           # Show differences for all files
    #     git diff-latest file.txt  # Show differences only for "file.txt"
    diff-latest = !"git diff-index --quiet HEAD -- || clear; \
            git --no-pager diff --patch-with-stat"

    # Usage: git diff-commits NUMBER
    # Show differences between the state `$number' commits ago and the current working state.
    # Example: git diff-commits 2
    diff-commits = "!f() { git diff --patch-with-stat HEAD~$1; }; \
            git diff-index --quiet HEAD -- || clear; \
            f"
#+end_src

*** Changes between the working tree and the index (staged for the next commit)

#+begin_src conf
    # Ignore whitespace when comparing the same lines. This indicates empty
    # lines added or deleted.
    diff-ignore-whitespace = diff -w
#+end_src

#+begin_src conf
    # Diff line-wise.
    df = diff

    # Diff word-wise.
    dw = diff --color-words
#+end_src

#+begin_src conf
    # Configure git-diff to produce the absolutely most minimal diff possible.
    dw-min = diff -w --word-diff-regex=. --color-words -U0

    # Show minimal differences in changes between working directory and the most recent commit, ignoring whitespace.
    wdiff = diff --diff-algorithm=minimal -w
#+end_src

*** Changes between the working tree and the latest commit (HEAD)

#+begin_src conf :tangle no
    diff-all = diff HEAD
#+end_src

*** Changes between the index (staged for the next commit) and the latest commit (HEAD)

Just before committing the *staged* changes (about to be committed), check what
your commit changes (to make sure you don't need to use the undo commands):

#+begin_src conf
    # Diff staged line-wise.
    df-staged = diff --cached

    # Diff staged word-wise.
    dw-staged = diff --color-words --cached

    # Show minimal differences in changes between staged changes and the most recent commit, ignoring whitespace.
    swdiff = diff --diff-algorithm=minimal -w --cached
#+end_src

*** When was this file first committed

#+begin_src conf
    # Usage: git first-modified-date FILENAME
    # Show the date of the first modification of a file.
    first-modified-date = "!f() { \
        date=$(git log --all --follow --pretty=format:%ci -- $1 | tail -n 1); \
        echo \"$date\"; \
    }; f"
#+end_src

XXX The above alias does not work on renamed files...

#+begin_src conf :tangle no
    first-modified-date-FIX = "!f() { \
        git log --follow --format=%ai -- $1 | tail -1; \
    }; f"
    #+end_src

*** When was this file last updated

Before using this, please *update all local branches*, checking out each branch in
succession.

See script =git-update-all= at [[https://stackoverflow.com/questions/4318161/can-git-pull-all-update-all-my-local-branches][Can "git pull --all" update all my local branches?]].

#+begin_src conf
    # When was this file last updated, on each local branch.
    wwflu = "!f() { \
        for BRANCH_NAME in $(git rev-parse --symbolic --branches); do \
            echo -e \"$(git log --decorate=no -1 \
                                --format=\"%at:%C(green)%ad%C(reset) %C(yellow)%h%C(auto)%d%C(reset) %s %C(bold blue)<%an>%C(reset)\" \
                                --color=always $BRANCH_NAME -- \"$1\")  On branch $(tput bold)$BRANCH_NAME$(tput sgr0)\"; \
        done \
            | sort -r; \
    }; f"
#+end_src

:               | cut -f2 -d:; \

*** Add only modified changes (and ignore untracked files)

Ideally your =.gitignore= should prevent the untracked (and ignored) files from
being shown in status, added using ~git add~ etc.  So correct your =.gitignore=.

To *stage* the modified and deleted files *for commit*, use the ~git add -u~ command:

#+begin_src conf
    stage-modified-removed-files = add -u
#+end_src

The ~-u~ flag tells Git to update the index with the modifications and deletions,
effectively staging the changes.

Then, *commit* the changes.

** SHOW - View the commit history

#+begin_note
The ~git log~ command shows, by default, the "author date" -- not the "committer
date".
#+end_note

#+begin_src conf
    # Usage: git ls
    # Print a summary of activity.  Alias of log.
    ls = log
#+end_src

XXX Check out http://marcgg.com/blog/2015/08/04/git-first-parent-log/

List commits *showing changed files* (prettier and more concise version of
~whatchanged~):

#+begin_src conf
    ll = log --pretty=medium --abbrev-commit --stat
#+end_src

#+begin_src conf
    # Usage: git last
    # Return the last commit on the current branch.
    last = log -1 --stat

    # Usage: git lastn [N]
    # Show the last N commits on the current branch.
    lastn = "!f() { \
        git show --name-only $(git rev-list -${1:-1} HEAD); \
    }; f"

    # lastn2 = "!f() { \
    #     git log -${1:-1} --stat $(git rev-list -${1:-1} HEAD); \
    # }; f"
#+end_src

TODO: More information with lastn2 (for file renames), but missing newline after
merge commits...

*** Show the commit history of a file

*List of commits* that modified the *specified file*:

#+begin_src conf
    # Usage: git file-history FILENAME
    # Show the commit history of a specific file.
    file-history = log --
#+end_src

That also will *print the /right/ merge commits*, *like in BitBucket*.

: curl -u USER_NAME 'https://api.bitbucket.org/2.0/repositories/REPO_OWNER/REPO_SLUG/filehistory/master/PATH/TO/FILE'

This one will *follow renames and copies*:

#+begin_src conf
    # Usage: git file-history-follow-copy-without-merge-commits FILENAME
    # Show commit history with file copies and renames.
    file-history-follow-copy-without-merge-commits = log --follow --date-order -C
    # ... BUT WITHOUT MERGE COMMITS
#+end_src

... but it *DOES NOT print merge commits*!

And adding ~-m~ to show merge commits doesn't quite work -- it will show many,
many, many /wrong/ (all?) merge commits.

#+begin_note
Merge commits in particular are very hard cases for ~git log --follow~, because
they have two parents and one parent might have renamed the file. The rename
detection and following code inside ~git log~ is a quick hack...
#+end_note

#+begin_src conf
    # Usage: git file-history-follow-copy FILENAME
    # Show commit history of a file, including copies, renames, and merges.
    file-history-follow-copy = log --follow --date-order -C --find-renames --merges
#+end_src

Add ~--all~ to show commits of /all your branches/, not just from the current
branch:

#+begin_src conf
    # Usage: git file-history-all FILENAME
    # Show commit history for all branches.
    file-history-all = log --all
#+end_src

Find the *most recent commit* (chronologically) that modified a file -- looking in
/all/ known commits:

#+begin_src conf
    # Usage: git file-last-modified FILENAME
    # Show the most recent commit across all branches in date order.
    file-last-modified = log -n 1 --all --date-order
#+end_src

List commits affecting a specific path and then get all the files modified in
each commit:

#+begin_src conf
    # Usage: git related FILENAME
    # Show all commits that modified a specific file, including the commit
    # message and file list.
    related = "!f() { \
        git show --name-only $(git rev-list HEAD -- $1); \
    }; f"
#+end_src

(see https://stackoverflow.com/questions/42527378/git-get-the-list-of-files-that-have-been-modified-along-one-specific-file)

#+begin_src conf
    # Usage: git related-files FILENAME
    # Generate a list of which files changed together with a file.
    related-files = !sh -c 'git log --format=format:%H $0 \
                | xargs -L 1 git diff-tree --no-commit-id --name-only -r \
                | sort \
                | uniq -c \
                | sort -b -n -r \
                | less'
#+end_src

*** Inspect the commits for each edit

: git log ... | xargs -n 1 git show

** SHOW - Show blame information about original authors of lines changed or removed

$ git blame -w  # ignores white space
$ git blame -M  # ignores moving text
$ git blame -C  # ignores moving text into other files

git blame -w README.md
The -w option ignores whitespace changes. If a previous author has modified the
spacing of a file by switching from tabs to spaces or adding new lines this,
unfortunately, obscures the output of git blame by showing these changes.

git blame -M README.md
The -M option detects moved or copied lines within in the same file. This will
report the original author of the lines instead of the last author that moved or
copied the lines.

git blame -C README.md
The -C option detects lines that were moved or copied from other files. This
will report the original author of the lines instead of the last author that
moved or copied the lines.

: git blame -L 1509,1511 lisp/ox-html.el

#+begin_src conf
    praise = blame -w
    archeology = blame -w -C -n
#+end_src

** Merge

#+begin_src conf
    # Given a merge commit, find the span of commits that exist(ed).
    # Not so useful in itself, but used by other aliases.
    # Thanks to Rob Miller for the merge-span-* aliaes.
    merge-span = "!f() { \
        echo $(git log -1 --merges --pretty=format:%P $2 | cut -d' ' -f1)$1$(git log -1 --merges --pretty=format:%P $2 | cut -d' ' -f2); \
    }; f"

    # Find the commits that were introduced by a merge
    merge-span-log = "!f() { \
        git log $(git merge-span .. $1); \
    }; f"

    # Show the changes that were introduced by a merge
    merge-span-diff = "!f() { \
        git diff $(git merge-span ... $1); \
    }; f"

    # Show the changes that were introduced by a merge, in your difftool
    merge-span-difftool = "!f() { \
        git difftool $(git merge-span ... $1); \
    }; f"
#+end_src

** UPDATE - Pull

#+begin_src conf
    # Show a list of existing remotes (with URL).
    r = remote -v
#+end_src

#+begin_note
~git pull~ is simply ~git fetch && git merge remote~.  Its ~--rebase~ option uses
~rebase~ instead of ~merge~.

That's exactly why some decide to avoid ~rebase~ (but to ~pull~ instead), because it
has bad effects if one merges from another branch and then wants to push.
#+end_note

About rebase (with visual aid):
https://itnext.io/become-a-git-pro-in-just-one-blog-a-thorough-guide-to-git-architecture-and-command-line-interface-93fbe9bdb395

*** Show incoming changes

The ~incoming~ command returns a list of *incoming* commits for the *current
branch* -- after a ~git fetch~, to fetch down *all the data* it has for the *current
remote* that you do not --, the next time you do a merge.

What was going on, while you were away?

#+begin_src conf
    # Usage: git incoming
    # Show new commits found in the remote repository.
    incoming = !(git remote update -p \
                && git log ..@{u})
    # TODO: git fetch, instead?
    # TODO: Add optional argument BRANCH_NAME, and delete alias incoming-on-branch

    # Alias of 'incoming'.
    in = !git incoming
#+end_src

#+begin_src conf
    # Show log of new commits after you fetched, with stats, excluding merges
    log-fresh = log --no-merges --stat ORIG_HEAD..
#+end_src

#+begin_tip
Starting with Git 1.7.0, ~@{u}~ is shorthand for the *current* branch's *upstream*
branch; e.g., ~origin/foo~ (or ~github/foo~, etc., since the remote doesn't have to
be called ~origin~) if the checked out branch is ~foo~.
#+end_tip

#+begin_src conf
    # Usage: git incoming-on-branch BRANCH_NAME
    # Show new commits found in the remote repository.
    # Example: git incoming-on-branch master
    incoming-on-branch = !sh -c 'git fetch' \
                && git log ..$(git origin)/$1
#+end_src

#+begin_src conf
    # Usage: git who-is-changing-branch BRANCH_NAME
    who-is-changing-branch = !sh -c 'git shortlog HEAD..$(git origin)/$0'
    # TODO: Add fetch?
#+end_src

Show a *single diffstat* (number of added and deleted lines for *all changed
files*):

#+begin_src conf
    incoming-files = !(git remote update -p \
                && git diff --stat ...@{u})

    # Alias of 'incoming-files'.
    in-files = !git incoming-files
#+end_src

#+begin_warning
The upstream diff ~in-what~ will show the negative of unpushed (rebased) commits,
if any, with the ~..~ notation --- not with the ~...~ notation!
#+end_warning

Show the changes between the last local commit and the *remote* branch:

#+begin_src conf
    incoming-diff = diff @{u} HEAD
    # diff with upstream branch
#+end_src

*** Pull

Before doing work (in a new branch), *ensure that the working tree is* *up-to-date*
with the ~origin~ (pull and get latest for all submodules):

#+begin_src conf
    # Get everything new.
    update = !git pull                     && git submodule update --init --recursive
    get    = !git pull --rebase            && git submodule update --init --recursive
    update = !git pull --rebase --prune $@ && git submodule update --init --recursive

    # Pull in remote changes for the current repository and all its submodules
    p = !"git pull; git submodule foreach git pull $(git origin) master"
#+end_src

[[https://gist.github.com/gitaarik/8735255][Git Submodules basic explanation]]

*** Get timestamp of last pull

#+begin_src conf
    # Retrieve the timestamp of the most recent pull operation, regardless of changes being present.
    latest-pull-time = "!f() { \
        local fetch_head_time=$(stat -c %y $(git root)/.git/FETCH_HEAD | cut -d'.' -f1); \
        printf \"Latest pull time: %s\\n\" \"$fetch_head_time\"; \
    }; f"
    # For the latest pull (even if there's nothing new).

    # Retrieve the timestamp of the last update to your current branch from the remote master branch, considering changes received.
    latest-update-time = "!f() { \
        local current_branch=$(git current-branch); \
        local update_time=$(stat -c %y $(git root)/.git/refs/heads/$current_branch | cut -d'.' -f1); \
        printf \"Latest update time for branch '%s': %s\\n\" \"$current_branch\" \"$update_time\"; \
    }; f"
    # For the latest pull resulting in changes coming in from the remote master
    # branch (the timestamp won't change when git pull reports there are no
    # changes).
#+end_src

*** Pull and push

#+begin_src conf
    # Pull the latest changes for the current branch from its remote counterpart.
    pull-current = "!git pull $(git origin) $(git current-branch)"

    # Push the current branch to its remote counterpart.
    push-current = "!git push $(git origin) $(git current-branch)"

    # Pull and push the latest changes for the current branch.
    pull-and-push--current = "!f() { \
        pull-current && push-current; \
    }; f"
#+end_src

#+begin_src conf
    # Update repository by pulling changes from remote and pushing local commits.
    pull-and-push = !git pull && git push
#+end_src

** UPDATE - Merge

Merging means to *bring the contents of another branch* (possibly from an external
repository) *into the current branch*. [...]  Merging is performed by an automatic
process that identifies changes made since the branches diverged, and then
applies all those changes together.

: Merge branch 'BRANCH_NAME' into master

#+begin_src conf
    # Avoid a fast-forward commit.
    mnf = merge --no-ff --log
#+end_src

*** Merge current branch into another one

Merge strategy:
- Merge commit: git merge --no-ff
- Squash:       git merge --squash
- Fast forward: git merge --ff-only

#+begin_src conf
    merge-into-master =  "!f() { \
            OLD_BRANCH=\"$(git symbolic-ref HEAD 2>/dev/null)\" || OLD_BRANCH=\"(unnamed branch)\"; \
            OLD_BRANCH=${OLD_BRANCH##refs/heads/}; \
            git checkout master \
                && git merge $OLD_BRANCH \
                && git checkout $OLD_BRANCH; \
        };f"
#+end_src

On projects where we work with a staging or test branch, I regularly merge my
work in progress into it so others can test it.

#+begin_src conf
    m = "!f() { \
        local OLD_BRANCH=$(git current-branch); \
        git checkout \"$1\" \
            && git pull \
            && git merge $OLD_BRANCH \
            && git push \
            && git checkout $OLD_BRANCH; \
    }; f"
#+end_src

If you now type ~git m staging~ while on the ~feature~ branch, this will happen:

1. First, the function checks out the ~staging~ branch.
2. It then pulls the latest changes to the ~staging~ branch from origin.
3. Then it merges ~feature~ into ~staging~.
4. Next, it pushes the updated ~staging~ branch back to origin.
5. Finally, it checks out the ~feature~ branch again.

Such a timesaver!

*** Undo the merge

If you tried a merge which resulted in complex conflicts and want to start over,
you can recover with ~git merge --abort~.  It will allow you to *undo the merge*,
even if it is a fast-forward merge.

*** Dry run (do not make changes)

Naive (but slow) way:

: rm -Rf /tmp/repository
: cp -r repository /tmp/
: cd /tmp/repository
: git merge ...
: # ... If successful, do the real merge.

#+begin_warning
It won't work just cloning to =/tmp=; you need a *copy* in order *to be sure that
uncommitted changes will not conflict*.
#+end_warning

Performing a Git merge with *no commit* and *no fast-forward* will merge the two
code bases together -- it will *modify your working copy*.  This will allow you to
examine, test, and undo the merge if required.

: git merge --no-commit --no-ff BRANCH_NAME

You can do ~git merge --abort~ after seeing that there are conflicts.

#+begin_src conf
    # Run merge test (before merge) to check for any conflicts beforehand.
    merge-test = "!f() { \
        git merge --no-commit --no-ff \"$1\"; \
        git merge --abort; \
        echo \"Merge aborted\"; \
    }; f"
#+end_src

#+begin_warning
If your repository is a live Web server, then you could be serving files with
conflicts in.  That's why you should *never* be *handling merges on a live Web
server*!  Fix up the ~master~ branch (on your development box) and then push it to
the real webserver with ~git pull --ff-only~.
#+end_warning

See if the merge is applicable to the current working tree and/or the index file
and *detects conflicts*:

#+begin_src conf
    # Usage: git merge-dry-run BRANCH_NAME
    # Check how the merge of BRANCH_NAME into master will go
    merge-dry-run = "!f() { \
        grep -q 'changed in both' <<< $(git merge-tree $(git merge-base FETCH_HEAD $1) FETCH_HEAD $1) \
            && echo 'Merge conflicts!' \
            || echo 'This branch can be automatically merged.'; \
    }; f"
# XXX DOESN'T work for git fetch & git merge

    # Extract the "changed in both" lines as well as the conflicting parts.
    merge-dry-run-conflicts = "!f() { \
        git merge-tree $(git merge-base $1 $2) $1 $2 \
            | sed -n '/+<<<<<<< .our/,/+>>>>>>> .their/p;/^changed in both/{n;N;N;s/^/#/mg;p}' \
            | cdiff; \
    }; f"
#+end_src

*** Branch/Integration manager

Often, during a *merge*, you know you want to take a file from one side wholesale;
that is, to select the entirety of either our or their file.

Pick a file(s) from:

- the *current branch*

#+begin_src conf
    ours = "!f() { \
        git checkout --ours $@ \
            && git add $@; \
    }; f"
#+end_src

- the *branch being merged in*

#+begin_src conf
    theirs = "!f() { \
        git checkout --theirs $@ \
            && git add $@; \
    }; f"
#+end_src

#+begin_warning
During a *rebase*, the commits being merged into the current branch /are/ the
commits from your original feature branch.  So ~--ours~ and ~--theirs~ will appear
to be *flipped* around.
#+end_warning

#+begin_note
Using ~git checkout~ with ~--ours~ or ~--theirs~ expects at least one argument: the
*path(s)* of the *files / directories* to checkout.  If you use ~git checkout~ without
any files, then it takes the meaning of /switching branches/.
#+end_note

*Best (and safest) way to merge* a Git local branch into =master=:

: git checkout master
: git pull $(git origin) master           # Get the latest changes from the remote.
: git merge test
: git push $(git origin) master
:
: git delete-local-branch BRANCH_NAME     # Delete local branch.

#+begin_warning
*Update first the branch (to merge in) of the RIGHT LOCAL CLONE.* -- if you do
have many clones on your file system.
#+end_warning

Best answer I have seen on ~git merge~ *strategies*:
https://stackoverflow.com/questions/366860/when-would-you-use-the-different-git-merge-strategies

*** Show list of files in a conflict state

List unmerged files (after a merge failure), having leftover conflict markers:

#+begin_src conf
    # Usage: git conflicts
    # List files with conflicts.
    conflicts = diff --name-only --diff-filter=U
#+end_src

See also ~git diff --check~.

Quickly solve conflicts using an editor.

#+begin_src conf
    edit-unmerged = "!$EDITOR $(git conflicts)"
#+end_src

Then, add the conflicted files.

#+begin_src conf
    add-unmerged = "!git add $(git conflicts)"
#+end_src

** BRANCH - Branch

*** Feature Branches

#+begin_src conf
    # Create a feature branch.
    feature = "!f() { \
        git create-branch feature/$1 develop; \
    }; f"
    # XXX or feature-start?

    # Incorporate a finished feature on develop.
    feature-finish = "!f() { \
        git checkout develop; \
        git merge --no-ff feature/$1 \
            && git delete-local-branch feature/$1; \
    }; f"

    # XXX Also bug and refactor.

    # XXX release-start
    # XXX release-finish
#+end_src

https://medium.com/gumgum-tech/git-and-git-flow-a-guide-871d46a0ebcb

Alias configuration for our feature branches, like a simple Git flow for feature
stories, or hotfix patches, etc.

Create a new feature branch:

: feature-start = '!OLD_BRANCH=$1; git checkout master; git pull; git create-branch "$OLD_BRANCH" master'

Update the feature branch:

: feature-pull = '!OLD_BRANCH=$(git current-branch); git checkout master; git pull; git checkout "$OLD_BRANCH"; git rebase master'

Share the feature branch:

: feature-push = '!OLD_BRANCH=$(git current-branch); git push -u $(git origin) "$OLD_BRANCH"'

If your team uses a different feature flow, you may want to skip including these
aliases, or you may want to edit these aliases to match your team's feature flow.

*** Git workflows

It may be helpful to do a some background reading on workflows with Git.  Here
is the gitworkflows man page:
https://www.kernel.org/pub/software/scm/git/docs/gitworkflows.html

Other doc on branching models:

http://www.draconianoverlord.com/2013/09/07/no-cherry-picking.html
http://williamdurand.fr/2012/01/17/my-git-branching-model/

*** General

See http://nuclearsquid.com/writings/git-tricks-tips-workflows/ for more
interesting stuff, such as:

- When branching off a remote branch, automatically let the local branch track
  the remote branch.

- When pushing without giving a refspec, push the current branch to its upstream
  branch. See the git config man page for more possible options.

#+begin_src conf
    # Shortcut for checkout.
    co = checkout
#+end_src

Check out the next commit in the commit history -- quite useful for demos to
jump across commits:

#+begin_src conf
    next = "!f() { \
        git checkout $(git rev-list --topo-order HEAD..master | tail -1); \
    }; f"
#+end_src

*** If you get the error "The following untracked working tree files would be overwritten by checkout"

#+begin_src text :tangle no
error: Your local changes to the following files would be overwritten by checkout:
        WEB-INF/config/afm-projects.xml.DEV-fni
        WEB-INF/config/context/logging/logging.xml
Please commit your changes or stash them before you switch branches.
error: The following untracked working tree files would be overwritten by checkout:
        WEB-INF/config/afm-projects.xml
Please move or remove them before you switch branches.
#+end_src

One solution is to *move the untracked files*, instead of *deleting them*.  For
example:

: cd "$(git root)"
: git checkout BRANCH_NAME 2>&1 \
:     | while read F; do \
:           [ ! -e "$F" ] || mv -v "$F" "$F.bak"; \
:       done

Another is to throw away local changes using a *forced checkout*:

: git checkout -f BRANCH_NAME

*** Website and page hosting

You can easily host websites directly in your repository hosting service.  And
open HTML files directly from the file browser.

For GitHub pages:

#+begin_src shell :tangle no
echo 'setting up gh-pages'
echo '-------------------'

echo 'Tell me your github account username: '
read USER_NAME

echo 'Now, tell me your repository name: '
read REPOSITORY

git stash \
    && git create-branch 'gh-pages' \
    && echo 'My Page' > index.html \
    && git add . \
    && git commit -a -m 'Initial commit' \
    && git remote add $(git origin) https://github.com/"$USER_NAME"/"$REPOSITORY".git \
    && git push -u $(git origin) gh-pages \
    && echo 'Complete' \
    && echo '-------------------' \
    && echo 'You can find your last changes in the stash!'
#+end_src

For BitBucket:
https://marketplace.atlassian.com/apps/1212525/pages-for-bitbucket-server?hosting=server&tab=overview

*** Recover a branch after its deletion in Git

Most of the time unreachable commits are in the reflog. So, the *first thing to
try is to look at the reflog* using the command ~git reflog~ (which display the
reflog for =HEAD=).

1. Perhaps something easier if the commit was part of a specific branch still
   existing is to use the command ~git reflog name-of-my-branch~ to *find the SHA-1*
   for the commit at the tip of your deleted branch -- It works also with
   a remote, for example if you forced push.  Otherwise, use ~git reflog~.

2. Then, you can just ~git create-branch BRANCH SHA_1~ to recreate the branch from
   there.

See https://stackoverflow.com/questions/3640764/can-i-recover-a-branch-after-its-deletion-in-git

*** Show branches and their commits

#+begin_src conf
    # "show-branch -g=N" can't be aliased for N easily, so we stop here:
    sb  = show-branch
    # pg sbt master pu -- if the last line is 'master' and not 'master~'
    # or 'master~N' then pu is a descendent of master
    sbt = show-branch --topics
    sbs = show-branch --sha1-name
#+end_src

** PUBLISH - Push

*** Show outgoing changes: commits that are on the local branch that have not been pushed

It is useful to know if you have any *local commits* that are not in the remote
branch.

#+begin_note
It is a good idea to examine what you are about to push, before actually doing
so, because fixing mistakes before pushing is much easier. To do that, use the
command "git diff origin/master". If you want to show your unpushed commits with
their commit log messages, use "git show origin/master.." instead. If you only
have one local commit you want to push, just "git show" is enough.

> It is not clear to me how these two differ.  Does "git show origin/master.."
> output everything that "git diff origin/master" outputs, plus log messages?

Yes, that's the only real difference between them, when you have no uncommitted
changes.  (When you do have uncommitted changes, "git diff" will include them,
while "git show" will not.)
#+end_note

The ~outgoing~ command returns a list of *unpushed* (outgoing) commits for the
*current branch*, the next time you do a push.

#+begin_src conf
    # Usage: git outgoing
    # Show (unpushed) commits not found in the remote branch.
    outgoing = log @{u}..

    # Alias of 'outgoing'.
    out = !git outgoing
#+end_src

TODO: Fix missing newline at the end...
Hence, wrong count of lines (with shell alias "W")...

#+begin_src conf
    outgoing-files = diff --stat @{u}...

    # Alias of 'outgoing-files'.
    out-files = !git outgoing-files
#+end_src

This causes ~git log~ to show all commits reachable from =HEAD= excluding those
reachable from the upstream branch.  The ~@{u}..~ argument is equivalent to
~@{u}..HEAD~, where =HEAD= stands for the last commit in your local branch, but =HEAD=
can be omitted for shorthand purposes.

If you want to see all *unpushed* commits from *all branches*, do this:

#+begin_src conf
    # Usage: git outgoing-all
    # Show commits not found in the destination repository.
    outgoing-all = log --branches --not --remotes

    # Alias of 'outgoing-all'.
    out-all = !git outgoing-all
#+end_src

*** Show the history difference between a local branch and its remote

= git in + git out

#+begin_src conf
    # Usage: git divergence BRANCH_NAME
    divergence = "!f() { \
        git log --cherry-pick --left-right --graph $1...$(git origin)/$1; \
    }; f"
#+end_src

** PUBLISH - Find out if a change is part of a release

#+begin_src conf
    # Usage: git sha1-tag COMMIT
    sha1-tag = "!f() { \
        git name-rev --name-only \"$@\"; \
    }; f"
#+end_src

The ~name-rev~ command indicates the *position of a commit relative to tags* in the
project.  For example, ~v2.3~5~ means that this commit is located 5 commits *before*
the ~v2.3~ tag -- we can be certain that this change is part of v2.3, then.

** Create patches

#+begin_src conf
    lll = log -u
#+end_src

*** Creating a patch

1. Make your changes and commit them.

2. Run

   : git format-patch COMMIT_ISH

   to convert all commits since the referenced commit (not including it) into
   patch files.

   For example:

   : git format-patch HEAD~

*** Git apply

> Indeed.  I cannot apply the patch, git am returns "patch format
> detection failed."  Can you resubmit it using git format-patch?

You want to use 'git apply' on that patch, 'git am' is for applying
patches produced by 'git format-patch' only.  In a pinch however, you
can relatively easily convert the patch format from 'git show to
something suitable for 'git am':

Replace "commit" with "From", Replace "Author" with "From" and replace
the whitespace at the beginning of the first line of the commit message
with "Subject: [PATCH] ".

*** Applying the patch

: git am *.patch

Error while applying a patch

: git am--ignore-whitespace 0001-my-awesome-change.patch

When ~git apply~ is working normally, you get no output at all:

: git apply 0001-my-awesome-change.patch

[nothing returned]

If you want to see what's going on behind the scenes, you can use the ~-v~
(verbose) flag:

: git apply -v 0001-my-awesome-change.patch

Use ~patch -p1 < filename.patch~. Whereas ~git-apply~ altogether rejects a patch
with any errors, ~patch -p1~ works hunk by hunk, applying as many individual
changes as it can. It backs up each file as =filename.ext.orig= before modifying
it and saves rejected hunks in =filename.ext.rej=. Discard the =.orig= files and
manually apply the changes left in the =.rej=. This is an easy strategy for small
patches.

*Applying Patches* with different line endings error on Cygwin:

: patch -t -N -r - -p1 -i 0001-my-awesome-change.patch

*** Apply patches from URL

#+begin_src conf
    # Apply a patch to files and/or to the index from URL.
    apply-url = "!f() { \
        curl -s $1 2>nul \
            | git apply ${@:2}; \
    }; f"
#+end_src

: git apply-url http://example.org/sample.patch args

#+begin_src conf
    # Apply a series of patches from an URL.
    am-url = "!f() { \
        curl -s $1 2>nul \
            | git am ${@:2}; \
    }; f"
#+end_src

: git am-url http://example.org/sample.patch args

*** Apply a patch interactively

#+begin_src conf
    # Interactive apply patch.
    ipatch = "!f() { \
        git apply $1; \
        git add -p; \
    }; f"
#+end_src

: git ipatch mypatchfile

*** Shell patch aliases

#+begin_src shell :tangle no
# Copy a patch URL to the clipboard, then run one of these commands to download
# the patch and apply it. Hat tip to @chrisjlee for making me reconsider curl.

# Apply
alias cap='curl $(pbpaste) | git apply -v'

# Apply and stage
alias cape='curl $(pbpaste) | git apply -v --index'

# Apply with `patch'
alias capp='curl $(pbpaste) | patch -p1'

# Reverse apply
alias carp='curl $(pbpaste) | git apply -Rv'

# Reverse apply and stage
alias carpe='curl $(pbpaste) | git apply -Rv --index'

# Verify patch
alias cav='curl $(pbpaste) | git apply -v --check'

# Verify patch with `patch'
alias capv='curl $(pbpaste) | patch -p1 --dry-run'
#+end_src

** PUBLISH - Prepare a release

See https://github.com/aiidateam/aiida-core/wiki/How-to-make-a-new-release

*** ChangeLog

Generate the ChangeLog (for your [[https://keepachangelog.com/][CHANGELOG.md]]) with all commit messages since
the last tag.

A properly formed Git commit subject line should always be able to complete the
following sentence:

: If applied, this commit will YOUR_SUBJECT_LINE_HERE

How to write a good commit message + A changelog generation:
https://dev.to/gaelthomas/a-beginner-s-guide-to-git-how-to-write-a-good-commit-message-2j49
https://dev.to/chrissiemhrk/git-commit-message-5e21
https://dev.to/helderburato/patterns-for-writing-better-git-commit-messages-4ba0

#+begin_src conf
    # Usage: git changelog [FIRST_TAG_NAME] [LAST_TAG_NAME] XXX
    # Detailed list of changes.
    changelog1 = "!f() { \
        git log --no-merges ${1-$(git last-tag)}..$2; \
    }; f"
    changelog = !sh -c 'git log --no-merges --pretty=format:\"* %s\" $(git last-tag)...' -
    changelog-org = !sh -c 'git log --no-merges --pretty=format:\"- %s\" $(git last-tag)...' -
#+end_src

Savoir quels sont les commits de ma branche courante depuis le dernier tag, afin
de savoir ce qu'embarquera la  prochaine release  de mon projet.

#+begin_src conf
    # le dernier tag, ainsi que la liste des commits ayant eu lieu depuis sur la
    # branche courante.
    unreleased = !git log $(git last-tag)...HEAD \
                && git last-tag
#+end_src

XXX git log --pretty=format:"- %s" 2019.10.10...HEAD displays too many entries on mcpflow repo

See also
- https://github.com/github-changelog-generator/github-changelog-generator
- https://github.com/github-changelog-generator/github-changelog-generator/wiki/Alternatives

**** Today

Quickly see what you've done today (list commits that aren't merges, on *all
branches*):

#+begin_src conf
    # Usage: git today [AUTHOR]
    today = "!f() { \
        git log \
            --since=midnight \
            --author=\"${1-$(git config --get user.name)}\" \
            --no-merges \
            --all \
            --pretty='%C(green)%ad%C(auto) - %s%C(auto)%d' \
            --date=format:'%Y-%m-%d %a %H:%M'; \
    }; f"

    # Usage: git yesterday [AUTHOR]
    yesterday = "!f() { \
        git log \
            --since='1 day ago midnight' --until=midnight \
            --author=\"${1-$(git config --get user.name)}\" \
            --no-merges \
            --all \
            --pretty='%C(green)%ad%C(auto) - %s%C(auto)%d' \
            --date=format:'%Y-%m-%d %a %H:%M'; \
    }; f"

    # Usage: git this-week [AUTHOR]
    this-week = "!f() { \
        git log \
            --since='1 week ago' \
            --author=\"${1-$(git config --get user.name)}\" \
            --no-merges \
            --all \
            --pretty='%C(green)%ad%C(auto) - %s%C(auto)%d' \
            --date=format:'%Y-%m-%d %a %H:%M'; \
    }; f"
#+end_src

Show changes for a daily standup meeting:

#+begin_src conf
    # Usage: git standup [AUTHOR]
    # Summarize changes since 24h, suitable for a daily standup meeting.
    standup = "!f() { \
        git log \
                --branches \
                --since=$(if [ \"$(date +%a)\" = \"Mon\" ]; then \
                              echo \"friday\"; \
                          else \
                              echo \"yesterday\"; \
                          fi) \
                --author=\"${1-$(git config --get user.name)}\" \
                --format=format:'%C(green)%ad%C(reset) - %s%C(auto)%d' \
                --date=format:'%Y-%m-%d %a %H:%M'; \
    }; f"
#+end_src

TODO: git standup W donne un dcompte avec une ligne trop peu !

*** Release assets

Generate =zip= archived source code from the given Git tag.

I use this when zipping the current branch with the name of the zip file as the
current tag.  Useful for uploading to Elasticbeanstalk.

#+begin_src conf
    current-tag = tag --points-at HEAD
    zip = "!f() { \
        git archive --format=zip -o $(git current-tag).zip HEAD; \
    }; f"
#+end_src

#+begin_src conf
    export-branch = "!f() { \
        git format-patch --stdout $1 > ~/$(git current-branch-without-slash).diff; \
    }; f"
#+end_src

Example for a branch:

: git missing-files main > file-list.txt
: cat file-list.txt | xargs zip -9 DATE_what-it-does.zip

Save a repo (for example, ~HEAD~ or ~master~ -- or any other branch to archive, if
you've already checked it out) as a tarball:

#+begin_src conf
    export-zip = archive -o latest.zip
    export-tgz = archive -o latest.tar.gz -9
#+end_src

Note that the /output format/ is inferred by the extension of the output file.

**** Export a commit

#+begin_src conf
    # Usage: git export-commit [COMMIT_ISH]
    # Create an archive of a commit.
    export-commit = "!f() { \
        git changed-files ${1:-HEAD} \
            | tr '\\n' '\\0' \
            | xargs -0 zip -9 $(git repo-slug)-commit-$(git current-branch-without-slash)-${1:-$(git commit-hash)}.zip; \
    }; f"
#+end_src

XXX This does not handle spaces in file names

To see the contents of the zipped file (without extraction), use ~unzip -l FILE~.

**** Generate patch emails

#+begin_src conf
    # View raw commit.
    email-patch = XXX git format-patch $(git current-branch-without-slash).patch

    # Since oldest ancestor...
    plain-diff = !git branch-diff > $(git current-branch-without-slash).diff
#+end_src

Patch = this

: From 69936b7cc23c9ae78cec84baa30c599c1ad5990a Mon Sep 17 00:00:00 2001
: From: Brett Viren <brett.viren@gmail.com>
: Date: Fri, 2 Oct 2020 10:30:17 -0400
: Subject: [PATCH] Move doc to index.org and generate index.html, README.org
:  holds short links.
:
: This is meant to demo serving the refcard via GH pages.  The
: README.org probably deserves more attention!
:
: Content modified:
:
: - Switched to online SETUPFILE.  Maybe better to carry a copy of readtheorg?
:
: - I had problems related to id:<hash> and so switch a reference to use
:   the headline text.
:
: - Pointed UP and HOME to links related to the refcard.
: ---
:  README.html | 4118 ---------------------------------------------------
:  README.org  | 1673 +--------------------
:  index.html  | 3308 +++++++++++++++++++++++++++++++++++++++++
:  index.org   | 1672 +++++++++++++++++++++
:  4 files changed, 4984 insertions(+), 5787 deletions(-)
:  delete mode 100755 README.html
:  mode change 100755 => 100644 README.org
:  create mode 100644 index.html
:  create mode 100755 index.org

+ diff.

#+begin_src conf
    patch-for-this = "!git diff -p $(git hash-object -t tree /dev/null)"
#+end_src

** PUBLISH - Tag

When tagging releases in a version control system, the tag for a version should
be ~X.Y.Z~ (*without* prefix ~v~).  The advantages of ~X.Y.Z~ are that gitweb or GitHub
can automatically offer a tarball or zip download of the form
=packagename-$tag.tar.gz= (and it's quite established that a tarball should be
named =package-X.Y.Z.tar.gz=).

** Debugging

Sometimes it's nice to see what is going on under the hood. Try this alias:

#+begin_src conf
    # Enable comprehensive debugging output.
    debug = "!set -x; GIT_TRACE=2 GIT_CURL_VERBOSE=2 GIT_TRACE_PERFORMANCE=2 GIT_TRACE_PACK_ACCESS=2 GIT_TRACE_PACKET=2 GIT_TRACE_PACKFILE=2 GIT_TRACE_SETUP=2 GIT_TRACE_SHALLOW=2 git"
#+end_src

Just insert ~debug~ between ~git~ and whatever would usually follow; for example:

: git debug changed

** Abbreviations

Basic shortcuts.

#+begin_src conf
    cp = cherry-pick -x
    pick = cherry-pick -s

    # cherry-pick - apply the changes introduced by some existing commits; useful for moving small chunks of code between branches.
    cp = cherry-pick

    # cherry-pick without making a commit, and when when recording the commit, append a line that says "(cherry picked from commit ...)"
    cp-nx = cherry-pick --no-commit -x
#+end_src

This command has some useful parameters:
- ~-e~ to edit git message
- ~-x~ to add a line "Cherry-picked commit" in the commit message
- ~--no-commit~ or ~-n~ to apply the commit changes in the unstaged area (unstead of
  creating a commit in the branch)

#+begin_src conf
    h = help
#+end_src

** Show the path to root directory of Git repo

#+begin_src conf :tangle no
    # Get the path cleaned up.
    root = !pwd -P
#+end_src

#+begin_note
This works because Shell aliases are always executed in the top-level directory.
#+end_note

#+begin_src conf
    root = rev-parse --show-toplevel
    root-relative = rev-parse --show-prefix
#+end_src

** Sync

Fetch Git objects from upstream and update local branches.

- If the local branch is outdated, fast-forward it;
- If the local branch contains unpushed work, warn about it;
- If the branch seems merged and its upstream branch was deleted, delete it.

** Cherry-pick style recording

Ask interactively which patch hunk to commit, and then do the commit:

#+begin_src conf
    # Usage: git commit-interactive FILENAME...
    # Interactively stage changes and commit, or abort.
    commit-interactive = !sh -c '(git add -p -- $@ && git commit) || git reset' --

    # Alias of 'commit-interactive'.
    record = !git commit-interactive
#+end_src

It will not only do ~git add -p~ (with an optional file list), but it will also
immediately do the ~commit~. Upon abandonment of either the ~add~ or the ~commit~, it
will ~reset~ the index.

** Dangling

- Dangling blob = Change(s) that made it to the staging area/index but never got
  committed. One thing that is amazing with Git is that once it gets added to
  the staging area, you can always get it back because these blobs behave like
  commits!!

- Dangling commit = A commit that isn't linked to any branch or tag either
  directly or by any of its ancestors. You can get these back too!

#+begin_src conf
    lost = "!git fsck \
                | awk '/dangling commit/ {print $3}' \
                | git show --format='SHA-1: %C(yellow)%h%C(reset)  %s' --stdin \
                | awk '/SHA-1/ {sub(\"SHA-1: \", \"\"); print}'"
#+end_src

Resurrection of lost commits:

#+begin_src conf
    # Show a graph of the commit history, including dangling commits (not reachable by any reference).
    dangling-graph-log = !git log --all --pretty=oneline --abbrev-commit --graph \
                    $(git fsck --no-reflogs | grep commit | cut -d\\  -f3)
#+end_src

* If you get errors...

Many situations may cause "errors":

- merge conflicts (two people editing the same part of the same file)

- unmerged changes (another person committed a change before you did, so you
  need to merge their changes first)

- attempting to recover from a situation such as an accidental merge, and making
  the situation worse.

https://explainxkcd.com/wiki/index.php/1597:_Git

** Method 1

It is POSSIBLE that a safe way to recover from your problems is as follows:

: git stash
: git reset --hard HEAD
: git pull --ff-only
: git stash apply

Of course, if any of the commands but the last fails, stop and ask for advice
again. If the last one reports merge conflicts, fix them by hand and run ~git add~
on each file after you fixed it. DO NOT use C-x v v after fixing a merge
conflict, since that runs both git add and git commit, and you are not ready for
the latter until all merge conflicts are dealt with.

In any case, do run git status before finally doing git commit. If all succeeds,
you can clean up with:

: git stash drop

** Alternative

If your =master= branch is busted, rename it to something else so that it's out of
the way:

: git rename-local-branch master master-busted

Create a new branch =master= that tracks the origin:

: git branch --track master $(git origin)/master

Check it out (be careful, this will discard all your local changes):

: git checkout -f master

Make sure the =master= is up-to-date:

: git pull

** A GitHub test repository to experiment with conflicts

You can experiment with resolving a Git conflict with this repository:
https://github.com/brianleetest/testGit/blob/master/README.md

** GitHub tasks

# https://github.com/abo-abo/oremacs/blob/github/etc/org/wiki/git.org

** Doc about push failure

If a push fails, that does not necessarily indicate a "bad state" -- it simply
represents that your history is different than what the remote server has, and
that the tip of the branch you are pushing to cannot simply be "fast-forwarded"
to your commit.

After a failed push, you are in no different state than you were before the push
(aside from a possibly puzzled mental state).

In your case, since you just want to commit and push in one operation, you
likely want to run ~git pull --rebase~, which would get those changes and then
automatically re-commit your work on top of them, as if you had those changes
all along.  You could then push.  So, something like:

#+begin_src shell :tangle no
# Commit all changes and attempt to push, pulling in changes if necessary and
# re-pushing; on failure, restore to previous state with changes uncomitted.
git commit -am Foo \
    && {
        git push \
            || {
                { git pull --rebase || handle-pull-conflicts; } \
                      && git push;
            }
    } \
    || {
        git reset --soft HEAD^
        echo 'Commit failed.'
    }
#+end_src

But what if rebasing fails?  Then you are left resolving a conflict before you
can attempt the push operation again.  I do not know how you would want to
handle this.  ~handle-pull-conflicts~ might simply perform a ~git rebase --abort~
and exit with a non-zero status, or it may open a UI/shell to help resolve
changes.  If you are pushing after every change, this amounts to correcting
a single commit, so it might be worth having VC maintain the state here, allow
you to correct your commit, and then the vc-next-action would be to run ~git
rebase --continue~ after adding the files that conflicted.

This will be how the majority of Git users will resolve rejected pushes.

Does that make sense?

  [Aside: ~git pull~ without ~--rebase~ performs a ~git fetch && git merge
  whatever-branch-you-are-tracking~, which has the unfortunate side-effect of
  creating a merge commit if histories are different; this muddies up history.
  ~git pull --rebase~ performs ~git fetch && git rebase
  whatever-branch-you-are-tracking~.  The difference in the two styles of
  conflicts here is that, with rebasing, since you are re-committing each and
  every changeset, you may get multiple conflicts on any number of commits,
  whereas a merge will give you a single conflict that must be resolved at once.
  The benefit of rebasing is that it gives you a clean history and does not
  produce an unnecessary merge conflict which you would then push to origin,
  akin to leaving a bag of poop on origin's doorstep.]

For other users, it may represent a wholly different problem.  For example, if
I were to push to GNU ease.js' repo and get that message, that would be
a problem, since that means that someone has committed to my repository without
my permission.  An automatic pull and re-push would be bad in this case, since
that makes it look like I'm okay with that.

A failed push could also mean that you are tracking the wrong branch, or pushing
to the wrong repository.  Git allows you to set a "tracking branch", which can
be anything---a local branch, a remote branch, or a branch in an entirely
different repository, local or remote.  Further, you can override the tracking
branch by specifying which remote to push to as part of the ~push~ command.

In your case, you'd always want to respect the tracking branch and assume that
there are no problems pushing, since you use only one remote, and the tracking
branch is always a branch of the same name on origin.

A failed push could also mean that someone rudely rewrote history on the remote
branch (using ~git push --force~) and someone needs a talkin' to.

* References

- https://github.com/tj/git-extras
- https://hub.github.com/hub.1.html
- http://stackoverflow.com/questions/2423777/is-it-possible-to-create-a-remote-repo-on-github-from-the-cli-without-ssh

- [[https://girliemac.com/blog/2017/12/26/git-purr/][Git Commands Explained with Cats!]]
- [[https://git.wiki.kernel.org/index.php/Aliases][Git SCM Wiki - Aliases]]
- [[https://ochronus.com/git-tips-from-the-trenches/][Git tips from the trenches]]
# - [[file:~/Public/Repositories/emacs/admin/notes/git-workflow][Emacs Git workflow]]

* Git clients

- [[https://jonas.github.io/tig/][Tig]]
- [[https://www.gitkraken.com/][GitKraken]]

* Local configuration

#+begin_src conf
[include]
    path = .gitconfig_local
#+end_src

* Contributing

** Issues

Report issues and suggest features and improvements on the [[https://github.com/fniessen/git-leuven/issues/new][GitHub issue tracker]].

** Patches

I love contributions!  Patches under any form are always welcome!

** Donations

If you use the git-leuven project (or any of [[https://github.com/fniessen/][my other projects]]) and feel it is
making your life better and easier, you can show your appreciation and help
support future development by making today a [[https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=VCVAS6KPDQ4JC&lc=BE&item_number=git%2dleuven&currency_code=EUR&bn=PP%2dDonationsBF%3abtn_donate_LG%2egif%3aNonHosted][donation]] through PayPal.  Thank
you!

Regardless of the donations, git-leuven will always be free both as in beer and
as in speech.

** Follow me

I have an [[https://twitter.com/f_niessen][f_niessen]] account on Twitter.  You should follow it.

* License

Copyright (C) 2013-2022 Fabrice Niessen

Author: Fabrice Niessen \\
Keywords: git aliases

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see http://www.gnu.org/licenses/.

#+html: <a href="http://opensource.org/licenses/GPL-3.0">
#+html:   <img src="http://img.shields.io/:license-gpl-blue.svg" alt=":license-gpl-blue.svg" />
#+html: </a>
#+html: <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=VCVAS6KPDQ4JC&lc=BE&item_number=git%2dleuven&currency_code=EUR&bn=PP%2dDonationsBF%3abtn_donate_LG%2egif%3aNonHosted">
#+html:   <img src="https://www.paypalobjects.com/en_US/i/btn/btn_donate_LG.gif" alt="btn_donate_LG.gif" />
#+html: </a>
