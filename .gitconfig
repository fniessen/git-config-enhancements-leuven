# .gitconfig, Time-stamp: 20220107.1234

[user]
    # Tell Git about yourself.  Override this in the file .gitconfig_local.
    name = John Doe
    email = john.doe@example.com

[github]
    user = jdoe

[fetch]
    prune = true

[merge]
    conflictstyle = diff3

[merge]
    tool = meld

[mergetool "meld"]
    cmd = meld --diff "$LOCAL" "$MERGED" "$REMOTE" --diff "$BASE" "$LOCAL" --diff "$BASE" "$REMOTE" --output "$MERGED"
    # cmd = meld --diff "$LOCAL" "$BASE" "$REMOTE" --diff "$BASE" "$LOCAL" --diff "$BASE" "$REMOTE" --output "$MERGED"
    keepBackup = false

[diff]
    tool = meld

[difftool]
    prompt = false

[difftool "meld"]
    cmd = meld "$LOCAL" "$REMOTE"

[core]
    # editor = notepad++.exe -multiInst -notabbar -nosession -noPlugin
    editor = emacsclient

    # git-grep to ignore ^M.
    pager = tr -d '\\r' | less -REX

    # whitespace = fix,-indent-with-non-tab,trailing-space,space-before-tab,cr-at-eol
    whitespace = cr-at-eol

    pager = diff-so-fancy | LESS= less --tabs=4 -FRX

[core]

    # Do filesystem operations in parallel to hide latency (default since v2.1).
    preloadindex = true

    # Enable file system caching.  Also, fix UAC issues so you don't need to run
    # Git as administrator (default since v2.8).
    fscache = true

[gc]
    # Minimize the number of files in .git/.
    auto = 256

[help]
    autocorrect = 1

[log]
    date = short

    decorate = short

[diff]
    renames = copies
    renameLimit = 30000

    algorithm = patience

    mnemonicprefix = true

    noprefix = true

    colorMoved = dimmed_zebra

[apply]
    # Don't detect whitespace errors when applying a patch.
    whitespace = nowarn

[status]
    submoduleSummary = true

[push]
    default = simple

[merge]
    stat = true
    summary = true

    # Include summaries of merged commits in newly created merge commit messages.
    log = true

[rebase]
    stat = true

[grep]
    lineNumber = true

    # # Allow extended regular expressions
    # extendedRegexp = true

    fullName = true

[color]
    ui = auto
    branch = auto
    diff = auto
    status = auto
    interactive = auto

[color "branch"]
    current = cyan bold
    local = green bold
    remote = red bold
    upstream = red bold
    plain = yellow reverse

[color "diff"]
    plain = "#888888"
    meta = 11
    frag = magenta bold
    func = "#cc99cc"
    old = red bold
    new = green bold
    commit = yellow bold
    whitespace = red reverse

[diff-so-fancy]
    useUnicodeRuler = true

[color "diff-highlight"]
    oldNormal = red bold
    oldHighlight = red bold 52
    newNormal = green bold
    newHighlight = green bold 22

[color "status"]
    header = normal
    added = green bold
    changed = yellow bold
    untracked = cyan
    branch = cyan bold
    nobranch = bold ul blink 12
    unmerged = red reverse bold

[color "grep"]
    context = "#888888"
    filename = yellow bold
    function = red
    linenumber = magenta bold
    match = green reverse bold
    matchContext = yellow reverse bold
    matchSelected = yellow bold blue
    separator = red bold
    selected = white

[format]
    pretty = format:%C(green)%ad%C(reset) %C(yellow)%h%C(auto)%d%C(reset) %s %C(bold blue)<%an>%C(reset)

# https://dev.to/megamattmiller/the-git-aliases-that-get-me-to-friday-1cmj
[custom.formats]
    ls = "[%C(auto,yellow)%<|(10)%h%C(reset)] [%C(auto,bold blue)%<(15trunc)%cn%C(reset)]  %C(auto)%d% C(reset)%s"
    find = "[%C(yellow)%<|(20)%h%C(reset)] [%C(bold blue)%<(10)%cn%C(reset)]  %C(auto)%d %C(reset)  %s"
    graph = "%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset) %C(yellow)%d%C(reset)%n %C(white)%s%C(reset)%n %C(dim white)- %an <%ae> %C(reset) %C(dim white)(committer: %cn <%ce>)%C(reset)"

[alias]

    # Usage: git alias
    # Print the list of Git aliases.
    alias = "!git config -l \
                | grep alias \
                | cut -c 7- \
                | sort \
                | sed 's/=/ = /'"

    work-profile = config user.email \"john@work.com\"

    # Usage: git init-repository
    # Create a repository.
    init-repository = !git init \
                && ( [ -n "$(ls)" ] || touch .gitignore ) \
                && git add . \
                && git commit -m \"Initial commit\"

    cl = clone --recursive

    # origin = !echo "${$(git config --get clone.defaultRemoteName):-origin}"
    origin = !echo "origin"

    repo-owner = "!f() { \
            git remote show $(git origin) -n \
                | grep 'Fetch URL:' \
                | sed -E 's#^.*[/:](.*)/.*$#\\1#' \
                | sed 's#.git$##'; \
        }; f"

    repo-slug = "!f() { \
            git remote show $(git origin) -n \
                | grep 'Fetch URL:' \
                | sed -E 's#^.*/(.*)$#\\1#' \
                | sed 's#.git$##'; \
        }; f"

    # Usage: git serve
    # Fire up a builtin local webserver (for browsing and sharing repository over HTTP).
    serve = "daemon --verbose --export-all --base-path=.git --reuseaddr --strict-paths .git/"
    serve = "-c daemon.receivepack=true daemon --base-path=. --export-all --reuseaddr --verbose"

    # Usage: git search-for-files PATTERN
    # List files matching the pattern.
    search-for-files = !git ls-tree -r --name-only HEAD | grep -i --color=auto

    # Alias of 'search-for-files'.
    find-files = !git search-for-files

    search-for-files-all = "!f() { \
            for BRANCH in $(git for-each-ref --format=\"%(refname)\" refs/heads); do \
                printf \"\n$(tput bold)$BRANCH:$(tput sgr0)\n\"; \
                git ls-tree -r --name-only $BRANCH | nl -bn -w3 | grep --color=auto \"$1\"; \
            done; \
        }; f"

    # Alias of 'search-for-files-all'.
    find-files-all = !git search-for-files-all

    search-for-code = "grep -i --line-number --break --heading -C 1"

# ack = '-c color.grep.linenumber="bold yellow"
#     -c color.grep.filename="bold green"
#     -c color.grep.match="reverse yellow"
#     grep --break --heading --line-number'

    search-for-code-in-extension = "XXX"

    search-for-code-in-path = "XXX"

    # In all commits, not in all branches!!! Lots of duplicates!!!
    grep-all = "!f() { \
            git rev-list --all \
                | xargs git grep $1; \
        }; f"

    # `-I' = Don't match the pattern in binary files.
    g = "grep -I"

    # Name only.
    gno = "grep -I --files-with-matches"

    # Usage: git unmodify TREE_ISH...
    # Undo local changes in the working copy at or within TREE_ISH.
    unmodify = checkout --
    undelete = checkout --

    # Usage: git unstage [FILE...]
    # Undo a 'git add' before the next commit.
    unstage = reset HEAD --
    unadd = reset HEAD --

    added = "!git status --porcelain -uno | awk 'match($1, /A/) {print $2}'"

    modified = !git diff --name-only --diff-filter=M

    ignored = ls-files --others --ignored --exclude-standard

    # List all untracked files.
    untracked = ls-files --others --exclude-standard

    # List all tracked files.
    tracked = ls-files -t

    # Usage: git deleted
    # List files deleted in the working tree.
    deleted = ls-files -d

    # List staged added, modified or deleted files.
    staged = "!git status --porcelain -uno | grep -P '^[ADM]' | awk '{ print $2 }'"

    is-tracked1 = "!f() { \
            TRACKED=$(git ls-files $1); \
            if [ -z \"$TRACKED\" ]; then \
                echo 'File NOT tracked (or No such file)'; \
            else \
                echo 'File tracked'; \
            fi; \
        }; f"
    is-tracked2 = "!f() { \
            echo -n $1': '; \
            if [ -f \"$1\" ]; then \
                TRACKED=$(git ls-files $1); \
                if [ -z \"$TRACKED\" ]; then \
                    echo 'File NOT tracked'; \
                else \
                    echo 'File tracked'; \
                fi; \
            else \
                echo 'No such file!'; \
            fi; \
        }; f"
# does not work!?

    ignore = "!f() { \
            echo \"$1\" >> \"${GIT_PREFIX}.gitignore\"; \
        }; f"
    # ignore=!([ ! -e .gitignore ] && touch .gitignore) | echo $1 >>.gitignore
# XXX What is GIT_PREFIX?

    # Ignore all untracked files by appending them to .gitignore:
    ignore-untracked = "!git status \
                | grep -P \"^\\t\" \
                | grep -vF .gitignore \
                | sed \"s/^\\t//\" \
                >> \"${GIT_PREFIX}.gitignore\""

    # Fix .gitignore.
    fix-gitignore = !git rm -r --cached . \
                && git add . \
                && git commit -m \"Fix .gitignore\"

    # Ignore files only locally.
    skip = update-index --assume-unchanged
    unskip = update-index --no-assume-unchanged

    skip-all = "!git status -s \
                | awk {'print $2'} \
                | xargs git skip"

    unskip-all = "!git skipped \
                | xargs git update-index --no-assume-unchanged"

    skipped = "!git ls-files -v \
                | grep '^h' \
                | cut -c 3-"
    skipped2-BAD-MAYBE = !git ls-files -v \
                | grep '^[a-z]'

    # Usage: git clean-tree-unknown
    # Delete (only) untracked files and directories.
    clean-tree-unknown = clean -d -f
    # THIS COMMAND MAY DELETE FILES THAT CANNOT BE RECOVERED.
    # Files and directories in .gitignore will be preserved.

    # Alias to git clean-tree-unknown.
    purge = !git clean-tree-unknown

    # Usage: git clean-tree-unknown-dry-run
    # Show files to delete instead of deleting them.
    clean-tree-unknown-dry-run = clean -d -n

    # Alias to clean-tree-unknown-dry-run.
    purge-dry-run = !git clean-tree-unknown-dry-run

    # Usage: git clean-tree-unknown-ignored
    # Delete untracked files (and directories), and also ignored files.
    clean-tree-unknown-ignored = clean -d -f -x
    # THIS COMMAND MAY DELETE FILES THAT CANNOT BE RECOVERED,
    # including those in .gitignore.

    # Alias to clean-tree-unknown-ignored.
    purge-all = !git clean-tree-unknown-ignored

    # Usage: git clean-tree-unknown-ignored-dry-run
    # Show files to delete instead of deleting them.
    clean-tree-unknown-ignored-dry-run = clean -d -n -x

    # Alias to clean-tree-unknown-ignored-dry-run.
    purge-all-dry-run = !git clean-tree-unknown-ignored-dry-run

    stash-push = stash push

    # Pop stash off with name like text.
    stash-pop = "!f() { \
            git stash pop stash@{$(git stash-id $@)}; \
        }; f"

    # Only accepts single word, no quotations.
    stash-id = "!f() { \
            git stash list \
                | grep $@ \
                | head -n 1 \
                | sed -n 's/stash@{\\(.*\\)}.*/\\1/p'; \
        }; f"

    # "Add" modified files, deleted files, and new untracked files.
    stash-all = !git add -A \
                && git stash

    # Hide all files, including untracked files (faster than using --all).
    hide = stash push --include-untracked

    snapshot = !git stash push -m "snapshot-$(date +%Y%m%d_%H%M)" \
                && git stash apply "stash@{0}"

    # checkpoint
    checkpoint = !git stash push -m "$(date +%F--%T)" \
                && git stash pop --index

    # checkpoint recover
    checkpoint-recover = "!f() { \
            git fsck \
                | grep commit \
                | cut -d' ' -f3 \
                | while read HASH; do \
                      git rev-parse --verify --no-revs --quiet $HASH^2 2>/dev/null \
                          && echo $HASH \
                          | xargs git rev-list --since=${1:-1day} -1; \
                  done \
                | xargs -L 1 git log --format=%at:%h -1 \
                | sort \
                | cut -f2 -d: \
                | xargs -L 1 git log --graph --format='%Cblue%h %Cgreen(%ar) %Creset%s' -3; \
        }; f"

    stashes = stash list --date=short

    # Usage: git unstash-preview
    # Instead of unshelving the changes, show the diff that would result from
    # unshelving.
    unstash-preview = stash show -p

    # Show only stash with name like text.
    stash-show = "!f() { \
            git stash show stash^{/$@} -p; \
        }; f"

    stash-show = "!f() { \
            git stash show stash^{/$*} -p; \
        }; f"

    stash-shno = stash show --name-only

    # Usage: git unstash-keep [STASH_ID]
    # Apply changes but don't delete them.
    unstash-keep = stash apply

    # Find stash with name like text.
    stash-apply = "!f() { \
            git stash apply stash^{/$@}; \
        }; f"

    stash-apply = "!f() { \
            git stash apply stash^{/$*}; \
        }; f"

    stash-unapply = !git stash show -p --no-textconv --binary \
                | git apply -R

    # Usage: git unstash [STASH_ID]
    # Apply changes and remove them from the shelf.
    unstash = stash pop

    # Usage: git unstash-delete-only [STASH_ID]
    # Delete changes without applying them.
    unstash-delete-only = stash drop

    # Shortcut for commit.
    ci = commit

[commit]
    template = ~/.git_commit_template.txt

[alias]

    # Usage: git commit-hash [COMMIT_ISH]
    # Examples:
    #   git commit-hash               find hash of last commit
    #   git commit-hash develop       find hash of last commit in develop
    commit-hash = log -1 --pretty=format:'%h'

    # Usage: git changed-files [COMMIT]
    # Examples:
    #   git changed-files             list files modified in last commit
    #   git changed-files bada55      list files modified in this commit
    changed-files = show --pretty="format:" --name-only -m

    download-email-patch = XXX git format-patch $(git current-branch).patch
    download-plain-diff = "!f() { \
            git diff ${1:-HEAD}~ ${1:-HEAD} > ${1:-HEAD}.diff; \
        }; f"

    showtool = "!f() { \
            REV=$(git rev-parse \"${*:-HEAD}\"); \
            git difftool $REV~1 $REV; \
        }; f"

    diff-file-last-commit = "!f() { \
            PROJECT_ROOT_DIR=$(git root); \
            echo finding full file path of $1 in $PROJECT_ROOT_DIR; \
            FILEPATH=$(find $PROJECT_ROOT_DIR -type f -name $1); \
            echo full file path $FILEPATH; \
            LAST_MODIFIED_COMMIT_HASH=$(git rev-list -1 HEAD $FILEPATH); \
            echo last commit file modified $LAST_MODIFIED_COMMIT_HASH; \
            git difftool $LAST_MODIFIED_COMMIT_HASH^ $FILEPATH; \
        }; f"

    diffall = difftool -t meld --dir-diff

    # Usage: git where REV
    # Print only refs which contain the commit.
    where = for-each-ref --format='%(refname)' --contains
    where2 = for-each-ref --format="%(refname:short)" --points-at HEAD refs/heads
    where3 = "!f() { \
            git for-each-ref --format='%(committerdate:iso) %09 %(authorname) %09 %(refname:short)' --contains $1 \
                | sort -r; \
        }; f"

    # Find branches containing commit.
    branches-that-contain = branch -a --contains

    # Find tags containing commit.
    tags-that-contain = "!f() { \
            git tag -l --contains $1 \
                | sort -r; \
        }; f"

    # Usage: git is-ancestor COMMIT_1 COMMIT_2
    # Check if one commit is an ancestor of another.
    is-ancestor = !$HOME/bin/git-is-ancestor

    findc1 = "log -i --all --grep"
    findc2 = "!f() { \
            git log --grep=$1 -i --all; \
        }; f"

    # Search for commits (Filter by commit message).
    search-for-commits = "!f() { \
            STR=\"git log --all-match\"; \
            for VAR in \"$@\"; do \
                STR=\"$STR --grep '$VAR'\"; \
            done; \
            eval $STR; \
        }; f"

    search = "!f() { \
            for l in \"$@\"; do \
                git log --grep \"$l\"; \
            done; \
        }; f"
# XXX Add i, all, date short...

    search2 = "!f() { \
            git log --grep \"$1\" $(git rev-list --all); \
        }; f"

    # Usage: git search-for-author [PATTERN]
    # Show the log for an author (or my own user email).
    search-for-author = "!f() { \
            git log -i --no-merges --all --author=${1-$(git config --get user.email)}; \
        }; f"

    whatwhen = log -p -S

    # Find commits by source code.
    search-for-commits-contents = "!f() { \
            git log -S $1; \
        }; f"
# XXX Does not work for strings with spaces in them...

    grep4d = !sh -c 'git log -p -S'$1' $2' -
# Not the best example, but: git grep4d CLOSED '*.java'

    browse-commits = "!f() { \
            URL=$(git config --get remote.$(git origin).url); \
            xdg-open ${URL/.git}/commits; \
        }; f"

    # Append your staged changes to the latest commit (keeping the pre-existing
    # commit message).
    recommit = commit -v --amend --reuse-message HEAD

    # Usage: git reword MSG
    # Change latest commit message to what you type in.
    reword = commit --amend -m

    # Usage: git credit AUTHOR_NAME AUTHOR_EMAIL
    # Credit an author on the latest commit.
    credit = "!f() { \
            git commit --amend --author=\"$1 <$2>\" --reuse-message HEAD; \
        }; f"

    # Edit history.
    recommit2 = "!f() { TARGET=$(git rev-parse \"$1\"); \
                     git commit --fixup=$TARGET ${@:2} \
                         && GIT_EDITOR=true git rebase --interactive --autostash --autosquash $TARGET~; }; f"
    # See https://blog.filippo.io/git-fixup-amending-an-older-commit/

    # Checkout the commit in question, and amend its message.
    reword2 = "!f() { OLD_BRANCH=$(git current-branch); \
                      git checkout $1; \
                      git commit --amend; \
                      git checkout $OLD_BRANCH; }; f"

    # Usage: git uncommit
    # Remove the last commit.
    uncommit = reset --soft HEAD~1

    uncommit-unstage = reset --mixed HEAD~1

    # Erase any changes since your last commit (reset every file in your working
    # directory to its committed state).
    # Destroy the changes from the commit you want to undo.
    undo = reset --hard HEAD~1
    # Delete last commit.

    # Usage: git squash N
    # Bundle the last N commits into a single commit.
    squash = "!f() { \
            git reset --soft HEAD~$1 \
                && git commit --edit -m\"$(git log --format=%B --reverse HEAD..HEAD@{1})\"; \
        }; f"

    create-branch = checkout -b

    # Usage: git current-branch
    # Show the current branch name (v2.22+).
    current-branch = branch --show-current

    # Usage: git current-branch-without-slash
    # Show the current branch name (without slash).
    current-branch-without-slash = "!f() { \
            git current-branch \
                | tr '/' '-'; \
        }; f"

    # Usage: git publish
    # Push current branch to remote server.
    publish = !git push -u $(git origin) $(git current-branch)
    # (Create a copy of the current branch on the remote "origin", and set it to
    # track the upstream branch)

    # List local and remote branches.
    branches = branch -a -vv

    # Show info for branches which have been checked out locally...
    # (Sorted by date; can be useful for spring cleaning)
    br = for-each-ref \
                --sort=-committerdate refs/heads/ \
                --format='%(color:green)%(committerdate:short)%(color:reset) %(HEAD) %(color:green bold)%(refname:short)%(color:reset) %(color:red bold)%(upstream:track)%(color:reset) %(color:yellow)%(objectname:short)%(color:reset) %(contents:subject) %(color:bold blue)<%(authorname)>%(color:reset)'

    # What branches you have on origin, with info on who is guilty and how long ago. Useful for gitflow and feature branches in general.
    show-origin = "!sh -c 'git fetch; \
                for BRANCH_NAME in $(git branch -r | grep -v HEAD); do \
                    echo $(git show -s --format=\"%Cred%ci %C(green)%h %C(yellow)%cr %C(magenta)%an %C(blue)\" $BRANCH_NAME | head -n 1) \\\t$BRANCH_NAME; \
            done | sort -r'"

    be = branch --edit-description

    track = for-each-ref --format='%(refname:short) <- %(upstream:short)' refs/heads

    br-active = "!f() { \
            git branch --no-merged \
                | grep -v '\\*'; \
        }; f"

    # Usage: git branches-active
    # Show only branches that are unmerged.
    branches-active = "!f() { \
            git branch -a -vv --no-merged \
                | grep -v '\\*'; \
        }; f"

    br-merged = "!f() { \
            git branch --merged \
                | grep -v '\\*'; \
        }; f"

    # Usage: git branches-merged
    # Show only branches that are merged.
    branches-merged = "!f() { \
            git branch -a -vv --merged \
                | grep -v '\\*'; \
        }; f"

    master = !git checkout master
    main =  !git checkout main
    develop = checkout develop

    update-all-branches = !sh -c "for BRANCH_NAME in $(git branch -r); do \
                git checkout $BRANCH_NAME; \
                git pull; \
            done"

    # Delete a local branch.
    delete-local-branch = branch -d

bclean = "!f() { \
        DEFAULT=$(git default); \
        git branch --merged ${1-$DEFAULT} \
            | grep -v " ${1-$DEFAULT}$" \
            | xargs git delete-local-branch; \
    }; f"

    # Delete fully merged branches.
    delete-local-merged-branches = "!f() { \
            git branch --no-color --merged \
                | grep -v '\\*' \
                | egrep -v \"(master|main|develop)\" \
                | xargs -n 1 git delete-local-branch; \
        }; f"

    # # https://stackoverflow.com/questions/6127328/how-can-i-delete-all-git-branches-which-have-been-merged
    # sweep = '!git branch --merged $([ $1 != "-f" ] && git rev-parse master) | \
    #           egrep -v "(^\*|^\s*(master|main|develop)$)" | \
    #           xargs git delete-local-branch'

    # Delete all branches that were safely merged into the main branch. All other are skipped (no worries).
    # On osx xargs does not have -r argument, so it fail. If you remove -r, it will run at least once, making this not safe operation.
    cleanup = !git branch --merged=master \
                | grep -Ev '^\\* | master$' \
                | xargs -r git delete-local-branch

    # Usage: git delete-remote-branch BRANCH_NAME
    # Delete a remote branch.
    delete-remote-branch = !git push $(git origin) --delete

    # Usage: git unpublish
    # Delete current branch on remote server.
    unpublish = !git delete-remote-branch $(git current-branch)

    delete-branch = "!f() { \
            git delete-local-branch $1 \
                && git delete-remote-branch $1; \
        }; f"

    # Usage: git prune-all
    # Prune deleted branches from all remotes.
    prune-all = !git remote \
                | xargs -n 1 git remote prune
    # 'git remote prune' does not understand '--all'.

    # There's no way to tell git remote update to prune orphaned branches?

    prune-local-branches = "!f() { \
            git branch -vv \
                | grep ': gone]' \
                | awk '{print $1}' \
                | xargs git delete-local-branch; \
        }; f"

    rename-local-branch = branch -m

    # Usage: git rename-branch OLD_BRANCH_NAME NEW_BRANCH_NAME
    # Rename both a local and remote branch.
    rename-branch = "!f() { \
            git rename-local-branch $1 $2 \
                && git push --set-upstream $(git origin) $2 \
                && git delete-remote-branch $1; \
        }; f"

    tag-with-date = !sh -c 'git tag $(date "+%Y.%m.%d_%H.%M")_"$0"'

    # Push TAG_NAME to remote repo.
    publish-tag = "!sh -c 'git push ${2:-$(git origin)} $1' -"

    # Remove TAG_NAME from remote repo.
    unpublish-tag = "!sh -c 'git push ${2:-$(git origin)} :refs/tags/$1' -"

    push-tags = push --tags

    # List tags.
    tags = tag -l --sort=v:refname

    # Show a list of tag names and the commits they reference.
    tags-show-ids = show-ref --tags

    last-tag = describe --tags --abbrev=0

    last-tag-all = !git describe --tags $(git rev-list --tags --max-count=1)

    # Usage: git rename-tag OLD_TAG_NAME NEW_TAG_NAME
    # Rename a tag (locally and remotely).
    rename-tag = "!f() { \
            git tag $2 $1; \
            git tag -d $1; \
            git push $(git origin) $2; \
            git push $(git origin) :refs/tags/$1; \
        }; f"

    # Delete local and remote tags.
    delete-tag = "!f() { \
            [ -z $1 ] \
                && echo \"No tags given as an argument!\" \
                || (git tag -l $1 | \
                    xargs -I % echo \"git tag -d % \
                                   && git push --delete $(git origin) %\" | \
                    sh); \
        }; f"

    # Usage: git compare-commits REV_BASE REV_COMPARE
    compare-commits = "!f() { \
            git log $1...$2; \
        }; f"

    # Usage: git compare-changed-files REV_BASE REV_COMPARE
    # Show changed files between two commits.
    compare-changed-files = "!f() { \
            git diff --stat $1...$2; \
        }; f"

    # Usage: git compare REV_BASE REV_COMPARE
    #      = git diff REV_BASE...REV_COMPARE
    # Example: git compare master@{1day} master
    compare = "!f() { \
            git diff $1...$2; \
        }; f"
    # https://github.com/fniessen/git-leuven/compare/master@%7B1day%7D...master

    # Usage: git missing [COMMIT_ISH]
    # Show the missing commits between this and another branch
    missing = "!f() { \
            printf \"$(tput bold)Only in HEAD:$(tput sgr0)\n\"; \
            git log "${1:-master}"..; \
            printf \"\n\"; \
            printf \"$(tput bold)Only in other:$(tput sgr0)\n\"; \
            git log .."${1:-master}"; \
        }; f"

    # Find the point at which a branch forked from another branch
    ancestor = !zsh -c 'diff --old-line-format='' --new-line-format='' \
                    <(git rev-list --first-parent "${1:-master}") \
                    <(git rev-list --first-parent "${2:-HEAD}") \
                | head -1' -

    # Since branch point.
    log-ancestor = !sh -c 'git log $(git ancestor)..'
    diff-ancestor = !sh -c 'git diff $(git ancestor)..'

    # Find the point at which a branch forked from MASTER
    # Best common ancestor (when it was branched off).
    ancestor2 = !git merge-base $(git origin)/master $(git current-branch)
    ancestor3 = !git merge-base --all $(git origin)/master $(git current-branch)

    # Usage: git missing-files [COMMIT_ISH]
    # Show the changed files between this and another branch
    # Examples:
    #   git missing-files             list changed files between this and master
    #   git missing-files feature/7   list changed files between this and the 'feature/7' branch
    missing-files = "!f() { \
            git diff --stat ${1:-master}...; \
        }; f"

    # 50 most recent commits.
    # XXX this is a summary?
    graph = log -50 --branches --tags --remotes --date-order --format=format:'%C(yellow)%h %C(reset) %<(75,trunc)%s <%cn> (%cr) %C(red)%d' --graph

    # Show log as a graph
    glog = log --all --graph

    releases = log --no-merges --all --simplify-by-decoration --graph

    hist = log --graph

    hist-full = log --pretty=format:'%C(green)%cr%C(reset) %C(yellow)%h%Creset %C(yellow)%d%Creset %s %C(bold blue)<%an>%Creset%n' --graph --name-status

    graphviz = "!f() { \
            echo 'digraph git {' ; \
            git log -25 --pretty='format:  %h -> { %p }' \"$@\" \
                | sed 's/[0-9a-f][0-9a-f]*/\"&\"/g' ; \
            echo '}'; \
        }; f"

    contributors-name  = shortlog -n -s --no-merges --
    contributors-email = shortlog -n -s -e --no-merges --

    whois = "!sh -c 'git log -i -1 --pretty=\"format:%an <%ae>\n\" --author=\"$1\"' -"

    pull-request-bb = "!f() { \
            USER_NAME=$1; \
            curl --user $USER_NAME https://bitbucket.org/$(git repo-owner)/$(git repo-slug)/pull-requests/new?source=$(git current-branch)&t=1; \
        }; f"

    pr-list = XXX

    # For GitHub.
    pr-checkout-gh = "!f() { \
            git fetch $(git origin) pull/$1/head:pr/$1 \
                && git checkout pr/$1; \
        }; f"
    # https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/checking-out-pull-requests-locally

    # For GitLab.
    pr-checkout-gl = "!f() { \
            git fetch $(git origin) merge-requests/$1/head:pr/$1 \
                && git checkout pr/$1; \
        }; f"
    # https://about.gitlab.com/blog/2016/12/08/git-tips-and-tricks/#add-an-alias-to-checkout-merge-requests-locally

    # For GitHub.
    mpr = "!f() { \
            declare OLD_BRANCH=\"$(git current-branch)\"; \
            declare BRANCH_NAME=\"${2:-$OLD_BRANCH}\"; \
            if [ $(printf \"%s\" \"$1\" | grep '^[0-9]\\+$' > /dev/null; printf $?) -eq 0 ]; then \
                git fetch $(git origin) refs/pull/$1/head:pr/$1 \
                    && git checkout -B $BRANCH_NAME \
                    && git rebase $BRANCH_NAME pr/$1 \
                    && git checkout -B $BRANCH_NAME \
                    && git merge --ff-only pr/$1 \
                    && git delete-local-branch pr/$1; \
            fi \
        }; f"

    # Merge given pull request into the current branch.
    # The commit message will have the same for as if done using the
    # merge button on github.com
    # Example:
    #   git merge-pr $(git origin) 5
    merge-pr = "!sh -c '\
        USER_AND_REPO=$(git remote show $1 | grep \"Fetch URL\" | sed -E \"s/.*github.com[:\\/]([a-zA-Z_\\-]+)\\/([a-zA-Z_\\-]+)\\.git$/\\1 \\2/\"); \
        USER=$(echo $USER_AND_REPO | cut -d\" \" -f1); \
        REPO=$(echo $USER_AND_REPO | cut -d\" \" -f2); \
        TMP_FILE=$(mktemp); \
        curl -si https://api.github.com/repos/$USER/$REPO/pulls/$2 > $TMP_FILE; \
        PULL_AUTHOR=$(cat $TMP_FILE | awk \"{if (/ *\\\"head\\\"/) head=\\\\$1; if (/ *\\\"login\\\": \\\"/) value=\\\\$2}{if (head && value) print value; if (head && value) exit}\" | sed -E \"s/\\\"([^\\\"]+)\\\".*/\\1/\"); \
        PULL_REF=$(cat $TMP_FILE | awk \"{if (/ *\\\"head\\\"/) head=\\\\$1; if (/ *\\\"ref\\\": \\\"/) label=\\\\$2}{if (head && label) print label; if (head && label) exit}\" | sed -E \"s/\\\"([^\\\"]+)\\\".*/\\1/\"); \
        PULL_TITLE=$(cat $TMP_FILE | grep \"\\\"title\\\": \" | sed \"s/^ *\\\"title\\\": \\\"//\" | sed \"s/\\\",$//\"); \
        rm $TMP_FILE; \
        git fetch $1 pull/$2/head; \
        git merge --no-ff -m \"Merged pull request #$2 from $PULL_AUTHOR/$PULL_REF\n\n$PULL_TITLE\" FETCH_HEAD; \
        ' -"

    pr-clean = "!f() { \
            git delete-local-branch pr/$1; \
        }; f"

    pr-show = XXX <pr-number>

    related-pr-of-commit = "!sh -c 'git log --merges --ancestry-path $1..master | tail -n 1 ' -"

    # Usage: git release VERSION
    # Release a new version of your project.
    release = "!f() { \
            git tag -a v$1 -m \"Release version $1\" \
                && git push $(git origin) --tags \
                && git push $(git origin); \
        }; f"

    # Usage: git manifest
    # Print a list of version controlled files for the current revision.
    manifest = ls-files

    # Check if any file in repo has whitespace errors
    # As described in http://peter.eisentraut.org/blog/2014/11/04/checking-whitespace-with-git/
    check-whitespace = diff-tree --check $(git hash-object -t tree /dev/null) HEAD
    whitespace-violations = "!git diff --check $(git hash-object -t tree /dev/null)"

    # Check if any file in repo has windows line endings
    # Currently do not work as alias, works from comand line directly. There is a problem with \r
    check-eol = grep --files-with-matches $'\\r' HEAD

rsync-deploy =

# Deploy a branch to review server (https://review-feature-1.example.com).
deploy-review =

# Deploy master to staging server (https://staging.example.com).
deploy-staging =

# Deploy master to production server (https://example.com).
deploy-prod =

  # # Deploy
  # staging = !git push heroku-staging $(git current-branch):master -f && git track 'Deployed to staging ' # push current branch to staging, can add more comments after
  # dev = !git push heroku-dev $(git current-branch):master -f && git track 'Deployed to dev ' # push current branch to dev
  # deploy = !git push heroku $(git current-branch):master -f && git track 'Deployed to production ' # push current branch to production

# shipit = push heroku master

 # deploy='git push production master && terminal-notifier-notify -title "Deploy" -message "Deploy complete"'
 # stage='git push staging $(git current-branch):master'

# title
# description
# assignee
# kind
# priority
    create-issue = XXX

    create-issue-pull-request = XXX

    # issues = "!f() { USER_NAME=$1; \
    #     curl --user $USER_NAME \
    #         https://api.bitbucket.org/2.0/repositories/$(git repo-owner)/$(git repo-slug)/issues \
    #         | jq -C --compact-output '.values | .[] | [.id, .title, .type, .priority, .state, .votes, .assignee.display_name, .created_on, .updated_on]' \
    #         | sed -r 's/(....)-(..)-(..)T(..):(..):(..).(............)/\\1-\\2-\\3/g' \
    #         | sed \"s/new/NEW/\" \
    #         | sed \"s/NEW/$(tput setaf 2) -- NOUVEAU -- $(tput sgr0)/\" \
    #         | sed \"s/NEW/\$(tput setaf 3) -NOUV- \$(tput sgr0)/\" \
    #         | sed \"s/open/OPEN/\" \
    #         | sed \"s/closed/CLOSED/\"; }; f"
# --data-urlencode 'priority >= \"major\"'

    issues-open = !git issues | grep "open"

    issues-assigned-to-me = !git issues | grep "$(git config --get user.name)"

    issues-created-by-me = XXX

    show-issue = XXX

    browse-issues = "!f() { \
            URL=$(git config --get remote.$(git origin).url); \
            xdg-open ${URL/.git}/issues/$1; \
        }; f"

    # Jira tickets.
    issues = "!f() { \
            : git log; \
            echo 'Printing issue keys'; \
            git log $@ \
                | egrep -o [A-Z]+-[0-9]+ \
                | sort -u; \
        }; f"

    browse-wiki = "!f() { \
            URL=$(git config --get remote.$(git origin).url); \
            xdg-open ${URL/.git}/wiki; \
        }; f"

    # Put everything in the current repo in a Zip archive.
    download-repository = "!f() { \
            git archive ${1:-HEAD} --format=zip -o $(basename $(git root))-commit-$(git rev-parse ${1:-HEAD}).zip; \
        }; f"
# XXX Test it with tag or branch.

    print-repo-name-then-run = "!f() { \
            echo "======="; \
            basename $(git rev-parse --show-toplevel); \
            echo "======="; \
            git "$@"; \
            echo; \
            echo; \
        }; f"

    # Run commands for each repository in the current directory.
    bulk = "!f() { \
            ls -R -d */.git \
                | sed s,/.git,, \
                | xargs -I{} git -C {} print-repo-name-then-run "$@"; \
        }; f"

    bulk-status = "!for DIR in $(find . -name \".git\"); do \
                      echo \"\n*** Repository: $DIR ***\" \
                          && git --git-dir=$DIR --work-tree=$DIR/.. status | grep -q \"is ahead of\"; \
                    done"

    # Usage: git bulk-pull
    # Loop through all your directories and pull.
    bulk-pull = !$HOME/bin/git-bulk-pull

    # Usage: git bulk-push
    # Loop through all your directories and push.
    bulk-push = !$HOME/bin/git-bulk-push

    exec = '!exec '

    # Show the diff between the latest commit and the current state
    d = !"git diff-index --quiet HEAD -- || clear; git --no-pager diff --patch-with-stat"

    # `git di $number' shows the diff between the state `$number' commits ago and the current state
    di = "!f() { git diff --patch-with-stat HEAD~$1; }; \
           git diff-index --quiet HEAD -- || clear; \
           f"

    # Interactive rebase with the given number of latest commits
    ireb = "!r() { git rebase -i HEAD~$1; }; r"

    # Start an interactive rebase of all the commits you haven't pushed
    # yet. Handy for collapsing a bunch of work-in-progress snapshots into
    # logical commits before pushing, without having to worry about accidentally
    # squashing a commit someone else has already referred to.
    work-in-progress = rebase -i @{u}

    st = status -s -b

    # Ignore whitespace changes.
    wdiff = diff -b
    wdiff = diff --word-diff

    dw = diff --word-diff

    # Configure git-diff to produce the absolutely most minimal diff possible.
    wdiff = diff -w --word-diff-regex=. --color-words -U0

    # Diff line-wise.
    df = diff

    # Diff word-wise.
    dw = diff --color-words

    # Diff character-wise.
    dt = diff --word-diff-regex=.

    # Review staged changes (about to be committed).
    dc = diff --cached

    # Diff staged line-wise
    ds = diff --cached

    # Diff staged word-wise
    dws = diff --color-words --cached

    # Diff staged character-wise
    dts = diff --word-diff-regex=. --cached

    precommit = diff --cached --diff-algorithm=minimal -w

    # Show log of new commits after you fetched, with stats, excluding merges
    log-fresh = log ORIG_HEAD.. --stat --no-merges

    # When was this file last updated, on each local branch.
    wwflu = "!f() { for b in $(git rev-parse --symbolic --branches); do \
                        echo -e $(git log --format=%at:%ar -1 $b -- \"$1\")\\\\t$b; \
                    done | sort -r | cut -f2 -d:; }; f"

    stage-modified-removed-files = add -u

    wip = commit -am "WIP"

    # Usage: git ls
    # Print a summary of activity.  Alias of log.
    ls = log

    ll = log --pretty=medium --abbrev-commit --stat

    # Usage: git last
    # Return the last commit on the current branch.
    last = log -1 --stat

    # Usage: git lastn [N]
    # Show the last N commits on the current branch.
    lastn = "!f() { \
            git show --name-only $(git rev-list -${1:-1} HEAD); \
        }; f"

    # lastn2 = "!f() { \
    #         git log -${1:-1} --stat $(git rev-list -${1:-1} HEAD); \
    #     }; f"

    # Usage: git file-history FILE
    # Show commit history of a file (like BitBucket).
    file-history = log
    # file-history1 = log --
    # file-history5 = "!f() { git show -s $(git rev-list --date-order HEAD -- $1); }; f"
    # file-history6 = !sh -c 'git show -s $(git rev-list --date-order HEAD -- $0)'

    # Usage: git file-history-follow-no-merges FILE
    # Show commit history of a file (with renames and copies, but without merge commits).
    file-history-follow-no-merges = log --follow --date-order -C

    # Usage: git file-history-all FILE
    # Show commit history of a file in all branches.
    file-history-all = log --all
    # file-history-all1 = log --all --
    # file-history-all5 = "!f() { git show -s $(git rev-list --date-order --all HEAD -- $1); }; f"
    # file-history-all6 = !sh -c 'git show -s $(git rev-list --date-order --all HEAD -- $0)'

    # Usage: git file-last-modified FILE
    # Show when file was last modified.
    file-last-modified = log -n 1 --all --date-order

    # Usage: git related FILE
    # Generate a list of which files changed together with a file.
    related = "!f() { \
            git show --name-only $(git rev-list HEAD -- $1); \
        }; f"

    # Usage: git related-files FILE
    # Generate a list of which files changed together with a file.
    related-files = !sh -c 'git log --format=format:%H $0 \
                | xargs -L 1 git diff-tree --no-commit-id --name-only -r \
                | sort \
                | uniq -c \
                | sort -b -n -r \
                | less'

    praise = blame -w
    archeology = blame -w -C -n
    whodoikill = blame -w -C -n

    # Given a merge commit, find the span of commits that exist(ed).
    # Not so useful in itself, but used by other aliases.
    # Thanks to Rob Miller for the merge-span-* aliaes.
    merge-span = "!f() { \
            echo $(git log -1 $2 --merges --pretty=format:%P | cut -d' ' -f1)$1$(git log -1 $2 --merges --pretty=format:%P | cut -d' ' -f2); \
        }; f"

    # Find the commits that were introduced by a merge
    merge-span-log = "!f() { \
            git log $(git merge-span .. $1); \
        }; f"

    # Show the changes that were introduced by a merge
    merge-span-diff = "!f() { \
            git diff $(git merge-span ... $1); \
        }; f"

    # Show the changes that were introduced by a merge, in your difftool
    merge-span-difftool = "!f() { \
            git difftool $(git merge-span ... $1); \
        }; f"

    # Show a list of existing remotes (with URL).
    r = remote -v

    # Usage: git incoming
    # Show new commits found in the remote repository.
    incoming = !(git remote update -p \
                && git log ..@{u})
    # TODO: git fetch, instead?
    # TODO: Add optional argument BRANCH_NAME, and delete alias incoming-on-branch

    # Alias of 'incoming'.
    in = !git incoming

    # Usage: git incoming-on-branch BRANCH_NAME
    # Show new commits found in the remote repository.
    # Example: git incoming-on-branch master
    incoming-on-branch = !sh -c 'git fetch' \
                && git log ..$(git origin)/$1

    # Usage: git who-is-changing-branch BRANCH_NAME
    who-is-changing-branch = !sh -c 'git shortlog HEAD..$(git origin)/$0'
    # TODO: Add fetch?

    incoming-files = !(git remote update -p \
                && git diff --stat ...@{u})

    # Alias of 'incoming-files'.
    in-files = !git incoming-files

    incoming-diff = diff @{u} HEAD
    # diff with upstream branch

    pull = pull -v

    # up = "!git stash && git pull && git stash pop"

    pull-autostash = ![ -z \"$(git status --porcelain -uno)\" ] \
                && git pull \
                || git stash push -m "autostash" \
                && git pull \
                && git stash pop

    up = pull --rebase --autostash
    up = !git fetch && git rebase --autostash FETCH_HEAD
    up= "!git fetch $(git origin) && git branch -v -a"

    f = !git fetch --all && git rebase $(git origin)/master

    # Get everything new.
    update = !git pull                     && git submodule update --init --recursive
    get    = !git pull --rebase            && git submodule update --init --recursive
    update = !git pull --rebase --prune $@ && git submodule update --init --recursive

    # Pull in remote changes for the current repository and all its submodules
    p = !"git pull; git submodule foreach git pull $(git origin) master"

    # Do a push/pull for just one branch.
    push-1 = "!git push $(git origin) $(git current-branch)"
    pull-1 = "!git pull $(git origin) $(git current-branch)"

    # Pull and push from the current branch.
    sync = "!f() { pull-1 && push-1; }; f"

    pull-all = !"OLD_BRANCH=$(git current-branch); \
                 for BRANCH_NAME in $(git for-each-ref refs/heads --format='%(refname)'); do \
                     git checkout ${BRANCH_NAME#refs/heads/}; \
                     git pull --ff-only; \
                 done; \
                 git checkout $OLD_BRANCH"

    # For the latest pull (even if there's nothing new).
    last-pulled = !stat -c %y $(git root)/.git/FETCH_HEAD \
                       | cut -d'.' -f1

    # For the latest pull resulting in changes coming in from the remote master
    # branch (the timestamp won't change when git pull reports there are no
    # changes).
    last-updated = !stat -c %y $(git root)/.git/refs/heads/$(git current-branch) \
                        | cut -d'.' -f1

    # Will only try to "merge" if your current HEAD commit is in the branch
    # you're merging in.  This will allow you to merge some commits whilst being
    # sure you won't get conflicts.
    mff = merge --ff-only
    mff = merge --ff-only @{u}

    # Avoid a fast-forward commit.
    mnf = merge --no-ff
    mnf2 = merge --no-ff --log

    # Usage: git sync-branch
    # Merge remote master into the current branch.
    sync-branch = !git fetch -p \
                && git merge $(git origin)/master

    # Catch up those random feature branches you haven't had to touch in months.
    catchup = !git fetch -p \
                && git rebase $(git origin)/master

    up-tmpname = "!f() { \
            git remote update -p; \
            git merge --ff-only @{u}; \
        }; f"

    # Rebasing non-linear changes (when the fast-forward merge is not possible).
    upr = "!f() { \
            git remote update -p; \
            git rebase -p @{u}; \
        }; f"

    merge-into-master =  "!f() { \
            OLD_BRANCH=\"$(git symbolic-ref HEAD 2>/dev/null)\" || OLD_BRANCH=\"(unnamed branch)\"; \
            OLD_BRANCH=${OLD_BRANCH##refs/heads/}; \
            git checkout master \
                && git merge $OLD_BRANCH \
                && git checkout $OLD_BRANCH; \
        };f"

    m = "!f() { \
            local OLD_BRANCH=$(git current-branch); \
            git checkout \"$1\" \
                && git pull \
                && git merge $OLD_BRANCH \
                && git push \
                && git checkout $OLD_BRANCH; \
        }; f"

    # Run merge test (before merge) to check for any conflicts beforehand.
    merge-test = "!f() { \
            git merge --no-commit --no-ff \"$1\"; \
            git merge --abort; \
            echo \"Merge aborted\"; \
        }; f"

    # Usage: git merge-dry-run BRANCH_NAME
    # Check how the merge of BRANCH_NAME into master will go
    merge-dry-run = "!f() { \
            grep -q 'changed in both' <<< $(git merge-tree $(git merge-base FETCH_HEAD $1) FETCH_HEAD $1) \
                && echo 'Merge conflicts!' \
                || echo 'This branch can be automatically merged.'; \
        }; f"
# DOESN'T work for git fetch & git merge

    # Extract the "changed in both" lines as well as the conflicting parts.
    merge-dry-run-conflicts = "!f() { \
            git merge-tree $(git merge-base $1 $2) $1 $2 \
                | sed -n '/+<<<<<<< .our/,/+>>>>>>> .their/p;/^changed in both/{n;N;N;s/^/#/mg;p}' \
                | cdiff; \
        }; f"

    ours = "!f() { \
            git checkout --ours $@ \
                && git add $@; \
        }; f"

    theirs = "!f() { \
            git checkout --theirs $@ \
                && git add $@; \
        }; f"

    # Usage: git conflicts
    # List files with conflicts.
    conflicts = diff --name-only --diff-filter=U

    edit-unmerged = "!$EDITOR $(git conflicts)"

    add-unmerged = "!git add $(git conflicts)"

    # Create a feature branch.
    feature = "!f() { git create-branch feature/$1 develop; }; f"
    # XXX or feature-start?

    # Incorporate a finished feature on develop.
    feature-finish = "!f() { \
            git checkout develop; \
            git merge --no-ff feature/$1 \
                && git delete-local-branch feature/$1; \
        }; f"

    # XXX Also bug and refactor.

    # XXX release-start
    # XXX release-finish

    # Shortcut for checkout.
    co = checkout

    next = "!f() { \
            git checkout $(git rev-list --topo-order HEAD..master | tail -1); \
        }; f"

    # "show-branch -g=N" can't be aliased for N easily, so we stop here:
    sb  = show-branch
    # pg sbt master pu -- if the last line is 'master' and not 'master~'
    # or 'master~N' then pu is a descendent of master
    sbt = show-branch --topics
    sbs = show-branch --sha1-name

    # Usage: git outgoing
    # Show commits not found in the remote branch.
    outgoing = log @{u}..

    # Alias of 'outgoing'.
    out = !git outgoing

    outgoing-files = diff --stat @{u}...

    # Alias of 'outgoing-files'.
    out-files = !git outgoing-files

    # Usage: git outgoing-all
    # Show commits not found in the destination repository.
    outgoing-all = log --branches --not --remotes

    # Alias of 'outgoing-all'.
    out-all = !git outgoing-all

    # Usage: git divergence BRANCH_NAME
    divergence = "!f() { \
            git log --cherry-pick --left-right --graph $1...$(git origin)/$1; \
        }; f"

    # Usage: git sha1-tag COMMIT
    sha1-tag = "!f() { \
            git name-rev --name-only \"$@\"; \
        }; f"

    lll = log -u

    # Apply a patch to files and/or to the index from URL.
    apply-url = "!f() { \
            curl -s $1 2>nul \
                | git apply ${@:2}; \
        }; f"

    # Apply a series of patches from an URL.
    am-url = "!f() { \
            curl -s $1 2>nul \
                | git am ${@:2}; \
        }; f"

    # Interactive apply patch.
    ipatch = "!f() { \
            git apply $1; \
            git add -p; \
        }; f"

    # Detailed list of changes.
    changelog1 = "!f() { \
            git log --no-merges ${1-$(git last-tag)}..HEAD; \
        }; f"
    changelog = !sh -c 'git log --no-merges --pretty=format:\"* %s\" $(git last-tag)...' -
    changelog-org = !sh -c 'git log --no-merges --pretty=format:\"- %s\" $(git last-tag)...' -

    # le dernier tag, ainsi que la liste des commits ayant eu lieu depuis sur la
    # branche courante.
    unreleased = !git log $(git last-tag)...HEAD \
                && git last-tag

    # Usage: git today [AUTHOR]
    today = "!f() { \
            git log \
                --since=midnight \
                --author=\"${1-$(git config --get user.name)}\" \
                --no-merges \
                --all \
                --pretty='%C(green)%ad%C(auto) - %s%C(auto)%d' \
                --date=format:'%Y-%m-%d %a %H:%M'; \
        }; f"

    # Usage: git yesterday [AUTHOR]
    yesterday = "!f() { \
            git log \
                --since='1 day ago midnight' --until=midnight \
                --author=\"${1-$(git config --get user.name)}\" \
                --no-merges \
                --all \
                --pretty='%C(green)%ad%C(auto) - %s%C(auto)%d' \
                --date=format:'%Y-%m-%d %a %H:%M'; \
        }; f"

    # Usage: git this-week [AUTHOR]
    this-week = "!f() { \
            git log \
                --since='1 week ago' \
                --author=\"${1-$(git config --get user.name)}\" \
                --no-merges \
                --all \
                --pretty='%C(green)%ad%C(auto) - %s%C(auto)%d' \
                --date=format:'%Y-%m-%d %a %H:%M'; \
        }; f"

    # Usage: git standup [AUTHOR]
    # Summarize changes since 24h, suitable for a daily standup meeting.
    standup = "!f() { \
            git log \
                    --branches \
                    --since=$(if [ \"$(date +%a)\" = \"Mon\" ]; then \
                                  echo \"friday\"; \
                              else \
                                  echo \"yesterday\"; \
                              fi) \
                    --author=\"${1-$(git config --get user.name)}\" \
                    --format=format:'%C(green)%ad%C(reset) - %s%C(auto)%d' \
                    --date=format:'%Y-%m-%d %a %H:%M'; \
        }; f"

    current-tag = tag --points-at HEAD
    zip = "!f() { \
            git archive --format=zip -o $(git current-tag).zip HEAD; \
        }; f"

    export-branch = "!f() { \
            git format-patch --stdout $1 > ~/$(git current-branch-without-slash).diff; \
        }; f"

    export-zip = archive -o latest.zip
    export-tgz = archive -o latest.tar.gz -9

    # Usage: git export-commit [COMMIT_ISH]
    # Create an archive of a commit.
    export-commit = "!f() { \
            git changed-files ${1:-HEAD} \
                | tr '\\n' '\\0' \
                | xargs -0 zip -9 $(git repo-slug)-commit-$(git current-branch-without-slash)-${1:-$(git commit-hash)}.zip; \
        }; f"

    # View raw commit.
    email-patch = XXX git format-patch $(git current-branch-without-slash).patch

    # Since oldest ancestor...
    plain-diff = !git branch-diff > $(git current-branch-without-slash).diff

    patch-for-this = "!git diff -p $(git hash-object -t tree /dev/null)"

    debug = "!set -x; GIT_TRACE=2 GIT_CURL_VERBOSE=2 GIT_TRACE_PERFORMANCE=2 GIT_TRACE_PACK_ACCESS=2 GIT_TRACE_PACKET=2 GIT_TRACE_PACKFILE=2 GIT_TRACE_SETUP=2 GIT_TRACE_SHALLOW=2 git"

    cp = cherry-pick -x
    pick = cherry-pick -s

    # cherry-pick - apply the changes introduced by some existing commits; useful for moving small chunks of code between branches.
    cp = cherry-pick

    # cherry-pick without making a commit, and when when recording the commit, append a line that says "(cherry picked from commit ...)"
    cp-nx = cherry-pick --no-commit -x

    h = help

    root = rev-parse --show-toplevel
    root-relative = rev-parse --show-prefix

    # Pull then push current branch.
    sync = !git pull \
                && git push

    sync = !git update \
                && git checkout master \
                && git pull \
                && git commit @{-1}

    # git resync -> sync repository and rebase current branch.
    resync = !sh -c 'git checkout master \
                && git fetch \
                && git reset --hard $(git origin)/master \
                && git rebase master'

    # Usage: git commit-interactive [FILE...]
    # Show record of pending changes, letting you choose which patch hunks to commit.
    commit-interactive = !sh -c '(git add -p -- $@ && git commit) \
                || git reset' --

    # Alias of 'commit-interactive'.
    record = !git commit-interactive

    lost = "!git fsck \
                | awk '/dangling commit/ {print $3}' \
                | git show --format='SHA-1: %C(yellow)%h%C(reset)  %s' --stdin \
                | awk '/SHA-1/ {sub(\"SHA-1: \", \"\"); print}'"

    # Resurrection of lost commits.
    zopa = !git log --all --pretty=oneline --abbrev-commit --graph \
                    $(git fsck --no-reflogs | grep commit | cut -d\\  -f3)

[include]
    path = .gitconfig_local
