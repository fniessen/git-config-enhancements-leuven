# .gitconfig, Time-stamp: 20230912.1122

[checkout]
    # Preserve timestamps of checked out files.
    preserveTimestamps = true

[user]
    # Override with your name and email in the file .gitconfig_local.
    name = John Doe
    email = john.doe@example.com

[github]
    # Override with your GitHub username in the file .gitconfig_local.
    user = jdoe

[fetch]
    # Remove remote-tracking references that no longer exist on the remote.
    prune = true

[init]
    # Set the default branch for new repositories to main.
    defaultBranch = main

[merge]
    # Show a three-way diff in case of conflicts.
    conflictstyle = diff3

[merge]
    # Use meld as the merge tool.
    tool = meld

[mergetool "meld"]
    # Run meld with the required arguments.
    cmd = meld --diff "$LOCAL" "$MERGED" "$REMOTE" --diff "$BASE" "$LOCAL" --diff "$BASE" "$REMOTE" --output "$MERGED"
    # cmd = meld --diff "$LOCAL" "$BASE" "$REMOTE" --diff "$BASE" "$LOCAL" --diff "$BASE" "$REMOTE" --output "$MERGED"
    # Don't keep backup files.
    keepBackup = false

[diff]
    tool = meld

[difftool]
    # Set prompt to false to avoid asking for confirmation before launching the diff tool.
    prompt = false

[difftool "meld"]
    # Set the command to launch "meld" with the two input files as arguments.
    cmd = meld "$LOCAL" "$REMOTE"

[core]
    # Set Emacsclient as the default editor.
    editor = emacsclient
    # editor = notepad++.exe -multiInst -notabbar -nosession -noPlugin

    # Set Git pager to ignore ^M and use less with custom flags.
    # (git-grep to ignore ^M)
    pager = tr -d '\\r' | less -REX

    # Set whitespace configuration to only warn about carriage return at the end of the line.
    whitespace = cr-at-eol
    # whitespace = fix,-indent-with-non-tab,trailing-space,space-before-tab,cr-at-eol

    # Set Git pager to use less with custom flags and diff-so-fancy.
    pager = diff-so-fancy | LESS= less --tabs=4 -FRX

[core]

    # Enable parallel filesystem operations.
    preloadindex = true

    # Enable file system caching to avoid UAC issues.
    fscache = true

[gc]
    # Optimize for repositories with many files.
    auto = 256

[help]
    # Enable autocorrect for mistyped commands.
    autocorrect = 1

[log]
    # Use short date format for log messages.
    date = short

    # Use short format for ref names (e.g. branch or tag names).
    decorate = short

[diff]
    # Treat file renames as copies.
    renames = copies

    # Set the limit of similarity for considering a file rename.
    renameLimit = 30000

    # Use the patience diff algorithm for generating patches.
    algorithm = patience

[diff "zebra"]
    # Use dimmed zebra coloring to highlight moved lines in a diff.
    colorMoved = dimmed_zebra

[diff "header"]
    # Include mnemonic prefixes in diff hunk headers.
    mnemonicprefix = true

    # Don't show any prefix in diff hunk headers.
    noprefix = true

[apply]
    # Don't detect whitespace errors when applying a patch.
    whitespace = nowarn

[status]
    submoduleSummary = true

[push]
    # Only push the current branch to its upstream branch.
    default = simple

[merge]
    # Show a diffstat of what changed in the merge.
    stat = true

    # Provide a summary of the merge, including affected files and commit messages.
    summary = true

    # Include summaries of merged commits in newly created merge commit messages.
    log = true

[rebase]
    # Enable the display of a diffstat when rebasing, showing what changed
    # during the rebase.
    stat = true

[grep]
    # Show line numbers in the results.
    lineNumber = true

    # # Allow extended regular expressions
    # extendedRegexp = true

    # Display the full path of matching files in the results.
    fullName = true

[color]
    ui = auto
    branch = auto
    diff = auto
    status = auto
    interactive = auto

[color "branch"]
    current = cyan bold
    local = green bold
    remote = red bold
    upstream = red bold
    plain = yellow reverse

[color "diff"]
    plain = "#888888"
    meta = 11
    frag = magenta bold
    func = "#cc99cc"
    old = red bold
    new = green bold
    commit = yellow
    whitespace = red reverse

[diff-so-fancy]
    useUnicodeRuler = true

[color "diff-highlight"]
    oldNormal = red bold
    oldHighlight = red bold 52
    newNormal = green bold
    newHighlight = green bold 22

[color "status"]
    header = normal
    added = green bold
    changed = yellow bold
    untracked = cyan
    branch = cyan bold
    nobranch = bold ul blink 12
    unmerged = red reverse bold

[color "grep"]
    context = "#888888"
    filename = yellow bold
    function = red
    linenumber = magenta bold
    match = green reverse bold
    matchContext = yellow reverse bold
    matchSelected = yellow bold blue
    separator = red bold
    selected = white

[format]
    pretty = format:%C(green)%ad%C(reset) %C(yellow)%h%C(auto)%d%C(reset) %s %C(bold blue)<%an>%C(reset)

# https://dev.to/megamattmiller/the-git-aliases-that-get-me-to-friday-1cmj
[custom.formats]
    ls = "[%C(auto,yellow)%<|(10)%h%C(reset)] [%C(auto,bold blue)%<(15trunc)%cn%C(reset)]  %C(auto)%d% C(reset)%s"
    find = "[%C(yellow)%<|(20)%h%C(reset)] [%C(bold blue)%<(10)%cn%C(reset)]  %C(auto)%d %C(reset)  %s"
    graph = "%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset) %C(yellow)%d%C(reset)%n %C(white)%s%C(reset)%n %C(dim white)- %an <%ae> %C(reset) %C(dim white)(committer: %cn <%ce>)%C(reset)"

[alias]

    ##? Usage: git aliases
    ##?
    ##? List all Git aliases in alphabetical order.
    aliases = "!git config -l \
                  | grep alias \
                  | cut -c 7- \
                  | sort \
                  | sed 's/=/ = /'"

    work-profile = config user.email \"john@work.com\"

    # Usage: git init-repository
    # Initialize a new Git repository with an initial commit.
    init-repository = !git init \
                && (ls -1A | grep -q . || touch .gitignore) \
                && git add . \
                && git commit -m \"Initial commit\"

    cl = clone --recursive

    # origin = !echo "${$(git config --get clone.defaultRemoteName):-origin}"
    origin = !echo "origin"

    # Usage: git repo-owner
    # Get the owner of the remote Git repository.
    repo-owner = "!f() { \
        git remote show $(git config --get remote.origin.url) -n \
            | grep 'Fetch URL:' \
            | sed -E 's#^.*[/:](.*)/.*$#\\1#' \
            | sed 's#\\.git$##'; \
    }; f"

    # Usage: git repo-slug-remote
    # Get the name of the remote repository.
    repo-slug-remote = "!f() { \
        git remote show $(git config --get remote.origin.url) -n \
            | awk -F/ '/Fetch URL:/{print $NF}' \
            | sed 's#\\.git$##'; \
    }; f"

    # Usage: git repo-slug-local
    # Provide the base name (slug) of the current local repository's top-level directory.
    repo-slug-local = "!f() { \
        echo $(basename \"$(git rev-parse --show-toplevel)\"); \
    }; f"

    # Usage: git main-branch
    # Get the name of the default branch (main or master).
    main-branch = "!f() { \
        if git show-ref --verify --quiet refs/heads/main; then \
            echo \"main\"; \
        else \
            echo \"master\"; \
        fi \
    }; f"

    ##? Usage: git search-for-files PATTERN
    ##?
    ##? List all files in the current branch matching a case-insensitive search pattern.
    ##?
    ##? Arguments:
    ##?   PATTERN                       Pattern
    search-for-files = "!f() { \
        local pattern=\"$1\"; \
        if [ -z \"$pattern\" ]; then \
            printf >&2 'Error: Missing pattern argument\n'; \
            return 2; \
        fi; \
        git ls-tree -r --name-only HEAD \
            | grep -i --color=auto \"$pattern\"; \
    }; f"

    # Alias of 'search-for-files'.
    find-files = !git search-for-files

    # Usage: git search-for-files-all PATTERN
    # Search for a file in all branches.
    search-for-files-all = "!f() { \
        for BRANCH in $(git for-each-ref refs/heads --format='%(refname)'); do \
            printf \"\n$(tput bold)$BRANCH:$(tput sgr0)\n\"; \
            git ls-tree -r --name-only $BRANCH | nl -bn -w3 | grep --color=auto \"$1\"; \
        done; \
    }; f"

    # Alias of 'search-for-files-all'.
    find-files-all = !git search-for-files-all

    # Usage: git search-for-code PATTERN [TREE]
    # Search for a string in files, ignoring binary files and highlighting matches.
    search-for-code = "grep -i -I --line-number --break --heading -C 1"

    # Alias of 'search-for-code'.
    ack = !git search-for-code

    search-for-code-in-extension = "XXX"

    # Usage: git git-search <search-term>
    # Search for a string in all Git-tracked files.
    grep-all = "!f() { \
        git rev-list --all \
          | xargs git grep \"$1\"; \
    }; f"
    # IN ALL COMMITS, NOT IN ALL BRANCHES???!!! LOTS OF DUPLICATES!!!

    # Usage: git gno PATTERN [TREE]
    # Search for a pattern in all tracked filenames, ignoring case and binary
    # files.
    gno = "grep -i -I --name-only"

    # Usage: git unmodify TREE_ISH...
    # Undo changes made to the working directory of the current branch by
    # overwriting them with the last committed version.
    unmodify = checkout --
    undelete = checkout --
    undo-changes = checkout --

    # Usage: git unstage [FILENAME...]
    # Unstage the changes to a file that were previously added to the Git
    # staging area.
    unstage = reset HEAD --

    # Usage: git staged-files
    # List files that are staged (added, modified, or deleted) and ready to be committed.
    staged-files = diff --cached --name-only

    # Usage: git added-files
    # List files that have been added but not yet committed.
    added-files = diff --cached --name-only --diff-filter=A

    # Usage: git modified-files
    # List files that have been modified in the working tree.
    modified-files = diff --name-only --diff-filter=M

    # Usage: git deleted-files
    # List files that have been deleted in the working directory.
    deleted-files = ls-files -d

    # Usage: git untracked-files
    # List files thare are not tracked by Git.
    untracked-files = ls-files --others --exclude-standard

    # Usage: git backup-untracked
    # Create a backup archive of untracked files in the repository.
    backup-untracked = "!f() { \
        repo_slug_remote=\"$(git repo-slug-remote)\"; \
        current_date=$(date +\"%Y-%m-%d\"); \
        backup_filename=\"$repo_slug_remote-$current_date-untracked.zip\"; \
        git ls-files --others --exclude-standard -z \
            | xargs -0 tar rvf ~/$backup_filename; \
    }; f"

    # Usage: git ignored-files
    # List files that are ignored according to your '.gitignore' rules.
    ignored-files = ls-files --others --ignored --exclude-standard

    # Usage: git tracked-files
    # List all tracked files in the repository, sorted by last modification time.
    tracked-files = ls-files -t

    # Usage: git check-file-status FILENAME
    # Check the status of a file (tracked, not tracked, or does not exist).
    check-file-status = "!f() { \
        if [ -e \"$1\" ]; then \
            if git ls-files --error-unmatch \"$1\" >/dev/null 2>&1; then \
                printf \"$1: tracked\\n\"; \
            else \
                printf \"$1: not tracked\\n\"; \
            fi; \
        else \
            printf \"$1: does not exist\\n\"; \
        fi; \
    }; f"

    # Add file or pattern to .gitignore.
    ignore = "!f() { \
        if [ ! -e .gitignore ]; then \
            touch .gitignore; \
        fi; \
        echo \"$1\" >> .gitignore; \
    }; f"

    # Ignore all untracked files by adding them to .gitignore.
    ignore-untracked = "!git status \
                | grep -P \"^\\t\" \
                | grep -vF .gitignore \
                | sed \"s/^\\t//\" \
                >> \"${GIT_PREFIX}.gitignore\""

    # Mark a file as unchanged and hide it from the Git status.
    skip = update-index --assume-unchanged

    # Revert the hidden status of a file, allowing it to be tracked again by Git.
    unskip = update-index --no-assume-unchanged

    # Mark all changed files as unchanged and hides them from the Git status.
    skip-all = "!git status -s \
                | awk {'print $2'} \
                | xargs git skip"

    # Revert the hidden status of all files, allowing them to be tracked again by Git.
    unskip-all = "!git skipped \
                | xargs git update-index --no-assume-unchanged"

    # List files marked as "assume unchanged" in the Git repository.
    skipped = "!git ls-files -v \
                | grep '^h' \
                | cut -c 3-"

    # Usage: git clean-untracked
    # Remove all untracked files and directories (that are not ignored by Git).
    clean-untracked = clean -f -d -X
    # THIS COMMAND MAY DELETE FILES THAT CANNOT BE RECOVERED.

    # Usage: git clean-untracked-dry
    # Show what files and directories would be removed by the clean-untracked
    # alias without actually removing them.
    clean-untracked-dry = clean -n -d -X

    # Usage: git clean-all
    # Delete all untracked files and directories, including those that are
    # ignored by Git.
    clean-all = clean -f -d -x
    # THIS COMMAND MAY DELETE FILES THAT CANNOT BE RECOVERED.

    # Usage: git clean-all-dry
    # Show what files and directories would be removed by the clean-all alias
    # without actually removing them.
    clean-all-dry = clean -n -d -x

    # Usage: git stash-push
    # Stash changes in the working directory for later retrieval.
    stash-push = stash push

    # Usage: git stash-all
    # Stage all changes and untracked files, then creates a stash.
    stash-all = !git add -A \
                && git stash

    # Usage: git stash-untracked
    # Stash changes, including untracked files, for later retrieval.
    stash-untracked = stash push --include-untracked

    # Usage: git snapshot
    # Create a snapshot stash with a timestamp and immediately apply it.
    snapshot = !git stash push -m "snapshot-$(date +%Y%m%d_%H%M)" \
                && git stash apply "stash@{0}"

    # Usage: git checkpoint
    # Create a new temporary stash with a timestamp and restore staged changes.
    checkpoint = !git stash push -m "$(date +%F--%T)" \
                && git stash pop --index

    # Usage: git checkpoint-recover [TIME_INTERVAL]
    # Display a formatted log of recent version changes with timestamps and commit messages.
    # Example: git checkpoint-recover 1week
    checkpoint-recover = "!f() { \
        git fsck \
            | grep commit \
            | cut -d' ' -f3 \
            | while read HASH; do \
                  git rev-parse --verify --no-revs --quiet $HASH^2 2>/dev/null \
                      && echo $HASH \
                      | xargs git rev-list --since=${1:-1day} -1; \
              done \
            | xargs -L 1 git log -1 --format=%at:%h \
            | sort \
            | cut -f2 -d: \
            | xargs -L 1 git log -3 --format='%Cblue%h %Cgreen(%ar) %Creset%s' --graph; \
    }; f"

    # Usage: git stashes
    # List stashes with their short creation dates.
    stashes = stash list --date=short

    # Usage: git stash-view
    # Show the changes introduced by the latest stash in a unified diff format.
    stash-view = stash show -p
    # Instead of unshelving the changes, show the diff that would result from
    # unshelving.

    # Show only stash with name like text.
    stash-show = "!f() { \
        git stash show stash^{/$@} -p; \
    }; f"

    stash-show = "!f() { \
        git stash show stash^{/$*} -p; \
    }; f"

    stash-shno = stash show --name-only

    # Usage: git stash-apply [STASH_INDEX]
    # Apply a specific stash to the working directory.
    stash-apply = "!f() { \
        if [ -z \"$1\" ]; then \
            git stash apply; \
        else \
            git stash apply stash@{\"$1\"}; \
        fi \
    }; f"
    # Apply changes but don't delete them.

    # Find stash with name like text.
    stash-apply = "!f() { \
        git stash apply stash^{/$@}; \
    }; f"

    stash-apply = "!f() { \
        git stash apply stash^{/$*}; \
    }; f"

    # Revert the changes introduced by the most recent stash.
    stash-revert = !git stash show -p --no-textconv --binary \
                | git apply -R

    # Usage: git find-stash-id [SEARCH_STRING]
    # Find the stash ID by searching stash descriptions for a specific string.
    find-stash-id = "!f() { \
        git stash list \
            | grep $@ \
            | head -n 1 \
            | sed -n 's/stash@{\\(.*\\)}.*/\\1/p'; \
    }; f"
    # Only accepts single word, no quotations.

    # Usage: git pop-stash [STASH_INDEX_OR_ID]
    # Appliy and remove the specified stash by index or ID.
    stash-pop = "!f() { \
        git stash pop stash@{$(git find-stash-id $@)}; \
    }; f"

    # Usage: git unstash [STASH_INDEX]
    # Apply the most recent stash and removes it from the stash stack.
    # Apply and remove a specific stash from the stash stack.
    unstash = "!f() { \
        if [ -z \"$1\" ]; then \
            git stash pop; \
        else \
            git stash pop stash@{\"$1\"}; \
        fi \
    }; f"

    # Usage: git stash-remove [STASH_INDEX]
    # Remove a specific stash from the stash stack without applying changes.
    stash-remove = stash drop

    # Usage: git stashes-clear
    # Remove all stashes from the stash stack.
    stashes-clear = "!git stash list \
                   | cut -d: -f1 \
                   | xargs -r -I {} git stash-remove {}"

    # Usage: git ci -m "MESSAGE"
    # Alias for "git commit".
    ci = commit

[commit]
    template = ~/.git_commit_template.txt

[alias]

    # Usage: git last-commit-hash
    # Show abbreviated hash of the last commit.
    # Examples:
    #   git last-commit-hash          find hash of last commit
    #   git last-commit-hash develop  find hash of last commit in develop
    last-commit-hash = log -1 --pretty=format:'%h'

    # Usage: git changed-files [COMMIT]
    # Show all files modified in each commit, including merge commits.
    # Examples:
    #   git changed-files             List files modified in last commit
    #   git changed-files bada55      List files modified in the commit with hash 'bada55'
    changed-files = "!f() { \
        if [ $# -eq 0 ]; then \
            git diff --name-only HEAD^ HEAD; \
        else \
            git diff --name-only $1^ $1; \
        fi \
    }; f"

    # Usage: git download-email-patch
    # Generate a patch file for the current branch using the git format-patch command.
    download-email-patch = "!f() { \
        local current_branch=$(git current-branch); \
        git format-patch $current_branch.patch; \
    }; f"

    # Usage: git download-commit-plain-diff [COMMIT]
    # Create a diff file for the changes in a commit or range of commits.
    download-commit-plain-diff = "!f() { \
        git diff ${1:-HEAD}~ ${1:-HEAD} > ${1:-HEAD}.diff; \
    }; f"

    # Usage: git difftool-rev [REVISION]
    # Launch a diff tool for a specific revision or branch.
    difftool-rev = "!f() { \
        REV=$(git rev-parse \"${*:-HEAD}\"); \
        git difftool $REV~1 $REV; \
    }; f"

    # Usage: git file-diff-last-modification FILENAME
    # Show the diff of the last commit that modified a specific file using
    # a diff tool.
    file-diff-last-modification = "!f() { \
        PROJECT_ROOT_DIR=$(git root); \
        echo Finding full file path of \"$1\" in $PROJECT_ROOT_DIR; \
        FILEPATH=$(find $PROJECT_ROOT_DIR -type f -name \"$1\"); \
        echo full file path $FILEPATH; \
        LAST_MODIFIED_COMMIT_HASH=$(git rev-list -1 HEAD $FILEPATH); \
        echo last commit file modified $LAST_MODIFIED_COMMIT_HASH; \
        git difftool $LAST_MODIFIED_COMMIT_HASH^ $FILEPATH; \
    }; f"

    file-diff-last-modification2 = "!f() { \
        PROJECT_ROOT_DIR=$(git rev-parse --show-toplevel); \
        echo Finding full file path of \"$1\" in $PROJECT_ROOT_DIR; \
        FILEPATH=$(git ls-files --full-name -- \"$1\"); \
        echo Full file path $FILEPATH; \
        LAST_MODIFIED_COMMIT_HASH=$(git log -1 --pretty=format:%H -- $FILEPATH); \
        echo Last commit file modified $LAST_MODIFIED_COMMIT_HASH; \
        git difftool $LAST_MODIFIED_COMMIT_HASH^ $FILEPATH; \
    }; f"

    # Usage: git dir-diff
    # Open Meld with directory comparison for all modified files.
    dir-diff = difftool -t meld --dir-diff

    # Usage: git find-branches-containing COMMIT_HASH
    # List branches containing a specific commit.
    find-branches-containing = "!f() { \
        if [ $# -eq 0 ]; then \
            echo 'Usage: git find-branches-containing COMMIT_HASH'; \
        else \
            git branch -a --contains $1; \
        fi \
    }; f"

    # Usage: git find-tags-containing COMMIT_HASH
    # Find tags containing commit.
    find-tags-containing = "!f() { \
        git tag -l --contains \"$1\" \
            | sort -r; \
    }; f"

    # Usage: git is-ancestor COMMIT_1 COMMIT_2
    # Check if one commit is an ancestor of another.
    is-ancestor = !$HOME/bin/git-is-ancestor

    # Error with 2 search strings!!!
    search-for-commits-all-1 = "log -i --all --grep"

    # Only one search string is read!
    search-for-commits-all-2 = "!f() { \
        git log --grep \"$1\" -i $(git rev-list --all); \
    }; f"

    search-all-commits = "!git rev-list --all | xargs git grep -F"

    # Usage: git search-for-commits-bitbucket-or KEYWORD...
    # Search for commit messages that match one or more search patterns (Filter
    # by message).
    search-for-commits-or-bitbucket = "!f() { \
        for l in \"$@\"; do \
            git log --grep \"$l\" -i --format=\"%at:%C(green)%ad%C(reset) %C(yellow)%h%C(auto)%d%C(reset) %s %C(bold blue)<%an>%C(reset)\" --color=always; \
            printf \"\\n\"; \
        done | sort -r; \
    }; f"
    # XXX Wrong sorting if all on the same date (wth "testing failure" on PFlow)
    # XXX Add all, date short...

    # Usage: git search-for-commits-gitlab-and PATTERN...
    # Search for commits that match one or more search patterns in commit
    # messages OR DIFF CONTENTS??? (Filter by message).
    search-for-commits-and-gitlab = "!f() { \
        CMD=\"git log --all-match -i\"; \
        for PATTERN in \"$@\"; do \
            CMD=\"$CMD --grep '$PATTERN'\"; \
        done; \
        eval $CMD; \
    }; f"

    # Usage: git author-commits [AUTHOR_EMAIL]
    # Show commit history for a specific author.
    author-commits = "!f() { \
        git log --author=${1-$(git config --get user.email)} -i --no-merges --all; \
    }; f"

    # Usage: git search-changes-in-message-and-diff SEARCH_TERM
    # Search for commits that add or remove a specific term in the repository's diff contents.
    search-changes-in-message-and-diff = "!f() { \
        git log --all -S \"$1\"; \
    }; f"

    # Usage: git show-commits-for-string STRING FILENAME
    # Show commits that add or remove a specific string in a file.
    # Example: git show-commits-for-string CLOSED '*.java'
    show-commits-for-string = "!sh -c 'git log -p -S \"$1\" \"$2\"' -"

    browse-commits = "!f() { \
        URL=$(git config --get remote.$(git origin).url); \
        xdg-open ${URL/.git}/commits; \
    }; f"

    # Append the staged changes to the last commit (keeping the pre-existing
    # commit message).
    recommit = commit -v --amend --reuse-message HEAD

    # Usage: git reword "NEW_COMMIT_MESSAGE"
    # Amend the previous commit message.
    amend = commit --amend -m

    # Usage: git amend-author NAME EMAIL
    # Amend the last commit with a new author.
    amend-author = "!f() { \
        git commit --amend --author=\"$1 <$2>\" --reuse-message HEAD; \
    }; f"

    # Edit history.
    recommit2 = "!f() { \
        TARGET=$(git rev-parse \"$1\"); \
        git commit --fixup=$TARGET ${@:2} \
            && GIT_EDITOR=true git rebase --interactive --autostash --autosquash $TARGET~; \
    }; f"
    # See https://blog.filippo.io/git-fixup-amending-an-older-commit/

    # Checkout the commit in question, and amend its message.
    reword2 = "!f() { \
        local current_branch=$(git current-branch); \
        git checkout \"$1\"; \
        git commit --amend; \
        git checkout $current_branch; \
    }; f"

    # Usage: git uncommit
    # Undo the most recent commit and keep the changes staged for commit again.
    uncommit = reset --soft HEAD~1

    # Usage: git uncommit-unstage
    # Undo the most recent commit and keep the changes made in the commit as
    # unstaged changes in the working directory.
    uncommit-unstage = reset --mixed HEAD~1

    # Usage: git undo
    # Undo the most recent commit and delete any changes made to the code since
    # then.
    undo = reset --hard HEAD~1

    # Usage: git squash NUMBER_OF_COMMITS_TO_UNDO
    # Create a new commit that combines the changes introduced by a specified
    # number of previous commits into a single commit.
    squash = "!f() { \
        local upstream=$(git rev-parse --abbrev-ref @{u} 2>/dev/null); \
        if [ -z \"$upstream\" ]; then \
            printf >&2 \"Error: No upstream branch configured for the current branch.\\n\"; \
            return 2; \
        fi; \
        local num_unpushed=$(git rev-list $upstream..HEAD --count); \
        if [ $1 -le $num_unpushed ]; then \
            git squash-force $1; \
        else \
            printf >&2 \"Error: Cannot squash %d commits. There are only %d unpushed commits.\\n\" $1 $num_unpushed; \
        fi; \
    }; f"

    # Usage: git squash-force NUMBER_OF_COMMITS_TO_UNDO
    # Create a new commit that combines the changes introduced by a specified
    # number of previous commits without safety checks.
    squash-force = "!f() { \
        git reset --soft HEAD~$1 \
            && git commit --edit -m\"$(git log --reverse --format=%B HEAD..HEAD@{1})\"; \
    }; f"

    create-branch = checkout -b

    # Usage: git current-branch
    # Show the current branch name (v2.22+).
    current-branch = branch --show-current

    # current-branch = !git symbolic-ref --short HEAD 2>/dev/null
    # Less readable, less convenient and user-friendly.

    # Usage: git current-branch-without-slash
    # Show the current branch name (without slash).
    current-branch-without-slash = "!f() { \
        git current-branch \
            | tr '/' '-'; \
    }; f"

    # Usage: git publish
    # Push the current branch to the upstream branch with the same name.
    push-upstream = !git push -u $(git origin) $(git current-branch)
    # push-upstream = !git push -u $(git remote show origin | grep 'Fetch URL' | cut -d':' -f2- | sed 's/\.git$//') $(git current-branch)

    # Alias of 'push-upstream'.
    publish = !git push-upstream

    # Usage: git branches
    # Show all branches with their corresponding upstream branches and commit hashes.
    branches = branch -a -vv

    ##? Usage: git local-branches
    ##?
    ##? List and display local branches.
    local-branches = "!git rev-parse --symbolic --branches"
    # Note: The alternative method
    # local-branches = "!git for-each-ref --format='%(refname:short)' refs/heads/"
    # is slower.

    # Usage: git br
    # Show detailed information about local branches, sorted by commit date.
    br = for-each-ref refs/heads \
                --sort=-committerdate \
                --format='%(color:green)%(committerdate:short)%(color:reset) %(HEAD) %(color:green bold)%(refname:short)%(color:reset) %(color:red bold)%(upstream:track)%(color:reset) %(color:yellow)%(objectname:short)%(color:reset) %(contents:subject) %(color:bold blue)<%(authorname)>%(color:reset)'

    # Usage: git remote-branches
    # List remote branches sorted by most recent commit.
    remote-branches = "!f() { \
        git fetch; \
        for branch in $(git branch -r | grep -v HEAD); do \
            echo \"$(git show -s --format='%Cred%ci %C(green)%h %C(yellow)%cr %C(magenta)%an %C(blue)' $branch | head -n 1) \\t$branch\"; \
        done | sort -r; \
    }; f"

    # Usage: git branch-desc BRANCH_NAME
    # Edit the description of a branch.
    branch-desc = "!f() { \
        git branch --edit-description \"$1\"; \
    }; f"

    # Usage: git branch-upstream
    # List local branches and their upstream branches.
    branch-upstream = for-each-ref --format='%(refname:short) <- %(upstream:short)' refs/heads

    # Usage: git my-branches
    # Show all local branches created by the current user.
    my-branches = !git for-each-ref --format='%(authorname) %(refname:short)' refs/heads | grep -E \"^$(git config --get user.name)\"

    br-active = "!f() { \
        git branch --no-merged \
            | grep -v '\\*'; \
    }; f"

    # Usage: git branches-active
    # Show only branches that are unmerged.
    branches-active = "!f() { \
        git branch -a -vv --no-merged \
            | grep -v '\\*'; \
    }; f"

    # Usage: git br-merged
    # List branches merged into the current branch, excluding the current branch itself.
    br-merged = "!f() { \
        git branch --merged $(git current-branch) \
            | grep -v \"^\\*\"; \
    }; f"

    # Usage: git branches-merged
    # List merged branches (including remote branches), excluding the current branch.
    branches-merged = "!f() { \
        git branch -a -vv --merged \
            | grep -v '\\*'; \
    }; f"

    main = checkout main
    master = "!f() { \
        git checkout $(git main-branch); \
    }; f"
    develop = checkout develop

    # Usage: git sync-main-merge
    # Fetch and merge the latest changes from the remote "main" branch into the current local branch.
    sync-main-merge = !git remote update -p \
                && git merge $(git origin)/$(git main-branch)

    sync-main-merge2 = "!f() { \
        git remote update -p; \
        local main_branch=$(git main-branch || echo 'main'); \
        local current_branch=$(git current-branch); \
        git merge origin/$main_branch; \
        merge_status=$?; \
        if [ $merge_status -eq 0 ]; then \
            echo \"Branch synced: '$current_branch' successfully synced with '$main_branch'\"; \
        else \
            git merge --abort 2>/dev/null; \
            echo \"Unable to sync branch: You can't merge until you resolve all merge conflicts.\"; \
        fi \
    }; f"

    # Fetch and rebase the current local branch onto the latest changes from the remote "main" branch.
    sync-main-rebase = !git remote update -p \
                && git rebase $(git origin)/$(git main-branch)

    pull = pull -v

    # Usage: git pull-autostash
    # Auto-stash changes, pull, and restore stashed changes.
    pull-autostash = pull --rebase --autostash
    pull-autostash2 = "!f() { \
        if [ -n \"$(git status --porcelain -uno)\" ]; then \
            git stash push -m \"autostash\"; \
        fi; \
        git pull; \
        git stash pop; \
    }; f"

    # Pull with rebase and auto-stash, updating your local branch with remote changes.
    up-rebase = pull --rebase --autostash

    # Update remote-tracking branches comprehensively, then rebase your current branch using fetched changes.
    up-rebase2 = !git remote update -p && git rebase --autostash FETCH_HEAD

    # Usage: git sync-ff-upstream
    # Update local branch with fast-forward from upstream.
    sync-upstream-ff = "!f() { \
        git remote update -p; \
        git merge --ff-only @{u}; \
    }; f"
    # (Keep your local branch in sync with the remote branch without creating
    # merge commits.)

    # Update remote-tracking branches and rebase the current local branch onto the upstream branch it tracks.
    sync-upstream-rebase = "!f() { \
        git remote update -p; \
        git rebase -p @{u}; \
    }; f"
    # Rebasing non-linear changes (when the fast-forward merge is not possible).

    # Iteratively synchronize all local branches with their corresponding remote branches using fast-forward merges.
    update-all-branches = "!f() { \
        local current_branch=$(git current-branch); \
        for BRANCH_REF in $(git for-each-ref refs/heads --format='%(refname)'); do \
            local BRANCH=${BRANCH_REF#refs/heads/}; \
            if [ \"$BRANCH\" != \"$current_branch\" ]; then \
                echo \"Switching to branch: $BRANCH\"; \
                git checkout $BRANCH && \
                git pull --ff-only; \
                echo; \
                echo; \
            fi; \
        done; \
        git checkout $current_branch; \
    }; f"

    ##? Usage: git update-all-branches2
    ##?
    ##? Update all local branches with their remote counterparts, checking for conflicts before updating.
    update-all-branches2 = "!f() { \
        local local_branches=$(git local-branches); \
        for branch in $local_branches; do \
            printf \"Checking for conflicts in \\e[1m%s\\e[0m...\\n\" \"$branch\"; \
            if git rev-parse --verify origin/$branch >/dev/null 2>&1; then \
                if git merge-base --is-ancestor origin/$branch $branch; then \
                    printf \"No conflicts found in \\e[1m%s\\e[0m. Updating...\\n\" \"$branch\"; \
                    git pull origin $branch:$branch; \
                    printf \"\\n\"; \
                else \
                    printf \"Potential conflicts found in \\e[1m%s\\e[0m. Skipping update.\\n\\n\" \"$branch\"; \
                fi; \
            else \
                printf \"Remote branch \\e[1m%s\\e[0m does not exist. Skipping update.\\n\\n\" \"$branch\"; \
            fi; \
        done \
    }; f"

    # Delete a local branch.
    delete-local-branch = branch -d

    # Delete local branches that have been merged into the default branch.
    bclean = "!f() { \
        local main_branch=$(git main-branch || echo 'main'); \
        git branch --merged ${1-$main_branch} \
            | grep -v " ${1-$main_branch}$" \
            | xargs git delete-local-branch; \
    }; f"

    # Delete fully merged branches.
    delete-local-merged-branches = "!f() { \
        git branch --no-color --merged \
            | grep -v '\\*' \
            | egrep -v \"(master|main|develop)\" \
            | xargs -n 1 git delete-local-branch; \
    }; f"

    # # https://stackoverflow.com/questions/6127328/how-can-i-delete-all-git-branches-which-have-been-merged
    # sweep = '!git branch --merged $([ $1 != "-f" ] && git rev-parse master) | \
    #           egrep -v "(^\*|^\s*(master|main|develop)$)" | \
    #           xargs git delete-local-branch'

    # Delete branches safely merged into the main branch, skipping main and *
    # (current) branches.
    cleanup-branches = !git branch --merged $(git main-branch) \
                            | grep -vE '^\\* | $(git main-branch)$' \
                            | xargs -r git delete-local-branch
    # On OSX, 'xargs' does not have '-r' argument, so it fail. If you remove
    # '-r', it will run at least once, making this not safe operation.

    # Usage: git delete-remote-branch BRANCH_NAME
    # Delete a remote branch.
    delete-remote-branch = !git push $(git origin) --delete
    # = "Close source branch" (after merging).

    # Usage: git unpublish
    # Delete the current branch from the remote repository.
    unpublish = !git delete-remote-branch $(git current-branch)

    delete-branch = "!f() { \
        git delete-local-branch \"$1\" \
            && git delete-remote-branch \"$1\"; \
    }; f"

    # Usage: git prune-all
    # Prune deleted branches from all remotes.
    prune-all = !git remote \
                | xargs -n 1 git remote prune
    # 'git remote prune' does not understand '--all'.

    # There's no way to tell git remote update to prune orphaned branches?

    # Usage: git prune-local-branches
    # Prune local branches that have been removed from the remote repository.
    prune-local-branches = "!f() { \
        git branch -vv \
            | grep ': gone]' \
            | awk '{print $1}' \
            | xargs git delete-local-branch; \
    }; f"

    # Usage: git rename-local-branch [OLD_BRANCH_NAME] NEW_BRANCH_NAME
    # Rename a local branch.
    rename-local-branch = branch -m

    # Usage: git rename-branch OLD_BRANCH_NAME NEW_BRANCH_NAME
    # Rename both a local and remote branch.
    rename-branch = "!f() { \
        git rename-local-branch \"$1\" $2 \
            && git push --set-upstream $(git origin) $2 \
            && git delete-remote-branch \"$1\"; \
    }; f"

    # Usage: git tag-with-date [SUFFIX]
    # Tag the current commit with the current date and a custom suffix.
    tag-with-date = "!sh -c 'git tag $(date \"+%Y.%m.%d_%H.%M\")_\"$0\"'"

    # Usage: git publish-tag TAG_NAME [REMOTE_NAME]
    # Publish a Git tag to a remote repository.
    publish-tag = "!sh -c 'git push ${2:-$(git origin)} $1' -"

    # Usage: git unpublish-tag TAG_NAME [REMOTE_NAME]
    # Remove a published Git tag from a remote repository.
    unpublish-tag = "!sh -c 'git push ${2:-$(git origin)} :refs/tags/$1' -"

    push-tags = push --tags

    # List tags.
    tags = tag -l --sort=v:refname

    # Show a list of tag names and the commits they reference.
    tags-show-ids = show-ref --tags

    last-tag = describe --tags --abbrev=0

    last-tag-all = !git describe --tags $(git rev-list --tags --max-count=1)

    # Usage: git rename-tag OLD_TAG_NAME NEW_TAG_NAME
    # Rename a tag (locally and remotely).
    rename-tag = "!f() { \
        git tag $2 \"$1\"; \
        git tag -d \"$1\"; \
        git push $(git origin) $2; \
        git push $(git origin) :refs/tags/\"$1\"; \
    }; f"

    # Delete local and remote tags.
    delete-tag = "!f() { \
        [ -z \"$1\" ] \
            && echo \"No tags given as an argument!\" \
            || (git tag -l \"$1\" | \
                xargs -I % echo \"git tag -d % \
                               && git push --delete $(git origin) %\" | \
                sh); \
    }; f"

    # Usage: git compare-commits REV_BASE REV_COMPARE
    compare-commits = "!f() { \
        git log \"$1\"...$2; \
    }; f"

    # Usage: git compare-changed-files REV_BASE REV_COMPARE
    # Show changed files between two commits.
    compare-changed-files = "!f() { \
        git diff --stat \"$1\"...$2; \
    }; f"

    # Usage: git compare REV_BASE REV_COMPARE
    #      = git diff REV_BASE...REV_COMPARE
    # Example: git compare master@{1day} master
    compare = "!f() { \
        git diff \"$1\"...$2; \
    }; f"
    # https://github.com/fniessen/git-leuven/compare/master@%7B1day%7D...master

    # Usage: git missing [OTHER_BRANCH]
    # Show the missing commits between the current branch and another branch.
    missing = "!f() { \
        local current_branch=$(git current-branch); \
        local other_branch=${1:-$(git main-branch)}; \
        commits_missing_to_current=$(git rev-list --count \"$other_branch\"..\"$current_branch\"); \
        commits_missing_to_other=$(git rev-list --count \"$current_branch\"..\"$other_branch\"); \
        printf \"$(tput bold)Commits missing in '%s' but present in '%s':$(tput sgr0) %d commits\\n\" \
            \"$other_branch\" \"$current_branch\" \"$commits_missing_to_current\"; \
        git log \"$other_branch\"..\"$current_branch\"; \
        printf \"\\n$(tput bold)Commits missing in '%s' but present in '%s':$(tput sgr0) %d commits\\n\" \
            \"$current_branch\" \"$other_branch\" \"$commits_missing_to_other\"; \
        git log \"$current_branch\"..\"$other_branch\"; \
    }; f"

    # Find the point at which a branch forked from another branch (when it was branched off).
    # Find the most recent common ancestor between the current branch and the default branch.
    ancestor = !git merge-base ${1:-$(git main-branch)} \
                               ${2:-$(git current-branch)}
    # BUG: Does not work between 2 specific branches -- well without arguments

    # Since branch point.
    log-ancestor = !sh -c 'git log $(git ancestor)..'
    diff-ancestor = !sh -c 'git diff $(git ancestor)..'

    # Usage: git missing-files [OTHER_BRANCH]
    # Show the changed files that are in the current branch but not in the other (i.e., asymmetrical diff).
    # Examples:
    #   git missing-files             list changed files between this and main
    #   git missing-files feature/7   list changed files between this and the 'feature/7' branch
    missing-files = "!f() { \
        local current_branch=$(git current-branch); \
        local other_branch=${1:-$(git main-branch)}; \
        missing_files_to_current=$(git diff --name-only \"$other_branch\"..\"$current_branch\" | wc -l | tr -d '[:space:]'); \
        printf \"$(tput bold)Files missing in '%s' but present in '%s':$(tput sgr0) %d files\\n\" \"$other_branch\" \"$current_branch\" \"$missing_files_to_current\"; \
        git diff --stat \"$other_branch\"...\"$current_branch\"; \
    }; f"

    missing-files2 = "!f() { \
        local current_branch=$(git current-branch); \
        local other_branch=${1:-$(git main-branch)}; \
        IFS=$'\n'; \
        missing_files_to_current=($(git diff --name-only \"$other_branch\"..\"$current_branch\")); \
        unset IFS; \
        total_missing_files=${#missing_files_to_current[@]}; \
        printf \"$(tput bold)Files missing in '%s' but present in '%s':$(tput sgr0) %d files\\n\" \"$other_branch\" \"$current_branch\" \"$total_missing_files\"; \
        for file in \"${missing_files_to_current[@]}\"; do \
            echo \"$file\"; \
        done; \
    }; f"

    missing-files-name-only = "!f() { \
        local current_branch=$(git rev-parse --abbrev-ref HEAD); \
        local other_branch=${1:-$(git main-branch)}; \
        git diff --name-only \"$other_branch\"...\"$current_branch\"; \
    }; f"

    # 50 most recent commits.
    # XXX this is a summary?
    graph = log -50 --branches --tags --remotes --date-order --format=format:'%C(yellow)%h %C(reset) %<(75,trunc)%s <%cn> (%cr) %C(red)%d' --graph

    # Show log as a graph
    glog = log --all --graph

    # Usage: git releases
    # Display a decorated Git commit history graph, excluding merge commits.
    releases = log --no-merges --all --simplify-by-decoration --graph

    # Usage: git hist
    # Display a Git commit history graph in tree format.
    hist = log --graph

    # Usage: git lgf
    # Display a Git commit history graph with file change status and custom formatting.
    hist-full = log --pretty=format:'%C(green)%cr%C(reset) %C(yellow)%h%Creset %C(yellow)%d%Creset %s %C(bold blue)<%an>%Creset%n' --graph --name-status

    # Draw Git revisions graph with Graphviz.
    graphviz = "!f() { \
        echo 'digraph git {' ; \
        git log -25 --pretty='format:  %h -> { %p }' \"$@\" \
            | sed 's/[0-9a-f][0-9a-f]*/\"&\"/g' ; \
        echo '}'; \
    }; f"

    contributors-name  = shortlog -n -s --no-merges --
    contributors-email = shortlog -n -s -e --no-merges --

    whois = "!sh -c 'git log -1 --author=\"$1\" -i --pretty=\"format:%an <%ae>\n\"' -"

    pull-request-bb = "!f() { \
        USER_NAME=\"$1\"; \
        curl --user $USER_NAME https://bitbucket.org/$(git repo-owner)/$(git repo-slug-remote)/pull-requests/new?source=$(git current-branch)&t=1; \
    }; f"

    pr-list = XXX

    # For GitHub.
    pr-checkout-gh = "!f() { \
        git fetch $(git origin) pull/\"$1\"/head:pr/\"$1\" \
            && git checkout pr/\"$1\"; \
    }; f"
    # https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/checking-out-pull-requests-locally

    # For GitLab.
    pr-checkout-gl = "!f() { \
        git fetch $(git origin) merge-requests/\"$1\"/head:pr/\"$1\" \
            && git checkout pr/\"$1\"; \
    }; f"
    # https://about.gitlab.com/blog/2016/12/08/git-tips-and-tricks/#add-an-alias-to-checkout-merge-requests-locally

    # For GitHub.
    mpr = "!f() { \
        declare current_branch=\"$(git current-branch)\"; \
        declare BRANCH=\"${2:-$current_branch}\"; \
        if [ $(printf \"%s\" \"$1\" | grep '^[0-9]\\+$' > /dev/null; printf $?) -eq 0 ]; then \
            git fetch $(git origin) refs/pull/\"$1\"/head:pr/\"$1\" \
                && git checkout -B $BRANCH \
                && git rebase $BRANCH pr/\"$1\" \
                && git checkout -B $BRANCH \
                && git merge --ff-only pr/\"$1\" \
                && git delete-local-branch pr/\"$1\"; \
        fi \
    }; f"

    # Merge given pull request into the current branch.
    # The commit message will have the same for as if done using the
    # merge button on github.com
    # Example:
    #   git merge-pr $(git origin) 5
    merge-pr = "!sh -c '\
        USER_AND_REPO=$(git remote show $1 | grep \"Fetch URL:\" | sed -E \"s/.*github.com[:\\/]([a-zA-Z_\\-]+)\\/([a-zA-Z_\\-]+)\\.git$/\\1 \\2/\"); \
        USER=$(echo $USER_AND_REPO | cut -d\" \" -f1); \
        REPO=$(echo $USER_AND_REPO | cut -d\" \" -f2); \
        TMP_FILE=$(mktemp); \
        curl -si https://api.github.com/repos/$USER/$REPO/pulls/$2 > $TMP_FILE; \
        PULL_AUTHOR=$(cat $TMP_FILE | awk \"{if (/ *\\\"head\\\"/) head=\\\\$1; if (/ *\\\"login\\\": \\\"/) value=\\\\$2}{if (head && value) print value; if (head && value) exit}\" | sed -E \"s/\\\"([^\\\"]+)\\\".*/\\1/\"); \
        PULL_REF=$(cat $TMP_FILE | awk \"{if (/ *\\\"head\\\"/) head=\\\\$1; if (/ *\\\"ref\\\": \\\"/) label=\\\\$2}{if (head && label) print label; if (head && label) exit}\" | sed -E \"s/\\\"([^\\\"]+)\\\".*/\\1/\"); \
        PULL_TITLE=$(cat $TMP_FILE | grep \"\\\"title\\\": \" | sed \"s/^ *\\\"title\\\": \\\"//\" | sed \"s/\\\",$//\"); \
        rm $TMP_FILE; \
        git fetch $1 pull/$2/head; \
        git merge --no-ff -m \"Merged pull request #$2 from $PULL_AUTHOR/$PULL_REF\n\n$PULL_TITLE\" FETCH_HEAD; \
        ' -"

    pr-clean = "!f() { \
        git delete-local-branch pr/\"$1\"; \
    }; f"

    pr-show = XXX <pr-number>

    related-pr-of-commit = "!sh -c 'git log --merges --ancestry-path $1..master \
                | tail -n 1 ' -"

    # Usage: git release VERSION
    # Release a new version of your project.
    release = "!f() { \
        git tag -a v\"$1\" -m \"Release version $1\" \
            && git push $(git origin) --tags \
            && git push $(git origin); \
    }; f"

    # Usage: git manifest
    # Print a list of version controlled files for the current revision.
    manifest = ls-files

    # Usage: git changelog [FIRST_TAG_NAME] [LAST_TAG_NAME] XXX
    # Detailed list of changes.
    changelog1 = "!f() { \
        git log --no-merges ${1-$(git last-tag)}..$2; \
    }; f"
    changelog = !sh -c 'git log --no-merges --pretty=format:\"* %s\" $(git last-tag)...' -
    changelog-org = !sh -c 'git log --no-merges --pretty=format:\"- %s\" $(git last-tag)...' -

    # le dernier tag, ainsi que la liste des commits ayant eu lieu depuis sur la
    # branche courante.
    unreleased = !git log $(git last-tag)...HEAD \
                && git last-tag

    current-tag = tag --points-at HEAD
    zip = "!f() { \
        git archive --format=zip -o $(git current-tag).zip HEAD; \
    }; f"

    # Usage: git export-branch
    # Export the changes of the current branch as a .diff file.
    export-branch = "!f() { \
        local current_branch=$(git current-branch); \
        git format-patch --stdout $current_branch > ~/$current_branch.diff; \
    }; f"

    # Usage: git zip-changed-files
    # Create a compressed archive (ZIP) of the files modified in the current Git branch compared to the main branch.
    zip-changed-files = "!f() { \
        local current_branch=$(git current-branch); \
        local main_branch=$(git main-branch || echo 'main'); \
        local changed_files=$(git diff --name-only $main_branch..$current_branch); \
        zip ~/$current_branch-changed-files.zip $changed_files; \
        echo 'Exported changed files saved as $current_branch-changed-files.zip'; \
    }; f"

    export-zip = archive -o latest.zip
    export-tgz = archive -o latest.tar.gz -9

    # Usage: git export-commit [COMMIT_ISH]
    # Create an archive of a commit.
    export-commit = "!f() { \
        git changed-files ${1:-HEAD} \
            | tr '\\n' '\\0' \
            | xargs -0 zip -9 $(git repo-slug-remote)-commit-$(git current-branch-without-slash)-${1:-$(git commit-hash)}.zip; \
    }; f"

    # View raw commit.
    email-patch = XXX git format-patch $(git current-branch-without-slash).patch

    # Since oldest ancestor...
    plain-diff = !git branch-diff > $(git current-branch-without-slash).diff

    patch-for-this = "!git diff -p $(git hash-object -t tree /dev/null)"

    # Check if any file in repo has whitespace errors
    # As described in http://peter.eisentraut.org/blog/2014/11/04/checking-whitespace-with-git/
    check-whitespace = diff-tree --check $(git hash-object -t tree /dev/null) HEAD
    whitespace-violations = "!git diff --check $(git hash-object -t tree /dev/null)"

    # Check if any file in repo has windows line endings
    # Currently do not work as alias, works from comand line directly. There is a problem with \r
    check-eol = grep --files-with-matches $'\\r' HEAD

rsync-deploy =

# Deploy a branch to review server (https://review-feature-1.example.com).
deploy-review =

# Deploy master to staging server (https://staging.example.com).
deploy-staging =

# Deploy master to production server (https://example.com).
deploy-prod =

  # # Deploy
  # staging = !git push heroku-staging $(git current-branch):master -f && git track 'Deployed to staging ' # push current branch to staging, can add more comments after
  # dev = !git push heroku-dev $(git current-branch):master -f && git track 'Deployed to dev ' # push current branch to dev
  # deploy = !git push heroku $(git current-branch):master -f && git track 'Deployed to production ' # push current branch to production

# shipit = push heroku master

 # deploy='git push production master && terminal-notifier-notify -title "Deploy" -message "Deploy complete"'
 # stage='git push staging $(git current-branch):master'

# title
# description
# assignee
# kind
# priority
    create-issue = XXX

    create-issue-pull-request = XXX

    # issues = "!f() { \
    #     USER_NAME=\"$1\"; \
    #     curl --user $USER_NAME \
    #         https://api.bitbucket.org/2.0/repositories/$(git repo-owner)/$(git repo-slug-remote)/issues \
    #         | jq -C --compact-output '.values | .[] | [.id, .title, .type, .priority, .state, .votes, .assignee.display_name, .created_on, .updated_on]' \
    #         | sed -r 's/(....)-(..)-(..)T(..):(..):(..).(............)/\\1-\\2-\\3/g' \
    #         | sed \"s/new/NEW/\" \
    #         | sed \"s/NEW/$(tput setaf 2) -- NOUVEAU -- $(tput sgr0)/\" \
    #         | sed \"s/NEW/\$(tput setaf 3) -NOUV- \$(tput sgr0)/\" \
    #         | sed \"s/open/OPEN/\" \
    #         | sed \"s/closed/CLOSED/\"; \
    # }; f"
# --data-urlencode 'priority >= \"major\"'

    issues-open = !git issues | grep "open"

    issues-assigned-to-me = !git issues | grep "$(git config --get user.name)"

    # Usage: git show-issue ISSUE_NUMBER
    show-issue = "!f() { \
        REPO_OWNER=\"YourUsername\"; \
        REPO_SLUG_REMOTE=\"YourRepository\"; \
        ISSUE_NUMBER=\"$1\"; \
        URL=\"https://github.com/$REPO_OWNER/$REPO_SLUG_REMOTE/issues/$ISSUE_NUMBER\"; \
        open \"$URL\"; \
    }; f"

    browse-issues = "!f() { \
        URL=$(git config --get remote.$(git origin).url); \
        xdg-open ${URL/.git}/issues/\"$1\"; \
    }; f"

    # List JIRA issue keys from commit messages.
    issue-keys = "!f() { \
        echo 'Printing JIRA issue keys'; \
        git log \"$@\" \
            | egrep -o '[A-Z]+-[0-9]+' \
            | sort -u; \
    }; f"

    browse-wiki = "!f() { \
        URL=$(git config --get remote.$(git origin).url); \
        xdg-open ${URL/.git}/wiki; \
    }; f"

    # Put everything in the current repo in a Zip archive.
    download-repository = "!f() { \
        git archive ${1:-HEAD} --format=zip -o $(basename $(git root))-commit-$(git rev-parse ${1:-HEAD}).zip; \
    }; f"
# XXX Test it with tag or branch.

    # Print repository name, execute command, and separate output.
    print-repo-info = "!f() { \
        repo_slug_local=$(git repo-slug-local); \
        printf '\\033[1m%s\\033[0m\\n' \"$repo_slug_local\"; \
        git "$@"; \
        printf '\\n\\n'; \
    }; f"

    # Usage: git all-repos COMMAND [ARGS]
    # Run a command for each repository in the current directory.
    all-repos = "!f() { \
        ls -R -d */.git \
            | sed 's#/.git##' \
            | xargs -I{} git -C {} print-repo-info \"$@\"; \
    }; f"

    # Usage: git pull-all-repos
    # Pull the changes in all Git repositories of the current directory.
    pull-all-repos = !$HOME/bin/git-pull-all-repos

    # Usage: git push-all-repos
    # Push the changes in all Git repositories of the current directory.
    push-all-repos = !$HOME/bin/git-push-all-repos

    # Execute shell command and show output.
    x = "!exec "

    # Interactive rebase with the given number of latest commits
    ireb = "!f() { \
        git rebase -i HEAD~\"$1\"; \
    }; f"

    # Start an interactive rebase of all the commits you haven't pushed
    # yet. Handy for collapsing a bunch of work-in-progress snapshots into
    # logical commits before pushing, without having to worry about accidentally
    # squashing a commit someone else has already referred to.
    work-in-progress = rebase -i @{u}

    # Usage: git st
    # Display the current status of the repository with branch names.
    st = status -s -b

    # Usage: git diff-latest [FILE]
    # Show differences between the latest commit and the current working state.
    # Examples:
    #     git diff-latest           # Show differences for all files
    #     git diff-latest file.txt  # Show differences only for "file.txt"
    diff-latest = !"git diff-index --quiet HEAD -- || clear; \
            git --no-pager diff --patch-with-stat"

    # Usage: git diff-commits NUMBER
    # Show the differences between the state `NUMBER' commits ago and the current working state.
    # Example: git diff-commits 2
    diff-commits = "!f() { \
        if [ $# -ne 1 ]; then \
            printf \"Usage: git diff-commits NUMBER\\n\"; \
            return 2; \
        fi; \
        git diff --patch-with-stat HEAD~$1; \
        git diff-index --quiet HEAD -- || clear; \
    }; f"

    # Ignore whitespace when comparing the same lines. This indicates empty
    # lines added or deleted.
    diff-ignore-whitespace = diff -w

    # Diff line-wise.
    df = diff

    # Diff word-wise.
    dw = diff --color-words

    # Configure git-diff to produce the absolutely most minimal diff possible.
    dw-min = diff -w --word-diff-regex=. --color-words -U0

    # Show minimal differences in changes between working directory and the most recent commit, ignoring whitespace.
    wdiff = diff --diff-algorithm=minimal -w

    # Diff staged line-wise.
    df-staged = diff --cached

    # Diff staged word-wise.
    dw-staged = diff --color-words --cached

    # Show minimal differences in changes between staged changes and the most recent commit, ignoring whitespace.
    swdiff = diff --diff-algorithm=minimal -w --cached

    # Usage: git first-modified-date FILENAME
    # Show the date of the first modification of a file.
    first-modified-date = "!f() { \
        date=$(git log --all --follow --pretty=format:%ci -- \"$1\" | tail -n 1); \
        echo \"$date\"; \
    }; f"

    first-modified-date2 = "!f() { \
        date=$(git log --all --follow --pretty=format:%ci --full-history -- \"$1\" | tail -n 1); \
        echo \"$date\"; \
    }; f"

    first-modified-date3 = "!f() { \
        git log --follow --format=%ai -- \"$1\" | tail -1; \
    }; f"

    # When was this file last updated, on each local branch.
    wwflu = "!f() { \
        local local_branches=$(git local-branches); \
        for branch in $local_branches; do \
            echo -e \"$(git log --decorate=no -1 \
                                --format=\"%at:%C(green)%ad%C(reset) %C(yellow)%h%C(auto)%d%C(reset) %s %C(bold blue)<%an>%C(reset)\" \
                                --color=always $branch -- \"$1\")  On branch $(tput bold)$branch$(tput sgr0)\"; \
        done | sort -r; \
    }; f"

    stage-modified-removed-files = add -u

    # Usage: git ls
    # Print a summary of activity.  Alias of log.
    ls = log

    ll = log --pretty=medium --abbrev-commit --stat

    # Usage: git last
    # Return the last commit on the current branch.
    last = log -1 --stat

    # Usage: git lastn [N]
    # Show the last N commits on the current branch.
    lastn = "!f() { \
        git show --name-only $(git rev-list -${1:-1} HEAD); \
    }; f"

    # lastn2 = "!f() { \
    #     git log -${1:-1} --stat $(git rev-list -${1:-1} HEAD); \
    # }; f"

    # Usage: git file-history FILENAME
    # Show the commit history of a specific file.
    file-history = log --

    # Usage: git file-history-follow-copy-without-merge-commits FILENAME
    # Show commit history with file copies and renames.
    file-history-follow-copy-without-merge-commits = log --follow --date-order -C
    # ... BUT WITHOUT MERGE COMMITS

    # Usage: git file-history-follow-copy FILENAME
    # Show commit history of a file, including copies, renames, and merges.
    file-history-follow-copy = log --follow --date-order -C --find-renames --merges

    # Usage: git file-history-all FILENAME
    # Show commit history for all branches.
    file-history-all = log --all

    # Usage: git file-last-modified FILENAME
    # Show the most recent commit across all branches in date order.
    file-last-modified = log -n 1 --all --date-order

    # Usage: git related FILENAME
    # Show all commits that modified a specific file, including the commit
    # message and file list.
    related = "!f() { \
        git show --name-only $(git rev-list HEAD -- \"$1\"); \
    }; f"

    # Usage: git related-files FILENAME
    # Generate a list of which files changed together with a file.
    related-files = !sh -c 'git log --format=format:%H $0 \
                | xargs -L 1 git diff-tree --no-commit-id --name-only -r \
                | sort \
                | uniq -c \
                | sort -b -n -r \
                | less'

    praise = blame -w
    archeology = blame -w -C -n

    # Given a merge commit, find the span of commits that exist(ed).
    # Not so useful in itself, but used by other aliases.
    # Thanks to Rob Miller for the merge-span-* aliaes.
    merge-span = "!f() { \
        echo $(git log -1 --merges --pretty=format:%P $2 | cut -d' ' -f1)\"$1\"$(git log -1 --merges --pretty=format:%P $2 | cut -d' ' -f2); \
    }; f"

    # Find the commits that were introduced by a merge
    merge-span-log = "!f() { \
        git log $(git merge-span .. \"$1\"); \
    }; f"

    # Show the changes that were introduced by a merge
    merge-span-diff = "!f() { \
        git diff $(git merge-span ... \"$1\"); \
    }; f"

    # Show the changes that were introduced by a merge, in your difftool
    merge-span-difftool = "!f() { \
        git difftool $(git merge-span ... \"$1\"); \
    }; f"

    # Show a list of existing remotes (with URL).
    r = remote -v

    # Usage: git incoming
    # Show new commits found in the remote repository.
    incoming = "!git fetch \
        && git log HEAD..@{u}"
    # TODO: Add optional argument BRANCH_NAME, and delete alias incoming-on-branch

    # Alias of 'incoming'.
    in = !git incoming

    # Show log of new commits after you fetched, with stats, excluding merges
    log-fresh = log --no-merges --stat ORIG_HEAD..

    # Usage: git incoming-on-branch BRANCH_NAME
    # Show new commits found in the remote repository.
    # Example: git incoming-on-branch master
    incoming-on-branch = !sh -c 'git fetch' \
                && git log ..$(git origin)/$1

    # Usage: git who-is-changing-branch BRANCH_NAME
    who-is-changing-branch = !sh -c 'git shortlog HEAD..$(git origin)/$0'
    # TODO: Add fetch?

    incoming-files = !(git fetch \
                && git diff --stat ...@{u})

    # Alias of 'incoming-files'.
    in-files = !git incoming-files

    incoming-diff = diff @{u} HEAD
    # diff with upstream branch

    # Get everything new.
    update = !git pull                     && git submodule update --init --recursive
    get    = !git pull --rebase            && git submodule update --init --recursive
    update = !git pull --rebase --prune $@ && git submodule update --init --recursive

    # Pull in remote changes for the current repository and all its submodules
    p = !"git pull; git submodule foreach git pull $(git origin) master"

    # Retrieve the timestamp of the most recent pull operation, regardless of changes being present.
    latest-pull-time = "!f() { \
        local fetch_head_time=$(stat -c %y $(git root)/.git/FETCH_HEAD | cut -d'.' -f1); \
        printf \"Latest pull time: %s\\n\" \"$fetch_head_time\"; \
    }; f"
    # For the latest pull (even if there's nothing new).

    # Retrieve the timestamp of the last update to your current branch from the remote master branch, considering changes received.
    latest-update-time = "!f() { \
        local current_branch=$(git current-branch); \
        local update_time=$(stat -c %y $(git root)/.git/refs/heads/$current_branch | cut -d'.' -f1); \
        printf \"Latest update time for branch '%s': %s\\n\" \"$current_branch\" \"$update_time\"; \
    }; f"
    # For the latest pull resulting in changes coming in from the remote master
    # branch (the timestamp won't change when git pull reports there are no
    # changes).

    # Pull the latest changes for the current branch from its remote counterpart.
    pull-current = "!git pull $(git origin) $(git current-branch)"

    # Push the current branch to its remote counterpart.
    push-current = "!git push $(git origin) $(git current-branch)"

    # Pull and push the latest changes for the current branch.
    pull-and-push--current = "!f() { \
        pull-current && push-current; \
    }; f"

    # Update repository by pulling changes from remote and pushing local commits.
    pull-and-push = !git pull && git push

    # Avoid a fast-forward commit.
    mnf = merge --no-ff --log

    # Usage: git merge-into-main
    # Merge the current branch into the 'main' branch and returns to the original branch.
    merge-into-main = "!f() { \
        local current_branch=\"$(git current-branch)\"; \
        if [ -z \"$current_branch\" ]; then \
            current_branch=\"(unnamed branch)\"; \
        fi; \
        git checkout $(git main-branch) \
            && git merge \"$current_branch\" \
            && git checkout \"$current_branch\"; \
    }; f"

    # Usage: git merge-update-push TARGET_BRANCH
    # Merge changes from the current branch into the specified target branch, updates it, and pushes changes.
    merge-update-push = "!f() { \
        local current_branch=\"$(git current-branch)\"; \
        local target_branch=\"$1\"; \
        git checkout \"$target_branch\" \
            && git pull \
            && git merge \"$current_branch\" \
            && git push \
            && git checkout \"$current_branch\"; \
    }; f"

    # Run merge test (before merge) to check for any conflicts beforehand.
    merge-test = "!f() { \
        git merge --no-commit --no-ff \"$1\"; \
        git merge --abort; \
        echo \"Merge aborted\"; \
    }; f"

    # Usage: git merge-dry-run BRANCH_NAME
    # Check how the merge of BRANCH_NAME into master will go
    merge-dry-run = "!f() { \
        grep -q 'changed in both' <<< $(git merge-tree $(git merge-base FETCH_HEAD \"$1\") FETCH_HEAD \"$1\") \
            && echo 'Merge conflicts!' \
            || echo 'This branch can be automatically merged.'; \
    }; f"
# XXX DOESN'T work for git fetch & git merge

    # Extract the "changed in both" lines as well as the conflicting parts.
    merge-dry-run-conflicts = "!f() { \
        git merge-tree $(git merge-base \"$1\" $2) \"$1\" $2 \
            | sed -n '/+<<<<<<< .our/,/+>>>>>>> .their/p;/^changed in both/{n;N;N;s/^/#/mg;p}' \
            | cdiff; \
    }; f"

    ours = "!f() { \
        git checkout --ours $@ \
            && git add $@; \
    }; f"

    theirs = "!f() { \
        git checkout --theirs $@ \
            && git add $@; \
    }; f"

    # Usage: git conflicts
    # List files with conflicts.
    conflicts = diff --name-only --diff-filter=U

    edit-unmerged = "!$EDITOR $(git conflicts)"

    add-unmerged = "!git add $(git conflicts)"

    # Create a feature branch.
    feature = "!f() { \
        git create-branch feature/\"$1\" develop; \
    }; f"
    # XXX or feature-start?

    # Incorporate a finished feature on develop.
    feature-finish = "!f() { \
        git checkout develop; \
        git merge --no-ff feature/\"$1\" \
            && git delete-local-branch feature/\"$1\"; \
    }; f"

    # XXX Also bug and refactor.

    # XXX release-start
    # XXX release-finish

    # Shortcut for checkout.
    co = checkout

    next = "!f() { \
        git checkout $(git rev-list --topo-order HEAD..master | tail -1); \
    }; f"

    # "show-branch -g=N" can't be aliased for N easily, so we stop here:
    sb  = show-branch
    # pg sbt master pu -- if the last line is 'master' and not 'master~'
    # or 'master~N' then pu is a descendent of master
    sbt = show-branch --topics
    sbs = show-branch --sha1-name

    # Usage: git outgoing
    # Show (unpushed) commits not found in the remote branch.
    outgoing = log @{u}..HEAD

    # Alias of 'outgoing'.
    out = !git outgoing

    outgoing-files = diff --stat @{u}...

    # Alias of 'outgoing-files'.
    out-files = !git outgoing-files

    # Usage: git outgoing-all
    # Show commits not found in the destination repository.
    outgoing-all = log --branches --not --remotes

    # Alias of 'outgoing-all'.
    out-all = !git outgoing-all

    # Usage: git divergence BRANCH_NAME
    divergence = "!f() { \
        git log --cherry-pick --left-right --graph \"$1\"...$(git origin)/\"$1\"; \
    }; f"

    # Usage: git sha1-tag COMMIT
    sha1-tag = "!f() { \
        git name-rev --name-only \"$@\"; \
    }; f"

    lll = log -u

    # Apply a patch to files and/or to the index from URL.
    apply-url = "!f() { \
        curl -s \"$1\" 2>nul \
            | git apply ${@:2}; \
    }; f"

    # Apply a series of patches from an URL.
    am-url = "!f() { \
        curl -s \"$1\" 2>nul \
            | git am ${@:2}; \
    }; f"

    # Interactive apply patch.
    ipatch = "!f() { \
        git apply \"$1\"; \
        git add -p; \
    }; f"

    # Usage: git today [AUTHOR]
    today = "!f() { \
        git log \
            --since=midnight \
            --author=\"${1-$(git config --get user.name)}\" \
            --no-merges \
            --all \
            --pretty='%C(green)%ad%C(auto) - %s%C(auto)%d' \
            --date=format:'%Y-%m-%d %a %H:%M'; \
    }; f"

    # Usage: git yesterday [AUTHOR]
    yesterday = "!f() { \
        git log \
            --since='1 day ago midnight' --until=midnight \
            --author=\"${1-$(git config --get user.name)}\" \
            --no-merges \
            --all \
            --pretty='%C(green)%ad%C(auto) - %s%C(auto)%d' \
            --date=format:'%Y-%m-%d %a %H:%M'; \
    }; f"

    # Usage: git this-week [AUTHOR]
    this-week = "!f() { \
        git log \
            --since='1 week ago' \
            --author=\"${1-$(git config --get user.name)}\" \
            --no-merges \
            --all \
            --pretty='%C(green)%ad%C(auto) - %s%C(auto)%d' \
            --date=format:'%Y-%m-%d %a %H:%M'; \
    }; f"

    # Usage: git standup [AUTHOR]
    # Summarize changes since 24h, suitable for a daily standup meeting.
    standup = "!f() { \
        git log \
                --branches \
                --since=$(if [ \"$(date +%a)\" = \"Mon\" ]; then \
                              echo \"friday\"; \
                          else \
                              echo \"yesterday\"; \
                          fi) \
                --author=\"${1-$(git config --get user.name)}\" \
                --format=format:'%C(green)%ad%C(reset) - %s%C(auto)%d' \
                --date=format:'%Y-%m-%d %a %H:%M'; \
    }; f"

    # Enable comprehensive debugging output.
    debug = "!set -x; GIT_TRACE=2 GIT_CURL_VERBOSE=2 GIT_TRACE_PERFORMANCE=2 GIT_TRACE_PACK_ACCESS=2 GIT_TRACE_PACKET=2 GIT_TRACE_PACKFILE=2 GIT_TRACE_SETUP=2 GIT_TRACE_SHALLOW=2 git"

    cp = cherry-pick -x
    pick = cherry-pick -s

    # cherry-pick - apply the changes introduced by some existing commits; useful for moving small chunks of code between branches.
    cp = cherry-pick

    # cherry-pick without making a commit, and when when recording the commit, append a line that says "(cherry picked from commit ...)"
    cp-nx = cherry-pick --no-commit -x

    root = rev-parse --show-toplevel
    root-relative = rev-parse --show-prefix

    # Usage: git commit-interactive FILENAME...
    # Interactively stage changes and commit, or abort.
    commit-interactive = !sh -c '(git add -p -- $@ && git commit) || git reset' --

    # Alias of 'commit-interactive'.
    record = !git commit-interactive

    lost = "!git fsck \
                | awk '/dangling commit/ {print $3}' \
                | git show --format='SHA-1: %C(yellow)%h%C(reset)  %s' --stdin \
                | awk '/SHA-1/ {sub(\"SHA-1: \", \"\"); print}'"

    # Show a graph of the commit history, including dangling commits (not reachable by any reference).
    dangling-graph-log = !git log --all --pretty=oneline --abbrev-commit --graph \
                    $(git fsck --no-reflogs | grep commit | cut -d\\  -f3)

[include]
    path = .gitconfig_local
