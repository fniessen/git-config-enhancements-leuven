# -*- mode: conf -*-
# .gitconfig, Time-stamp: <20250801.1138>

[checkout]
    # Preserve timestamps of checked out files.
    preserveTimestamps = true

[user]
    # Override with your name and email in the file .gitconfig.
    name = John Doe
    email = john.doe@example.com

[github]
    # Override with your GitHub username in the file .gitconfig.
    user = jdoe

[fetch]
    # Remove remote-tracking references that no longer exist on the remote.
    prune = true

[init]
    # Set the default branch for new repositories to main.
    defaultBranch = main

[merge]
    # Show a three-way diff in case of conflicts.
    conflictstyle = diff3

[merge]
    # Use meld as the merge tool.
    tool = meld

[mergetool "meld"]
    # Run meld with the required arguments.
    cmd = meld --diff "$LOCAL" "$MERGED" "$REMOTE" --diff "$BASE" "$LOCAL" --diff "$BASE" "$REMOTE" --output "$MERGED"
    # cmd = meld --diff "$LOCAL" "$BASE" "$REMOTE" --diff "$BASE" "$LOCAL" --diff "$BASE" "$REMOTE" --output "$MERGED"
    # Don't keep backup files.
    keepBackup = false

[difftool]
    # Set prompt to false to avoid asking for confirmation before launching the diff tool.
    prompt = false

[diff]
    tool = meld

[difftool "meld"]
    # Set the command to launch "meld" with the two input files as arguments.
    cmd = meld "$LOCAL" "$REMOTE"

[core]
    # editor = notepad++.exe -multiInst -notabbar -nosession -noPlugin

    # editor = sh -c 'command -v $GIT_EDITOR > /dev/null 2>&1 && exec $GIT_EDITOR || echo "Please install $GIT_EDITOR or set another editor"'
    # # (No editor name displayed!)
    # # Aborting commit due to empty commit message.

    # editor = sh -c 'command -v emacsclient > /dev/null 2>&1 && echo emacsclient || echo "No suitable editor found. Please install Emacs."'
    # # emacsclient
    # # Aborting commit due to empty commit message.

    # editor = sh -c 'for cmd in emacsclient emacs; do command -v $cmd > /dev/null 2>&1 && exec $cmd && echo "Using $cmd as the editor." && break; done; echo "No suitable editor found. Please install Emacs."'
    # # Syntax error: Unterminated quoted string

    # editor = sh -c 'for cmd in emacsclient emacs; do command -v $cmd > /dev/null 2>&1 && exec $cmd && echo \"Using $cmd as the editor.\" && break; done; echo \"No suitable editor found. Please install Emacs.\"'
    # # Syntax error: Unterminated quoted string

    # Set Emacsclient as the default editor.
    editor = emacsclient -a emacs

    # Set Git pager to ignore ^M and use less with custom flags.
    # (git-grep to ignore ^M)
    pager = tr -d '\\r' | less -REX

    # Set whitespace configuration to only warn about carriage return at the end of the line.
    whitespace = cr-at-eol
    # whitespace = fix,-indent-with-non-tab,trailing-space,space-before-tab,cr-at-eol

    # Set Git pager to use less with custom flags and diff-so-fancy.
    pager = "!sh -c '~/bin/git-pager'"
    pager = "!f() { \
        if command -v diff-so-fancy > /dev/null 2>&1; then \
            printf 'Using diff-so-fancy pager\n' && diff-so-fancy | LESS=less --tabs=4 -FRX \"$@\"; \
        else \
            printf 'Using default pager\n' && LESS=less --tabs=4 -FRX \"$@\"; \
        fi; \
    }; f"
    pager = LESS= less --tabs=4 -FRX

[core]

    # Enable parallel filesystem operations.
    preloadindex = true

    # Enable file system caching to avoid UAC issues.
    fscache = true

[gc]
    # Optimize for repositories with many files.
    auto = 256

[help]
    # Enable autocorrect for mistyped commands.
    autocorrect = 1

[log]
    # Use short date format for log messages.
    date = short

    # Use short format for ref names (e.g. branch or tag names).
    decorate = short

[diff]
    # Treat file renames as copies.
    renames = copies

    # Set the limit of similarity for considering a file rename.
    renameLimit = 30000

    # Use the patience diff algorithm for generating patches.
    algorithm = patience

[diff "zebra"]
    # Use dimmed zebra coloring to highlight moved lines in a diff.
    colorMoved = dimmed_zebra

[diff "header"]
    # Include mnemonic prefixes in diff hunk headers.
    mnemonicprefix = true

    # Don't show any prefix in diff hunk headers.
    noprefix = true

[apply]
    # Don't detect whitespace errors when applying a patch.
    whitespace = nowarn

[status]
    submoduleSummary = true

[push]
    # Only push the current branch to its upstream branch.
    default = simple

[merge]
    # Show a diffstat of what changed in the merge.
    stat = true

    # Provide a summary of the merge, including affected files and commit messages.
    summary = true

    # Include summaries of merged commits in newly created merge commit messages.
    log = true

[rebase]
    # Enable the display of a diffstat when rebasing, showing what changed
    # during the rebase.
    stat = true

[grep]
    # Show line numbers in the results.
    lineNumber = true

    # # Allow extended regular expressions
    # extendedRegexp = true

    # Display the full path of matching files in the results.
    fullName = true

[color]
    ui = auto
    branch = auto
    diff = auto
    status = auto
    interactive = auto

[color "branch"]
    current = cyan bold
    local = green bold
    remote = red bold
    upstream = red bold
    plain = yellow reverse

[color "diff"]
    plain = "#888888"
    meta = 11
    frag = magenta bold
    func = "#cc99cc"
    old = red bold
    new = green bold
    commit = yellow
    whitespace = red reverse

[diff-so-fancy]
    useUnicodeRuler = true

[color "diff-highlight"]
    oldNormal = red bold
    oldHighlight = red bold 52
    newNormal = green bold
    newHighlight = green bold 22

[color "status"]
    header = normal
    added = green bold
    changed = yellow bold
    untracked = cyan
    branch = cyan bold
    nobranch = bold ul blink 12
    unmerged = red reverse bold

[color "grep"]
    context = "#888888"
    filename = yellow bold
    function = red
    linenumber = magenta bold
    match = green reverse bold
    matchContext = yellow reverse bold
    matchSelected = yellow bold blue
    separator = red bold
    selected = white

[format]
    pretty = format:%C(green)%ad%C(reset) %C(yellow)%h%C(reset) %s%C(auto)%d%C(reset) %C(bold cyan)<%an>%C(reset)

# https://dev.to/megamattmiller/the-git-aliases-that-get-me-to-friday-1cmj
[custom.formats]
    ls = "[%C(auto,yellow)%<|(10)%h%C(reset)] [%C(auto,bold blue)%<(15trunc)%cn%C(reset)]  %C(auto)%d% C(reset)%s"
    find = "[%C(yellow)%<|(20)%h%C(reset)] [%C(bold blue)%<(10)%cn%C(reset)]  %C(auto)%d %C(reset)  %s"
    graph = "%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset) %C(yellow)%d%C(reset)%n %C(white)%s%C(reset)%n %C(dim white)- %an <%ae> %C(reset) %C(dim white)(committer: %cn <%ce>)%C(reset)"

[alias]

    ##? Usage: git aliases
    ##?
    ##? List all Git aliases in alphabetical order.
    aliases = "!f() { \
        git config -l \
            | grep '^alias\\.' \
            | cut -c 7- \
            | sort \
            | sed 's_=_ = _' \
            | sed 's/  */ /g' \
            | awk -F ' = ' '{printf \"\\033[1m%s\\033[0m = %s\\n\", $1, $2}'; \
    }; f"

    ##? Usage: git grep-aliases PATTERN
    ##?
    ##? List all Git aliases in alphabetical order and highlight the matching pattern.
    grep-aliases = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git grep-aliases PATTERN\n'; \
            return 64; \
        fi; \
        PATTERN=\"$1\"; \
        git aliases | grep --color=auto -i \"$PATTERN\"; \
    }; f"

    work-profile = config user.email \"john@work.com\"

    ##? Usage: git whoami
    ##?
    ##? Display the current git user's name and email.
    whoami = "!f() { \
        name=\"$(git config user.name)\"; \
        email=\"$(git config user.email)\"; \
        printf '%s <%s>\n' \"$name\" \"$email\"; \
    }; f"

    ##? Usage: git init-repository
    ##?
    ##? Initialize a new Git repository with an initial commit.
    init-repository = "!f() { \
        git init || { \
            printf >&2 'ERROR: git init failed. Aborting.\n'; \
            return 2; \
        }; \
        if [ -z \"$(ls -A)\" ]; then \
            touch .gitignore; \
        fi; \
        git add . || { \
            printf >&2 'ERROR: git add failed.\n'; \
            return 2; \
        }; \
        git commit -m 'Initial commit' || { \
            printf >&2 'ERROR: git commit failed.\n'; \
            return 2; \
        }; \
    }; f"

    ##? Usage: git cl
    ##?
    ##? Clone a repository recursively, including all submodules.
    cl = clone --recursive

    ##? Usage: git origin
    ##?
    ##? Get the default remote name, defaulting to 'origin' if not set.
    origin = "!f() { \
        default_remote_name=$(git config --get clone.defaultRemoteName); \
        printf \"%s\n\" \"${default_remote_name:-origin}\"; \
    }; f"
    ### git remote show
    ### git rev-parse --abbrev-ref @{u}
    ### git rev-parse --symbolic-full-name --abbrev-ref @{u} | sed 's!/! !g' | awk '{print $1}'

    ##? Usage: git repo-owner
    ##?
    ##? Get the owner of the repository from the remote URL.
    repo-owner = "!f() { \
        remote_name=$(git origin); \
        remote_url=$(git config --get remote.$remote_name.url); \
        git remote show $remote_url -n \
            | grep 'Fetch URL:' \
            | sed -E 's_^.*[/:](.*)/.*$_\\1_' \
            | sed 's_\\.git$__'; \
    }; f"

    ##? Usage: git repo-slug-remote
    ##?
    ##? Get the repository slug from the remote URL.
    repo-slug-remote = "!f() { \
        remote_name=$(git origin); \
        remote_url=$(git config --get remote.$remote_name.url); \
        git remote show $remote_url -n \
            | awk -F/ '/Fetch URL:/{print $NF}' \
            | sed 's_\\.git$__'; \
    }; f"

    ##? Usage: git repo-slug-local
    ##?
    ##? Get the repository slug from the local directory name.
    repo-slug-local = "!f() { \
        repo_name=$(basename \"$(git root)\"); \
        printf \"%s\n\" \"$repo_name\"; \
    }; f"

    ##? Usage: git main-branch
    ##?
    ##? Get the name of the main branch, regardless of whether it is called 'main' or 'master'.
    main-branch = "!f() { \
        if git show-ref --verify --quiet refs/heads/main; then \
            printf 'main\n'; \
        else \
            printf 'master\n'; \
        fi \
    }; f"
    # Note: The alias
    # main-branch = "!git symbolic-ref refs/remotes/$(git origin)/HEAD \
    #     | sed 's_^refs/remotes/$(git origin)/__'"
    # generates the error message
    # "fatal: ref refs/remotes/origin/HEAD is not a symbolic ref"
    # when the remote repository does not have a default branch.
    ### git symbolic-ref --short refs/remotes/origin/$(git rev-parse --abbrev-ref @{u})

    ##? Usage: git st
    ##?
    ##? Show the status in short format with branch info.
    st = status -s -b

    ##? Usage: git search-for-files PATTERN
    ##?
    ##? List all files in the current branch matching a case-insensitive search
    ##? pattern.
    ##?
    ##? Arguments:
    ##?   PATTERN                       Pattern
    search-for-files = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git search-for-files PATTERN\n'; \
            return 64; \
        fi; \
        PATTERN=\"$1\"; \
        git ls-tree -r --name-only HEAD \
            | grep -i --color=auto \"$PATTERN\"; \
    }; f"

    ##? Alias for 'search-for-files'.
    find-files = search-for-files

    ##? Usage: git search-for-files-all-branches PATTERN
    ##?
    ##? Search for a specific file in all local branches.
    ##?
    ##? Arguments:
    ##?   PATTERN                       The name of the file to search for in
    ##?                                 all local branches.
    search-for-files-all-branches = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git search-for-files-all-branches PATTERN\n'; \
            return 64; \
        fi; \
        PATTERN=\"$1\"; \
        git remote-branches \
            | grep -v HEAD \
            | while read -r branch_name; do \
                  printf \"\n$(tput bold)$(tput setaf 2)$branch_name:$(tput sgr0)\n\"; \
                  git ls-tree -r --name-only \"$branch_name\" | \
                  nl -bn -w3 | \
                  grep --color=auto \"$PATTERN\"; \
              done; \
    }; f"

    ##? Alias for 'search-for-files-all-branches'.
    find-files-all-branches = search-for-files-all-branches

    find-files-all-branches2 = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git find-files-all-branches2 PATTERN\n'; \
            return 64; \
        fi; \
        for branch in $(git remote-branches | grep -v HEAD); do \
            if git ls-tree -r \"$branch\" --name-only \
                   | grep -q \"$1\"; then \
                echo \"Found in $branch\"; \
            fi; \
        done; \
    }; f"

    # Usage: git search-for-code PATTERN [TREE]
    #
    ##? Perform a case-insensitive search for "pattern" in all tracked files,
    ##? displaying line numbers, context around matches, and file headers.
    ##?
    ##? Example:
    ##?   git search-for-code "pattern"
    search-for-code = "!git --no-pager grep -i -I --line-number --break --heading -C 1"

    # Alias for 'search-for-code'.
    ack = search-for-code

    # Usage: git search-for-code-in-extension EXTENSION PATTERN
    #
    # Search for a specific code pattern in files with a given extension across
    # all local branches.
    #
    # Arguments:
    #   EXTENSION                      The file extension to search within.
    #   PATTERN                        The code pattern to search for.
    search-for-code-in-extension = "!f() { \
        if [ $# -ne 2 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git search-for-code-in-extension EXTENSION PATTERN\n'; \
            return 64; \
        fi; \
        EXTENSION=\"$1\"; \
        PATTERN=\"$2\"; \
        git local-branches | \
        while read -r branch_name; do \
            printf \"\n$(tput bold)$(tput setaf 2)Branch: $branch_name$(tput sgr0)\n\"; \
            git grep -n -- \"$PATTERN\" \"$branch_name\" -- \":*.$EXTENSION\"; \
        done; \
    }; f"

    # Usage: git grep-all SEARCH_TERM
    # Search for a string in all Git-tracked files.
    grep-all = "!f() { \
        git rev-list --all \
          | xargs git grep \"$1\"; \
    }; f"
    # Issue: This will search ALL COMMITS, not just all files, and will generate
    # MANY DUPLICATES.
    # Suggestion: Add a warning in the docstring, or use a different approach if
    # you want to search all files in ALL BRANCHES.

    # Usage: git gno PATTERN [TREE]
    # Search for a pattern in all tracked filenames, ignoring case and binary
    # files.
    gno = "grep -i -I --name-only"

    ##? Usage: git unmodify [FILE_TO_RESTORE]
    ##?
    ##? Undo local modifications for a specific file or all files if no file is
    ##? provided.
    ##?
    ##? Examples:
    ##?   git unmodify                  Restore all modified files.
    ##?   git unmodify .                Restore all modified files in the
    ##?                                 current directory.
    ##?   git unmodify PATH/TO/FILE     Restore a specific modified file.
    unmodify = "!f() { \
        if [ $# -gt 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git unmodify [FILE_TO_RESTORE]\n'; \
            return 64; \
        fi; \
        FILE_TO_RESTORE=\"$1\"; \
        if [ -z \"$FILE_TO_RESTORE\" ]; then \
            git status --porcelain \
                | grep -E '^ M' \
                | sed 's_^ M __' \
                | xargs -I {} git checkout -- \"{}\" || true; \
        else \
            if git status --porcelain \"$FILE_TO_RESTORE\" | grep -qE '^ M'; then \
                git checkout -- \"$FILE_TO_RESTORE\"; \
            else \
                printf >&2 \"ERROR: File '%s' is not modified.\n\" \"$FILE_TO_RESTORE\"; \
                return 2; \
            fi; \
        fi; \
    }; f"

    ##? Usage: git undelete [FILE_TO_RESTORE]
    ##?
    ##? Restore deleted files for a specific file or all files if no file is
    ##? provided.
    ##?
    ##? Examples:
    ##?   git undelete                  Restore all deleted files.
    ##?   git undelete .                Restore all deleted files in the current
    ##?                                 directory.
    ##?   git undelete PATH/TO/FILE     Restore a specific deleted file.
    undelete = "!f() { \
        if [ $# -gt 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git undelete [FILE_TO_RESTORE]\n'; \
            return 64; \
        fi; \
        FILE_TO_RESTORE=\"$1\"; \
        if [ -z \"$FILE_TO_RESTORE\" ]; then \
            git status --porcelain \
                | grep -E '^ D' \
                | sed 's_^ D __' \
                | xargs -I {} git checkout -- \"{}\" || true; \
        else \
            if git status --porcelain \"$FILE_TO_RESTORE\" | grep -qE '^ D'; then \
                git checkout -- \"$FILE_TO_RESTORE\"; \
            else \
                printf >&2 \"ERROR: File '%s' is not deleted.\n\" \"$FILE_TO_RESTORE\"; \
                return 2; \
            fi; \
        fi; \
    }; f"

    # Usage: git unstage [FILENAME...]
    # Unstage the changes to a file that were previously added to the Git
    # staging area.
    unstage = reset HEAD --

    # Usage: git staged-files
    # List files that are staged (added, modified, or deleted) and ready to be committed.
    staged-files = diff --cached --name-only

    # Usage: git added-files
    # List files that have been added but not yet committed.
    added-files = diff --cached --name-only --diff-filter=A

    # Usage: git modified-files
    # List files that have been modified in the working tree.
    modified-files = diff --name-only --diff-filter=M

    # Usage: git deleted-files
    # List files that have been deleted in the working directory.
    deleted-files = ls-files --deleted

    ##? Usage: git ignored-and-untracked-files
    ##?
    ##? List both ignored and untracked files.
    ignored-and-untracked-files = ls-files --others

    # Usage: git backup-ignored-and-untracked-files
    # Create a backup archive of all ignored and untracked files in the repository.
    backup-ignored-and-untracked-files = "!f() { \
        repo_slug_remote=\"$(git repo-slug-remote)\"; \
        current_date=$(date +'%Y-%m-%d'); \
        backup_filename=\"$repo_slug_remote-$current_date-untracked.zip\"; \
        git ignored-and-untracked-files -z \
            | xargs -0 tar rvf ~/$backup_filename; \
    }; f"

    ##? Usage: git untracked-files
    ##?
    ##? List untracked files, excluding Git-ignored files.
    untracked-files = ls-files --others --exclude-standard

    ##? Usage: git ignored-files
    ##?
    ##? List only ignored files.
    ignored-files = ls-files --others --ignored --exclude-standard

    # Usage: git tracked-files
    # List all tracked files in the repository, sorted by last modification time.
    tracked-files = ls-files -t

    ##? Usage: git ignore PATTERN
    ##?
    ##? Add a pattern to .gitignore.
    ignore = "!f() { \
        PATTERN=\"$1\"; \
        if [ -z \"$PATTERN\" ]; then \
            printf >&2 'ERROR: No pattern provided.\\nUsage: git ignore PATTERN\\n' >&2; \
            return 2; \
        fi; \
        if [ ! -e .gitignore ]; then \
            touch .gitignore; \
        fi; \
        printf '%s\\n' \"$PATTERN\" >> .gitignore; \
    }; f"

    ##? Usage: git ignore-untracked
    ##?
    ##? Add all untracked files to .gitignore except .gitignore itself.
    ignore-untracked = "!f() { \
        git ls-files --others --exclude-standard \
            | grep -vF .gitignore \
            >> \"${GIT_PREFIX}.gitignore\"; \
    }; f"
    ignore-untracked2 = "!f() { \
        git status --porcelain \
            | grep '^??' \
            | cut -c 4- \
            | grep -vF .gitignore \
            >> \"${GIT_PREFIX}.gitignore\"; \
    }; f"

    ##? Usage: git skip FILE
    ##?
    ##? Mark a file as unchanged and hide it from the Git status.
    skip = update-index --assume-unchanged

    ##? Usage: git unskip FILE
    ##?
    ##? Revert the hidden status of a file, allowing it to be tracked again by
    ##? Git.
    unskip = update-index --no-assume-unchanged

    ##? Usage: git skip-all
    ##?
    ##? Ignore all files currently marked as changed in Git status.
    skip-all = "!git status -z -s \
            | awk 'BEGIN { RS=\"\\0\"; ORS=\"\\0\" } { print $2 }' \
            | xargs -0 git skip"

    ##? Usage: git unskip-all
    ##?
    ##? Revert the hidden status of all files currently marked as unchanged in Git
    ##? status, allowing them to be tracked again by Git.
    unskip-all = "!git skipped \
            | tr '\\n' '\\0' \
            | xargs -0 git unskip"

    ##? Usage: git skipped
    ##?
    ##? List all files currently marked as unchanged and hidden from Git status.
    skipped = "!git ls-files -v \
            | grep '^h' \
            | cut -c 3-"

    # Usage: git clean-untracked
    # Remove all untracked files (like 'hg purge --unknown').
    clean-only-untracked = clean -f -d

    ##? Usage: git clean-only-ignored
    ##?
    ##? Remove only ignored files and directories.
    clean-only-ignored = clean -f -d -X
    # THIS COMMAND MAY DELETE FILES THAT CANNOT BE RECOVERED.

    ##? Usage: git clean-only-ignored-dry-run
    ##?
    ##? Display files and directories that would be removed by git
    ##? clean-only-ignored.
    clean-only-ignored-dry-run = clean --dry-run -d -X

    ##? Usage: git clean-all
    ##?
    ##? Remove all ignored and untracked files and directories.
    clean-all = clean -f -d -x
    # THIS COMMAND MAY DELETE FILES THAT CANNOT BE RECOVERED.

    ##? Usage: git clean-all-dry-run
    ##?
    ##? Display files and directories that would be removed by git clean-all.
    clean-all-dry-run = clean --dry-run -d -x

    ##? Usage: git stash-all
    ##?
    ##? Stash all modified and untracked files.
    stash-all = "!f() { \
        git stash push --include-untracked -m 'Stash modified and untracked files'; \
    }; f"

    ##? Usage: git stash-only-untracked
    ##?
    ##? Stash only the untracked files (like 'hg shelve --unknown').
    stash-only-untracked = "!f() { \
      untracked=$(git ls-files --others --exclude-standard -z); \
      [ -z \"$untracked\" ] && printf '%s\\n' 'No untracked files to stash' && exit 0; \
      printf \"%s\" \"$untracked\" | xargs -0 git update-index --add --intent-to-add && \
      git stash push -m 'Stash only untracked files' && \
      git reset; \
    }; f"

    ##? Usage: git remove-deleted
    ##?
    ##? Remove all files that have been deleted from the working directory but
    ##? are still staged in Git.
    remove-deleted = "!f() { \
        git ls-files --deleted -z \
            | xargs -0 git rm; \
    }; f"

    # Usage: git stash-push
    # Stash changes in the working directory for later retrieval.
    stash-push = stash push

    # Usage: git stash-all
    # Stage all changes and untracked files, then creates a stash.
    stash-all = !git add -A \
                && git stash

    # Usage: git stash-include-untracked
    # Stash changes, including untracked files, for later retrieval.
    stash-include-untracked = stash push --include-untracked

    # Usage: git snapshot
    # Create a snapshot stash with a timestamp and immediately apply it.
    snapshot = !git stash push -m "snapshot-$(date +'%F_%H-%M')" \
                && git stash apply "stash@{0}"

    # Usage: git checkpoint
    # Create a new temporary stash with a timestamp and restore staged changes.
    checkpoint = !git stash push -m "$(date +%F-%H-%M)" \
                && git stash pop --index

    # Usage: git checkpoint-recover [TIME_INTERVAL]
    # Display a formatted log of recent version changes with timestamps and commit messages.
    # Example: git checkpoint-recover 1week
    checkpoint-recover = "!f() { \
        git fsck \
            | grep commit \
            | cut -d' ' -f3 \
            | while read HASH; do \
                  git rev-parse --verify --no-revs --quiet $HASH^2 2> /dev/null \
                      && echo $HASH \
                      | xargs git rev-list --since=${1:-1day} -1; \
              done \
            | xargs -L 1 git log -1 --format=%at:%h \
            | sort \
            | cut -f2 -d: \
            | xargs -L 1 git log -3 --format='%Cblue%h %Cgreen(%ar) %Creset%s' --graph; \
    }; f"

    ##? Usage: git stashes
    ##?
    ##? List stashes with their short creation dates, or output "Nothing stashed" to stderr if none.
    stashes = "!f() { \
        stash_list=\"$(git stash list --date=short)\"; \
        if [ -z \"$stash_list\" ]; then \
            printf \"$(tput setaf 2)%s$(tput sgr0)\" \"Nothing stashed\"; \
        fi; \
        printf \"$(tput setaf 1)%s$(tput sgr0)\n\" \"$stash_list\"; \
    }; f"

    # Usage: git stash-view
    # Show the changes introduced by the latest stash in a unified diff format.
    stash-view = stash show -p
    # Instead of unshelving the changes, show the diff that would result from
    # unshelving.

    ##? Usage: git stash-show STASH_NAME
    ##?
    ##? Show the contents of a specified stash in patch format.
    stash-show = "!f() { \
        git stash show stash^{/$@} -p; \
    }; f"

    stash-shno = stash show --name-only

    # Usage: git stash-apply [STASH_INDEX]
    # Apply a specific stash to the working directory.
    stash-apply = "!f() { \
        if [ -z \"$1\" ]; then \
            git stash apply; \
        else \
            git stash apply stash@{\"$1\"}; \
        fi \
    }; f"
    # Apply changes but don't delete them.

    # Find stash with name like text.
    stash-apply2 = "!f() { \
        git stash apply stash^{/$@}; \
    }; f"

    # Revert the changes introduced by the most recent stash.
    stash-revert = !git stash show -p --no-textconv --binary \
            | git apply -R

    # Usage: git find-stash-id [SEARCH_STRING]
    # Find the stash ID by searching stash descriptions for a specific string.
    find-stash-id = "!f() { \
        git stash list \
            | grep $@ \
            | head -n 1 \
            | sed -n 's_stash@{\\(.*\\)}.*_\\1_p'; \
    }; f"
    # Only accepts single word, no quotations.

    # Usage: git pop-stash [STASH_INDEX_OR_ID]
    # Appliy and remove the specified stash by index or ID.
    stash-pop = "!f() { \
        git stash pop stash@{$(git find-stash-id $@)}; \
    }; f"

    # Usage: git unstash [STASH_INDEX]
    # Apply the most recent stash and removes it from the stash stack.
    # Apply and remove a specific stash from the stash stack.
    unstash = "!f() { \
        if [ -z \"$1\" ]; then \
            git stash pop; \
        else \
            git stash pop stash@{\"$1\"}; \
        fi \
    }; f"

    # Usage: git stash-remove [STASH_INDEX]
    # Remove a specific stash from the stash stack without applying changes.
    stash-remove = stash drop

    # Usage: git stashes-clear
    # Remove all stashes from the stash stack.
    stashes-clear = "!git stash list \
            | cut -d: -f1 \
            | xargs -r -I {} git stash-remove {}"

    praise = blame -w
    archeology = blame -w -C -n

    ##? Usage: git ci -m "MESSAGE"
    ##?
    ##? Record changes to the repository.
    ##?
    ##? Alias for 'commit'.
    ci = commit

[commit]
    template = ~/.git_commit_template.txt

[alias]

    # Usage: git commit-interactive FILENAME...
    # Interactively stage changes and commit, or abort.
    commit-interactive = "!f() { \
        if [ \"$(git root)\" != \"$(pwd)\" ]; then \
            printf >&2 'ERROR: Not at the root of the Git repository.\n'; \
            return 2; \
        fi; \
        (git add -p -- \"$@\" && git commit) || git reset; \
    }; f"

    # Alias for 'commit-interactive'.
    record = commit-interactive

    ##? Show current commit of current branch.
    local-commit = "!git rev-parse @"

    ##? Usage: git ls
    ##?
    ##? Display the commit log.  Alias for 'log'.
    ls = log

    ##? Usage: git ll
    ##?
    ##? Show commit log with file statistics.
    ll = log --pretty=medium --abbrev-commit --stat

    ##? Usage: git log-unified-diff
    ##?
    ##? Show commit log with unified diffs.
    log-unified-diff = log -u

    ##? Alias for 'log-unified-diff'.
    lll = log-unified-diff

    # Usage: git last
    # Return the last commit on the current branch.
    last = log -1 --stat

    # Usage: git lastn [N]
    # Show the last N commits on the current branch.
    lastn = "!f() { \
        git show --name-only $(git rev-list -${1:-1} HEAD); \
    }; f"

    # lastn2 = "!f() { \
    #     git log -${1:-1} --stat $(git rev-list -${1:-1} HEAD); \
    # }; f"

    ##? Usage: git file-history FILE_PATH
    ##?
    ##? Show the commit history of a specific file or directory.
    file-history = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git file-history FILE_PATH\n'; \
            return 64; \
        fi; \
        FILE_PATH=\"$1\"; \
        if ! git ls-tree -r HEAD --name-only 2> /dev/null | grep -q \"^$FILE_PATH$\"; then \
            printf >&2 \"\\e[1;33mWarning: File '%s' not found in the current branch of the repository.\\e[0m\n\" \"$FILE_PATH\"; \
        fi; \
        git log --follow -- \"$FILE_PATH\" 2> /dev/null; \
    }; f"

    # Usage: git file-history-follow-copy-without-merge-commits FILENAME
    # Show commit history with file copies and renames.
    file-history-follow-copy-without-merge-commits = log --follow --date-order -C
    # ... BUT WITHOUT MERGE COMMITS

    # Usage: git file-history-follow-copy FILENAME
    # Show commit history of a file, including copies, renames, and merges.
    file-history-follow-copy = log --follow --date-order -C --find-renames --merges

    ##? Usage: git file-history-all-branches FILE_PATH
    ##?
    ##? Show the commit history of a specific file or directory across all branches.
    file-history-all-branches = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git file-history-all-branches FILE_PATH\n'; \
            return 64; \
        fi; \
        FILE_PATH=\"$1\"; \
        if ! git ls-tree -r HEAD --name-only 2> /dev/null | grep -q \"^$FILE_PATH$\"; then \
            printf >&2 \"\\e[1;33mWarning: File '%s' not found in the current branch of the repository.\\e[0m\n\" \"$FILE_PATH\"; \
        fi; \
        git log --follow --all -- \"$FILE_PATH\" 2> /dev/null; \
    }; f"

    ##? Usage: git related-history FILE_PATH
    ##?
    ##? Show all commits that modified a specific file, including the commit message and file list.
    ##?
    ##? NOTE:
    ##?   "rename from" files are not included in the output of this command.
    related-history = "!f() { \
        FILE_PATH=\"$1\"; \
        if [ ! -e \"$FILE_PATH\" ]; then \
            printf >&2 \"ERROR: File '%s' not found in the working tree.\n\" \"$FILE_PATH\"; \
            return 2; \
        fi; \
        git show --name-only $(git rev-list HEAD -- \"$FILE_PATH\"); \
    }; f"

    # DEBUG version:
    # related-files = "!f() { \
    #     if [ ! -e \"$1\" ]; then \
    #         echo \"ERROR: File '$1' not found in the working tree.\"; \
    #         return 2; \
    #     fi; \
    #     hashes=$(git --no-pager log --format=format:%H -- \"$1\"); \
    #     echo \"\nHashes: \n$hashes\"; \
    #     files=$(echo \"$hashes\" | xargs -I % sh -c 'echo \"Processing hash: %\" && git diff-tree --no-commit-id --name-only -r % && echo \"\";'); \
    #     echo \"\nFiles: \n$files\"; \
    #     sorted_files=$(echo \"$files\" | sort); \
    #     echo \"\nSorted Files: \n$sorted_files\"; \
    #     unique_files=$(echo \"$sorted_files\" | uniq -c | sort -b -n -r); \
    #     echo \"\nUnique Files: \n$unique_files\"; \
    # }; f"

    ##? Usage: git related-files FILE_PATH
    ##?
    ##? Generate a list of which files changed together with a file.
    related-files = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git related-files FILE_PATH\n'; \
            return 64; \
        fi; \
        FILE_PATH=\"$1\"; \
        if [ ! -e \"$FILE_PATH\" ]; then \
            printf >&2 \"ERROR: File '%s' not found in the working tree.\n\" \"$FILE_PATH\"; \
            return 2; \
        fi; \
        printf \"Unique Files:\n\"; \
        git log --format=format:%H -- \"$FILE_PATH\" \
            | xargs -L 1 git diff-tree --no-commit-id --name-only -r \
            | sort \
            | uniq -c | sort -b -n -r; \
    }; f"

    ##? Usage: git file-last-commit FILE_PATH
    ##?
    ##? Show the last commit that modified the specified FILE_PATH.
    file-last-commit = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git file-last-commit FILE_PATH\n'; \
            return 64; \
        fi; \
        FILE_PATH=\"$1\"; \
        git log -n 1 --all --date-order -- \"$FILE_PATH\"; \
    }; f"

    ##? Usage: git file-last-commits FILE_PATH
    ##?
    ##? Show the most recent commits for a specific file or directory across all local branches.
    file-last-commits = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git file-last-commits FILE_PATH\n'; \
            return 64; \
        fi; \
        FILE_PATH=\"$1\"; \
        local_branches=$(git local-branches); \
        for branch in $local_branches; do \
            printf \"$(git log --decorate=no -1 \
                               --format=\"%at:%C(green)%ad%C(reset) %C(yellow)%h%C(auto)%d%C(reset) %s %C(blue)<%an>%C(reset)\" \
                               --color=always $branch -- \"$FILE_PATH\") $(tput bold)$branch$(tput sgr0)\n\"; \
        done | sort -r | sed 's#^[0-9]*:##g'; \
    }; f"

    ##? Alias for 'file-last-commits'.
    wwflu = file-last-commits

    file-last-commits2 = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git file-last-commits2 FILE_PATH\n'; \
            return 64; \
        fi; \
        FILE_PATH=\"$1\"; \
        git for-each-ref --format=\"%(refname:short) %(objectname)\" refs/heads/ | \
        while read branch commit_hash; do \
            commit_info=$(git log -n 1 \
                                    --pretty=format:'\\e[32m%ad \\e[33m%h \\e[0m%s \\e[34m<%an>\\e[0m' \
                                    --date=format-local:'%Y-%m-%d' \"$commit_hash\" -- \"$FILE_PATH\"); \
            if [ -n \"$commit_info\" ]; then \
                printf \"%s \\e[32;1m%s\\e[0m\n\" \"$commit_info\" \"$branch\" \
            fi; \
        done | sort -k1,1r; \
    }; f"

    # Usage: git changed-files [COMMIT_HASH]
    # Show all files modified in each commit, including merge commits.
    # Examples:
    #   git changed-files             List files modified in last commit
    #   git changed-files bada55      List files modified in the commit with hash 'bada55'
    changed-files = "!f() { \
        COMMIT_HASH=${1:-HEAD}; \
        git diff --name-only $COMMIT_HASH^..$COMMIT_HASH; \
    }; f"

    # Show commit with word-wise diff.
    wshow = show --color-words

    # Show commit with minimal (char-level), whitespace-insensitive diff.
    minshow = show -w --word-diff-regex=. --color-words -U0

    # Usage: git download-email-patch
    # Generate a patch file for the current branch using the git format-patch command.
    download-email-patch = "!f() { \
        current_branch=$(git current-branch); \
        git format-patch $current_branch.patch; \
    }; f"

    # Usage: git download-commit-plain-diff [COMMIT_HASH]
    # Create a diff file for the changes in a commit or range of commits.
    download-commit-plain-diff = "!f() { \
        COMMIT_HASH=${1:-HEAD}; \
        git diff $COMMIT_HASH^..$COMMIT_HASH > $COMMIT_HASH.diff; \
    }; f"

    ##? Usage: git difftool-parent [COMMIT_HASH]
    ##?
    ##? Launch difftool for changes between specified commit and its parent.
    difftool-parent = "!f() { \
        COMMIT_HASH=${1:-HEAD}; \
        git difftool $COMMIT_HASH^..$COMMIT_HASH; \
    }; f"

    ##? Usage: git ediff-commit COMMIT_HASH FILE_PATH
    ##?
    ##? Compare FILE_PATH between the current version and COMMIT_HASH using
    ##? Emacs' ediff.
    ediff-commit = "!f() { \
        COMMIT_HASH=\"$1\"; \
        FILE_PATH=\"$2\"; \
        current_file=\"$FILE_PATH\"; \
        git show ${COMMIT_HASH}:\"$FILE_PATH\" > /tmp/ediff-temp-${COMMIT_HASH}; \
        emacs --eval \"(ediff-files \\\"$current_file\\\" \\\"/tmp/ediff-temp-${COMMIT_HASH}\\\")\"; \
        rm /tmp/ediff-temp-${COMMIT_HASH}; \
    }; f"

    ##? Usage: git difftool-last-modified FILE_PATH
    ##?
    ##? Compare the current version of FILE_PATH with its state in the last
    ##? commit that modified it, using difftool.
    difftool-last-modified = "!f() { \
        FILE_PATH=\"$1\"; \
        last_modified_commit_hash=$(git rev-list -1 HEAD -- \"$FILE_PATH\"); \
        git difftool \"$last_modified_commit_hash\"^ -- \"$FILE_PATH\"; \
    }; f"

    ##? Usage: git diff-stat [FILE]
    ##?
    ##? Show changes with statistics (between working directory and index) if
    ##? there are any.
    ##?
    ##? Examples:
    ##?   git diff-stat                 Show differences for all files.
    ##?   git diff-stat file.txt        Show differences only for "file.txt".
    diff-stat = "!f() { \
        git diff-index --quiet HEAD -- || clear; \
        git diff --patch-with-stat; \
    }; f"

    ##? Usage: git diff-commits-ago NUMBER [FILE]
    ##?
    ##? Show diff (with stats) between HEAD and the state `NUMBER' commits ago.
    ##? Optionally, specify a FILE to show differences for a specific file.
    ##?
    ##? Examples:
    ##?   git diff-commits-ago 2        Show differences between HEAD and
    ##?                                 2 commits ago for all files.
    ##?   git diff-commits-ago 2 file.txt
    ##?                                 Show differences for "file.txt" between
    ##?                                 HEAD and 2 commits ago.
    diff-commits-ago = "!f() { \
        if [ $# -lt 1 ] || [ $# -gt 2 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git diff-commits-ago NUMBER [FILE]\n'; \
            return 64; \
        fi; \
        if [ $# -eq 2 ]; then \
            git diff --patch-with-stat HEAD~$1 -- \"$2\"; \
        else \
            git diff --patch-with-stat HEAD~$1; \
        fi; \
        git diff-index --quiet HEAD -- || clear; \
    }; f"

    # Ignore whitespace when comparing the same lines. This indicates empty
    # lines added or deleted.
    diff-ignore-whitespace = diff -w

    # Line-wise diff (working dir vs index).
    df = diff

    # Word-wise diff (working dir vs index).
    wdf = diff --color-words

    # Minimal (char-level), whitespace-insensitive diff (working dir vs index).
    mindf = diff -w --word-diff-regex=. --color-words -U0

    # Line-wise diff of staged changes (index vs HEAD).
    dfc = diff --cached

    # Word-wise diff of staged changes (index vs HEAD).
    wdfc = diff --color-words --cached

    # Minimal (char-level), whitespace-insensitive diff of stage changes (index vs HEAD).
    mindfc = diff -w --word-diff-regex=. --color-words -U0 --cached

    # Usage: git dir-diff
    # Open Meld with directory comparison for all modified files.
    dir-diff = difftool -t meld --dir-diff

    ##? Usage: git branches-containing COMMIT_HASH
    ##?
    ##? List all branches (including remote branches) that contain the specified
    ##? commit, sorted by the latest commit date.
    branches-containing = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git branches-containing COMMIT_HASH\n'; \
            return 64; \
        fi; \
        COMMIT_HASH=\"$1\"; \
        git branch --all --sort=-committerdate --contains \"$COMMIT_HASH\"; \
    }; f"

    ##? Usage: git tags-containing COMMIT_HASH
    ##?
    ##? List tags containing a specific commit, sorted by the most recent commit
    ##? date.
    tags-containing = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git tags-containing COMMIT_HASH\n'; \
            return 64; \
        fi; \
        COMMIT_HASH=\"$1\"; \
        git tag --contains \"$COMMIT_HASH\" \
            | while read tag; do \
                commit_hash=$(git rev-list -n 1 \"$tag\"); \
                commit_date=$(git log -1 --format='%ct' \"$commit_hash\"); \
                printf \"%s %s\n\" \"$commit_date\" \"$tag\"; \
            done | sort -n -r | awk '{print $2}'; \
        }; f"

    ##? Usage: git is-ancestor COMMIT1 COMMIT2
    ##?
    ##? Check if the first commit is an ancestor of the second commit.
    ##?
    ##? Arguments:
    ##?   COMMIT1                       The first commit to check for ancestry
    ##?   COMMIT2                       The second commit to check for ancestry
    is-ancestor = "!f() { \
        if [ $# -ne 2 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git is-ancestor COMMIT1 COMMIT2\n'; \
            return 64; \
        fi; \
        COMMIT1=\"$1\"; \
        COMMIT2=\"$2\"; \
        git merge-base --is-ancestor \"$COMMIT1\" \"$COMMIT2\"; \
    }; f"

    ##? Usage: git commits-by [AUTHOR]
    ##?
    ##? Show all commits by a specific author, defaulting to the current user's
    ##? email if not provided.
    ##?
    ##? Examples:
    ##?   git commits-by                Show commits by the current user.
    ##?   git commits-by "Author Name"  Show commits by a specific author.
    ##?   git commits-by "author@example.com"
    ##?                                 Show commits by a specific author.
    commits-by = "!f() { \
        AUTHOR=\"${1:-$(git config --get user.email)}\"; \
        git log \
            --all \
            -i --author=\"$AUTHOR\" \
            --no-merges; \
    }; f"

    # Search through all commit logs for multiple patterns (case-insensitive)
    # across all branches.
    #
    # Example: git find-commit-messages-any-all-branches "pattern1" "pattern2" "pattern3"
    # See also git find-commit-messages-any PATTERN... (for current branch!!!)
    find-commit-messages-any-all-branches = "!f() { \
        if [ $# -eq 0 ]; then \
            printf >&2 'ERROR: No search pattern provided\n'; \
            return 2; \
        fi; \
        git log --all -i $(printf -- '--grep=%s ' \"$@\"); \
    }; f"

    # Usage: git find-commit-messages-any PATTERN...
    #
    # Search for commit messages that match any of the provided patterns (OR logic, like in BitBucket).
    #
    # This will search commit messages for the provided patterns and list the
    # matching commits.
    # (FOR CURRENT BRANCH ONLY!!!)
    find-commit-messages-any = "!f() { \
        if [ $# -eq 0 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git find-commit-messages-any PATTERN...\n'; \
            return 64; \
        fi; \
        for PATTERN in \"$@\"; do \
            git log --grep=\"$PATTERN\" -i --format=\"%at:%C(green)%ad%C(reset) %C(yellow)%h%C(auto)%d%C(reset) %s %C(bold blue)<%an>%C(reset)\" --color=always; \
            printf \"\n\"; \
        done | sort -r | sed 's/^[^:]*://'; \
    }; f"
    # XXX Add all, date short...

    # Usage: git find-commit-messages-all PATTERN...
    #
    # Search for commits that match all provided patterns in commit messages (AND logic, like in Gitlab).
    #
    # This will search commit messages for the provided patterns and list the
    # matching commits.
    # (FOR CURRENT BRANCH ONLY!!!)
    find-commit-messages-all = "!f() { \
        if [ $# -eq 0 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git find-commit-messages-all PATTERN...\n'; \
            return 64; \
        fi; \
        CMD=\"git log --all-match -i --format='%at:%C(green)%ad%C(reset) %C(yellow)%h%C(auto)%d%C(reset) %s %C(bold blue)<%an>%C(reset)' --color=always\"; \
        for PATTERN in \"$@\"; do \
            CMD=\"$CMD --grep='$PATTERN'\"; \
        done; \
        eval $CMD | sort -r | sed 's/^[^:]*://'; \
    }; f"

    ##? Usage: git find-commit-diffs REGEXP [PATH]
    ##?
    ##? Search Git log for a specific regular expression and show the patch. The
    ##? path can be a file, directory, or file pattern (e.g., *.txt). If no path
    ##? is specified, the entire repository is searched.
    ##? Shows patches where the regular expression is added, removed, or
    ##? modified.
    ##?
    ##? Examples:
    ##?   git find-commit-diffs "fix" "*.js"
    ##?   git find-commit-diffs "bugfix"
    find-commit-diffs = "!f() { \
        if [ -n \"$2\" ]; then \
            git log -p -G \"$1\" \"$2\"; \
        else \
            git log -p -G \"$1\"; \
        fi \
    }; f"

    ##? Usage: git find-commit-diffs-all-branches REGEXP
    ##?
    ##? Search for changes containing a specific regular expression across all
    ##? branches.
    ##? Shows patches where the regular expression is added, removed, or
    ##? modified.
    find-commit-diffs-all-branches = "!f() { \
        git log --all -G \"$1\"; \
    }; f"

    # Usage: git search-all-commits SEARCH_TERM
    search-all-commits = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git search-all-commits SEARCH_TERM\n'; \
            return 64; \
        fi; \
        SEARCH_TERM=\"$1\"; \
        git rev-list --all | xargs git grep -F \"$SEARCH_TERM\"; \
    }; f"

    ##? Open the commits page of the origin remote repository in the default web
    ##? browser.
    browse-commits = "!sh -c ' \
        ORIGIN_URL=$(git config --get remote.origin.url); \
        COMMITS_URL=\"$ORIGIN_URL/commits\"; \
        OS=$(uname -s); \
        if [ \"$OS\" = \"Linux\" ]; then \
            xdg-open \"$COMMITS_URL\"; \
        elif [ \"$OS\" = \"Darwin\" ]; then \
            open \"$COMMITS_URL\"; \
        elif [ \"$OS\" = \"CYGWIN\" ] || [ \"$OS\" = \"MINGW\" ] || [ \"$OS\" = \"MSYS\" ]; then \
            start \"$COMMITS_URL\"; \
        else \
            printf \"Unsupported OS\\n\"; \
        fi \
    '"

    ##? Show upstream commit of current branch.
    upstream-commit = "!git rev-parse @{u}"

    # Append the staged changes to the last commit, reusing its message.
    amend-reuse = "!f() { \
        upstream_commit=$(git upstream-commit 2> /dev/null); \
        local_commit=$(git local-commit); \
        if [ -n \"$upstream_commit\" ] && [ \"$upstream_commit\" = \"$local_commit\" ]; then \
            printf >&2 'ERROR: The commit has already been pushed to the remote repository.\n'; \
            return 2; \
        fi; \
        git commit -v --amend --reuse-message HEAD; \
    }; f"

    ##? Usage: git amend-message NEW_COMMIT_MESSAGE
    ##?
    ##? Safely amend the last commit message, only if it hasnâ€™t been pushed.
    ##?
    ##? Example:
    ##?   git amend-message "Fix typo in README"
    amend-message = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git amend-message NEW_COMMIT_MESSAGE\n'; \
            return 64; \
        fi; \
        upstream_commit=$(git upstream-commit 2> /dev/null); \
        local_commit=$(git local-commit); \
        if [ -n \"$upstream_commit\" ] && [ \"$upstream_commit\" = \"$local_commit\" ]; then \
            printf >&2 'ERROR: The commit has already been pushed to the remote repository.\n'; \
            return 2; \
        fi; \
        git commit --amend -m \"$1\"; \
    }; f"

    # Alias for 'amend-message'.
    reword = amend-message

    ##? Usage: git amend-author NAME EMAIL
    ##?
    ##? Amend the last commit with a new author and reuse the commit message,
    ##? only if the commit has not been pushed.
    amend-author = "!f() { \
        if [ $# -ne 2 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git amend-author NAME EMAIL\n'; \
            return 64; \
        fi; \
        NAME=\"$1\"; \
        EMAIL=\"$2\"; \
        upstream_commit=$(git upstream-commit 2> /dev/null); \
        local_commit=$(git local-commit); \
        if [ -n \"$upstream_commit\" ] && [ \"$upstream_commit\" = \"$local_commit\" ]; then \
            printf >&2 'ERROR: The commit has already been pushed to the remote repository.\n'; \
            return 2; \
        fi; \
        git commit --amend --author=\"$NAME <$EMAIL>\" --reuse-message HEAD; \
    }; f"

    # Edit history.
    recommit2 = "!f() { \
        TARGET=$(git rev-parse \"$1\"); \
        git commit --fixup=$TARGET ${@:2} \
            && GIT_EDITOR=true git rebase --interactive --autostash --autosquash $TARGET~; \
    }; f"
    # See https://blog.filippo.io/git-fixup-amending-an-older-commit/

    # Checkout the commit in question, and amend its message.
    reword2 = "!f() { \
        current_branch=$(git current-branch); \
        git checkout \"$1\"; \
        git commit --amend; \
        git checkout $current_branch; \
    }; f"

    # Usage: git uncommit
    # Undo the most recent commit and keep the changes staged for commit again.
    uncommit = reset --soft HEAD~1

    # Usage: git uncommit-unstage
    # Undo the most recent commit and keep the changes made in the commit as
    # unstaged changes in the working directory.
    uncommit-unstage = reset --mixed HEAD~1

    # Usage: git undo
    # Undo the most recent commit and delete any changes made to the code since
    # then.
    undo = reset --hard HEAD~1

    ##? Usage: git squash NUM_OF_COMMITS_TO_UNDO
    ##?
    ##? Create a new commit that combines the changes introduced by the
    ##? specified number of previous unpushed commits.
    ##?
    ##? Falls back to 'git squash-force' if all checks pass.
    squash = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git squash NUM_OF_COMMITS_TO_UNDO\n'; \
            return 64; \
        fi; \
        if ! printf '%s' \"$1\" | grep -Eq '^[0-9]+$'; then \
            printf >&2 'ERROR: Argument must be a non-negative integer.\n'; \
            return 2; \
        fi; \
        NUM_OF_COMMITS_TO_UNDO=$1; \
        upstream_branch=$(git upstream-branch 2> /dev/null); \
        if [ -z \"$upstream_branch\" ]; then \
            printf >&2 'Warning: No upstream branch configured for the current branch.\n'; \
            printf >&2 'Consider using 'squash-force' alias.\n'; \
            return 2; \
        fi; \
        num_unpushed=$(git rev-list $upstream_branch..HEAD --count); \
        if [ $NUM_OF_COMMITS_TO_UNDO -le $num_unpushed ]; then \
            git squash-force $NUM_OF_COMMITS_TO_UNDO; \
        else \
            printf >&2 'ERROR: Cannot squash %d commits. There are only %d unpushed commits.\n' \
                   $NUM_OF_COMMITS_TO_UNDO $num_unpushed; \
            return 2; \
        fi; \
    }; f"

    ##? Usage: git squash-force NUM_OF_COMMITS_TO_UNDO
    ##?

    ##? Create a new commit that combines the changes introduced by the
    ##? specified number of previous commits, without safety checks.
    ##?
    ##? Use with caution: it rewrites history regardless of push state.
    squash-force = "!f() { \
        NUM_OF_COMMITS_TO_UNDO=$1; \
        COMMIT_MSG=$(git log --reverse --format=%B -n $NUM_OF_COMMITS_TO_UNDO); \
        git reset --soft HEAD~$NUM_OF_COMMITS_TO_UNDO \
            && git commit --edit -m \"$COMMIT_MSG\"; \
    }; f"

    # Interactively rebase a specified number of recent commits.
    ireb = "!f() { \
        git rebase -i HEAD~\"$1\"; \
    }; f"

    # Interactively rebase all commits that haven't been pushed to the upstream
    # branch.
    work-in-progress = rebase -i @{u}

    ##? Usage: git today [AUTHOR]
    ##?
    ##? Show today's commits.
    today = "!f() { \
        AUTHOR=\"${1-}\"; \
        if [ -z \"$AUTHOR\" ]; then \
            git log \
                --all \
                --since=midnight \
                --no-merges \
                --pretty='%C(green)%ad%C(auto) - %s%C(auto)%d %C(bold blue)<%an>%C(reset)' \
                --date=format:'%Y-%m-%d %a %H:%M'; \
        else \
            git log \
                --all \
                -i --author=\"$AUTHOR\" \
                --since=midnight \
                --no-merges \
                --pretty='%C(green)%ad%C(auto) - %s%C(auto)%d' \
                --date=format:'%Y-%m-%d %a %H:%M'; \
        fi; \
    }; f"

    ##? Usage: git yesterday [AUTHOR]
    ##?
    ##? Show yesterday's commits.
    yesterday = "!f() { \
        AUTHOR=\"${1-}\"; \
        if [ -z \"$AUTHOR\" ]; then \
            git log \
                --all \
                --since='1 day ago midnight' --until=midnight \
                --no-merges \
                --pretty='%C(green)%ad%C(auto) - %s%C(auto)%d %C(bold blue)<%an>%C(reset)' \
                --date=format:'%Y-%m-%d %a %H:%M'; \
        else \
            git log \
                --all \
                -i --author=\"$AUTHOR\" \
                --since='1 day ago midnight' --until=midnight \
                --no-merges \
                --pretty='%C(green)%ad%C(auto) - %s%C(auto)%d' \
                --date=format:'%Y-%m-%d %a %H:%M'; \
        fi; \
    }; f"

    ##? Usage: git recent [AUTHOR]
    ##?
    ##? Show commits from this week.
    recent = "!f() { \
        AUTHOR=\"${1-}\"; \
        if [ -z \"$AUTHOR\" ]; then \
            git log \
                --all \
                --since='1 week ago midnight' \
                --no-merges \
                --pretty='%C(green)%ad%C(auto) - %s%C(auto)%d %C(bold blue)<%an>%C(reset)' \
                --date=format:'%Y-%m-%d %a %H:%M'; \
        else \
            git log \
                --all \
                -i --author=\"$AUTHOR\" \
                --since='1 week ago midnight' \
                --no-merges \
                --pretty='%C(green)%ad%C(auto) - %s%C(auto)%d' \
                --date=format:'%Y-%m-%d %a %H:%M'; \
        fi; \
    }; f"

    # Usage: git standup [AUTHOR]
    # Summarize changes since 24h, suitable for a daily standup meeting.
    standup = "!f() { \
        AUTHOR=\"${1-$(git config --get user.name)}\"; \
        today=$(date +%a); \
        since; \
        if [ \"$today\" = \"Mon\" ]; then \
            since=\"last.Friday\"; \
        else \
            since=\"yesterday\"; \
        fi; \
        git log \
            --all \
            -i --author=\"$AUTHOR\" \
            --since=\"$since\" \
            --format=format:'%C(green)%ad%C(reset) - %s%C(auto)%d' \
            --date=format:'%Y-%m-%d %a %H:%M'; \
    }; f"

    ##? Cherry-pick a commit and add a note to the commit message indicating it
    ##? was cherry-picked.
    cp = cherry-pick -x
    # Append a line that says "(cherry picked from commit ...)".
    # Add a line "Cherry-picked commit" in the commit message.

    ##? Cherry-pick a commit (without committing it) and add a note to the
    ##? commit message.
    cp-no-commit = cherry-pick --no-commit -x
    # Apply the commit changes in the unstaged area (unstead of creating
    # a commit in the branch).

    ##? Usage: git create-branch BRANCH_NAME
    ##?
    ##? Create a new branch and switch to it in one step.
    create-branch = "!f() { \
        if [ $# -ne 1 ]; then \
            printf >&2 'Usage: git create-branch BRANCH_NAME\n'; \
            exit 64; \
        fi; \
        BRANCH_NAME=\"$1\"; \
        git checkout -b \"$BRANCH_NAME\"; \
    }; f"

    ##? Usage: git current-branch
    ##?
    ##? Get the current branch name.
    current-branch = "!f() { \
        branch_name=\"$(git branch --show-current 2> /dev/null)\"; \
        if [ -z \"$branch_name\" ]; then \
            printf >&2 'ERROR: Unable to determine current branch.\n'; \
            return 2; \
        fi; \
        printf '%s\n' \"$branch_name\"; \
    }; f"
    # Note: This is the most recent (v2.22+) and recommended way to get the
    # current branch name.
    # The alternative methods
    #     current-branch = rev-parse --abbrev-ref HEAD
    # and
    #     current-branch = symbolic-ref --short HEAD 2> /dev/null
    # are less readable, less convenient and less user-friendly.

    ##? Usage: git convert-current-branch-name
    ##?
    ##? Convert the current branch name by replacing slashes with hyphens.
    convert-current-branch-name = "!f() { \
        git current-branch \
            | tr '/' '-'; \
    }; f"

    ##? Usage: git publish-branch
    ##?
    ##? Push the current branch to the remote repository 'origin' and set it as
    ##? upstream.
    publish-branch = "!f() { \
        branch=$(git current-branch); \
        git push -u origin $branch; \
    }; f"

    ##? Usage: git unpublish-branch
    ##?
    ##? Delete the current branch from the remote repository 'origin'.
    unpublish-branch = "!f() { \
        current_branch=$(git current-branch); \
        git delete-remote-branch \"$current_branch\"; \
    }; f"

    ##? Usage: git upstream-branch
    ##?
    ##? Get the upstream branch name.
    upstream-branch = rev-parse --abbrev-ref @{u}

    # Usage: git branches
    # Show all branches with their corresponding upstream branches and commit hashes.
    branches = "!git fetch --prune && git branch -a -vv"

    ##? Usage: git local-branches
    ##?
    ##? List and display local branches.
    local-branches = "!git rev-parse --symbolic --branches"
    # Note: The alternative methods
    # local-branches = "!git for-each-ref --format='%(refname:short)' refs/heads/"
    # or
    # local-branches = "!git for-each-ref refs/heads --format='%(refname:short)'"
    # are slower.

    # Usage: git verify-local-branch BRANCH_NAME
    # Verify if a local branch exists.
    verify-local-branch = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git verify-local-branch BRANCH_NAME\n'; \
            return 64; \
        fi; \
        BRANCH_NAME=\"$1\"; \
        git rev-parse --verify \"$BRANCH_NAME\" > /dev/null 2>&1; \
    }; f"

    # Usage: git verify-remote-branch BRANCH_NAME
    # Check if a remote branch exists.
    verify-remote-branch = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git verify-remote-branch BRANCH_NAME\n'; \
            return 64; \
        fi; \
        BRANCH_NAME=\"$1\"; \
        git rev-parse --verify \"$(git origin)/$BRANCH_NAME\" > /dev/null 2>&1; \
    }; f"

    # Usage: git br
    # Show detailed information about local branches, sorted by commit date.
    br = for-each-ref refs/heads \
            --sort=-committerdate \
            --format='%(color:green)%(committerdate:short)%(color:reset) %(HEAD) %(color:green bold)%(refname:short)%(color:reset) %(color:red bold)%(upstream:track)%(color:reset) %(color:yellow)%(objectname:short)%(color:reset) %(contents:subject) %(color:bold cyan)<%(authorname)>%(color:reset)'

    # Usage: git remote-branches
    # List remote branches.
    remote-branches = branch -r

    # Usage: git remote-branches
    # List remote branches sorted by most recent commit.
    remote-branches-with-commit-info = "!f() { \
        git fetch --prune && \
        for branch in $(git for-each-ref --format='%(refname:short)' refs/remotes | grep -v HEAD); do \
            printf \"%s\\t%s\n\" \"$(git show -s --format='%Cred%ci %C(green)%h %C(yellow)%cr %C(magenta)%an %C(blue)' $branch | head -n 1)\" \"$branch\"; \
        done | sort -r; \
    }; f"

    # Iterate over remote branches, show commit info and branch name, and sort
    # by date.
    remote-branches-with-commit-info2 = "!f() { \
        git fetch --prune && \
        for branch in $(git branch -r | grep -v HEAD); do \
            echo $(git show --name-only --pretty=\"[%ai] [%ar] [%an] [%h]\" $branch | head -n 1) [${branch}]; \
        done | sort -r; \
    }; f"

    # Usage: git branch-edit-desc BRANCH_NAME
    # Edit the description of a Git branch.
    branch-edit-desc = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git branch-edit-desc BRANCH_NAME\n'; \
            return 64; \
        fi; \
        BRANCH_NAME=\"$1\"; \
        description_file=\".git/refs/heads/$BRANCH_NAME.description\"; \
        mkdir -p \"$(dirname \"$description_file\")\"; \
        touch \"$description_file\"; \
        echo -n \"\" > \"$description_file\"; \
        \"${VISUAL:-${EDITOR:-emacs}}\" \"$description_file\"; \
        cat \"$description_file\" | git hash-object -w --stdin > \"$description_file.hash\"; \
        git update-ref refs/heads/\"$BRANCH_NAME.description\" \"$(cat \"$description_file.hash\")\"; \
        git branch --edit-description \"$BRANCH_NAME\"; \
        rm \"$description_file\"; \
        rm \"$description_file.hash\"; \
    }; f"

    # Usage: git branch-show-desc BRANCH_NAME
    # Show the description of a Git branch.
    branch-show-desc = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git branch-show-desc BRANCH_NAME\n'; \
            return 64; \
        fi; \
        BRANCH_NAME=\"$1\"; \
        git config --get branch.\"$BRANCH_NAME\".description; \
    }; f"

    # Usage: git branch-upstream
    # List local branches and their upstream branches.
    branch-upstream = for-each-ref --format='%(refname:short) <- %(upstream:short)' refs/heads

    # Usage: git my-branches
    # Show all local branches created by the current user.
    my-branches = !git for-each-ref --format='%(authorname) %(refname:short)' refs/heads | grep -E \"^$(git config --get user.name)\"

    br-active = "!f() { \
        git branch --no-merged \
            | grep -v '\\*'; \
    }; f"

    # Usage: git branches-active
    # Show only branches that are unmerged.
    branches-active = "!f() { \
        git branch -a -vv --no-merged \
            | grep -v '\\*'; \
    }; f"

    # Usage: git br-merged
    # List branches merged into the current branch, excluding the current branch itself.
    br-merged = "!f() { \
        git branch --merged $(git current-branch) \
            | grep -v \"^\\*\"; \
    }; f"

    # Usage: git branches-merged
    # List merged branches (including remote branches), excluding the current branch.
    branches-merged = "!f() { \
        git branch -a -vv --merged \
            | grep -v '\\*'; \
    }; f"

    main = checkout main
    master = "!f() { \
        git checkout $(git main-branch); \
    }; f"
    develop = checkout develop

    ##? Usage: git sync-main
    ##?
    ##? Update remote branches and merge changes from the main branch into the
    ##? current branch.
    sync-main = "!f() { \
        git fetch; \
        main_branch=$(git main-branch); \
        current_branch=$(git current-branch); \
        git merge $(git origin)/$main_branch; \
        merge_status=$?; \
        if [ $merge_status -eq 0 ]; then \
            printf \"\\033[1mBranch synced:\\033[0m '%s' successfully synced with '%s'\\n\" \"$current_branch\" \"$main_branch\"; \
        else \
            git merge --abort 2> /dev/null; \
            printf >&2 \"\\033[1mUnable to sync branch:\\033[0m You can't merge until you resolve all merge conflicts.\\n\"; \
            return 2; \
        fi \
    }; f"

    # Fetch and rebase the current local branch onto the latest changes from the remote "main" branch.
    sync-main-rebase = !git fetch \
                && git rebase $(git origin)/$(git main-branch)

    ##? Perform a verbose pull operation.
    pull = pull -v

    ##? Usage: git pull-autostash
    ##?
    ##? Auto-stash changes (if needed), pull with rebase, and restore stashed
    ##? changes (onto the current branch).
    pull-autostash = pull --rebase --autostash

    ##? Usage: git pull-autostash-include-untracked
    ##?
    ##? Auto-stash changes (including untracked files if any), pull with rebase,
    ##? and restore stashed changes (if any).
    pull-autostash-include-untracked = "!f() { \
        changes=$(git status --porcelain); \
        if [ -n \"$changes\" ]; then \
            git stash push --include-untracked -m 'autostash'; \
            git pull --rebase; \
            # Check for conflicts before popping the stash. \
            if ! git diff --quiet && ! git diff --cached --quiet; then \
                printf >&2 \"\\033[1mStash application would result in conflicts. Resolve conflicts manually.\\033[0m\\n\"; \
                git reset --hard; # Reset working directory to avoid accidental commit. \
                return 2; \
            fi; \
            git stash pop; \
        else \
            git pull --rebase; \
        fi; \
    }; f"

    # Update remote-tracking branches and rebase the current local branch onto
    # the upstream branch it tracks.
    ##? Fetch changes from upstream and rebase current branch preserving merges.
    sync-upstream-rebase = "!f() { \
        git fetch; \
        git rebase -p @{u}; \
    }; f"
    # Rebasing non-linear changes (when the fast-forward merge is not possible).

    # Usage: git sync-ff-upstream
    # Update local branch with fast-forward from upstream.
    sync-upstream-ff = "!f() { \
        git fetch; \
        git merge --ff-only @{u}; \
    }; f"
    # (Keep your local branch in sync with the remote branch without creating
    # merge commits.)

    ##? Usage: git has-new-commits BRANCH_NAME
    ##?
    ##? Check if a branch has new commits.
    ##?
    ##? Arguments:
    ##?   BRANCH_NAME                   The name of the branch to check.
    has-new-commits = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git has-new-commits BRANCH_NAME\n'; \
            return 64; \
        fi; \
        BRANCH_NAME=\"$1\"; \
        if [ -z \"$BRANCH_NAME\" ]; then \
            printf >&2 'ERROR: Please provide a branch name as a parameter.\n' \
            return 2; \
        fi; \
        [ $(git rev-list --count $(git origin)/\"$BRANCH_NAME\"..\"$BRANCH_NAME\") -gt 0 ]; \
    }; f"

    # Iteratively synchronize all local branches with their corresponding remote
    # branches using fast-forward merges.
    update-all-branches = "!f() { \
        current_branch=$(git current-branch); \
        local_branches=$(git local-branches); \
        for branch in $local_branches; do \
            if [ \"$branch\" != \"$current_branch\" ]; then \
                printf 'Switching to branch: \\e[1m%s\\e[0m\n' \"$branch\"; \
                git checkout $branch; \
                if git check-remote-branch \"$branch\"; then \
                    if git has-new-commits $branch; then \
                        if git pull --ff-only; then \
                            printf 'Successfully updated %s\n' \"$branch\"; \
                        else \
                            printf 'Failed to update %s. Please resolve any conflicts manually.\n' \"$branch\"; \
                        fi; \
                    else \
                        printf 'No new commits to fetch for %s\n' \"$branch\"; \
                    fi; \
                else \
                    printf \"Remote branch \\e[1m%s\\e[0m does not exist. Skipping update.\n\n\" \"$branch\"; \
                fi; \
                printf '\n'; \
            fi; \
        done; \
        git checkout $current_branch; \
    }; f"

    ##? Usage: git update-all-branches2
    ##?
    ##? Update all local branches with their remote counterparts, checking for
    ##? conflicts before updating.
    update-all-branches2 = "!f() { \
        local_branches=$(git local-branches); \
        for branch in $local_branches; do \
            printf \"Checking for conflicts in \\e[1m%s\\e[0m...\n\" \"$branch\"; \
            if git check-remote-branch \"$branch\"; then \
                if git is-ancestor $(git origin)/$branch $branch; then \
                    printf \"No conflicts found in \\e[1m%s\\e[0m. Updating...\n\" \"$branch\"; \
                    if git pull $(git origin) $branch:$branch; then \
                        printf \"\n\"; \
                    else \
                        printf \"\\e[91mERROR: Pull failed for branch '%s'.\\e[0m\n\" \"$branch\"; \
                        if git rebase --abort > /dev/null 2>&1; then \
                            printf \"Rebase operation aborted.\n\n\"; \
                        else \
                            printf \"\\e[91mCould not abort the rebase operation. Please do so manually.\\e[0m\n\"; \
                        fi; \
                        continue; \
                    fi; \
                else \
                    printf \"Potential conflicts found in \\e[1m%s\\e[0m. Skipping update.\n\n\" \"$branch\"; \
                fi; \
            else \
                printf \"Remote branch \\e[1m%s\\e[0m does not exist. Skipping update.\n\n\" \"$branch\"; \
            fi; \
        done \
    }; f"

    ##? Delete the specified local branch.
    delete-local-branch = branch -d

    ##? Usage: git delete-merged-branches [BASE_BRANCH]
    ##?
    ##? Delete local branches that are fully merged into the specified branch,
    ##? excluding master, main, and develop.
    delete-merged-branches = "!f() { \
        BASE_BRANCH=$(git main-branch); \
        target_branch=${1-$BASE_BRANCH}; \
        branches=$(git branch --merged \"$target_branch\" \
                    | grep -v \"^\\s*$target_branch$\" \
                    | grep -Ev '^(\\s*)(master|main|develop)$'); \
        if [ -n \"$branches\" ]; then \
            printf \"%s\\n\" \"$branches\" | xargs git delete-local-branch; \
        else \
            printf 'No merged branches to delete.\\n'; \
        fi; \
    }; f"

    # Usage: git delete-remote-branch BRANCH_NAME
    # Delete a remote branch.
    delete-remote-branch = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git delete-remote-branch BRANCH_NAME\n'; \
            return 64; \
        fi; \
        BRANCH_NAME=\"$1\"; \
        printf \"Are you sure you want to delete the remote branch '%s'? [y/N] \" \"$BRANCH_NAME\"; \
        read -r confirm; \
        if [ \"$confirm\" = \"y\" ] || [ \"$confirm\" = \"Y\" ]; then \
            git push $(git origin) --delete \"$BRANCH_NAME\"; \
        else \
            printf \"Branch deletion cancelled.\n\"; \
        fi \
    }; f"
    # = "Close source branch" (after merging).

    ##? Usage: git delete-branch BRANCH_NAME
    ##?
    ##? Delete both local and remote branches.
    delete-branch = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git delete-branch BRANCH_NAME\n'; \
            return 64; \
        fi; \
        BRANCH_NAME=\"$1\"; \
        git delete-local-branch \"$BRANCH_NAME\" \
            && git delete-remote-branch \"$BRANCH_NAME\"; \
    }; f"

    # Usage: git prune-branches-all-remotes
    # Prune all branches for all remotes.
    prune-branches-all-remotes = "!f() { \
        git remote | xargs -n 1 git remote prune; \
    }; f"
    # 'git remote prune' does not understand '--all'.

    ##? Usage: git delete-gone-branches
    ##?
    ##? Delete local branches that are tracking remote branches that are gone.
    delete-gone-branches = "!f() { \
        gone_branches=$(git branch -vv | awk '/: gone]/{print $1}'); \
        if [ -n \"$gone_branches\" ]; then \
            printf \"Deleting gone branches:\n\"; \
            printf \"%s\n\" \"$gone_branches\" | xargs -n 1 git delete-local-branch; \
        else \
            printf \"No gone branches to delete.\n\"; \
        fi \
    }; f"

    # Usage: git rename-local-branch [OLD_BRANCH_NAME] NEW_BRANCH_NAME
    # Rename a local branch.
    rename-local-branch = branch -m

    # Usage: git rename-branch OLD_BRANCH_NAME NEW_BRANCH_NAME
    # Rename both a local and remote branch.
    rename-branch = "!f() { \
        if [ $# -ne 2 ]; then \
            printf >&2 'Usage: git rename-branch OLD_BRANCH_NAME NEW_BRANCH_NAME\n'; \
            return 64; \
        fi; \
        git rename-local-branch \"$1\" \"$2\" \
            && git push --set-upstream $(git origin) \"$2\" \
            && git delete-remote-branch \"$1\"; \
    }; f"

    # Usage: git tag-with-date [SUFFIX]
    # Tag the current commit with the current date and a custom suffix.
    tag-with-date = "!f() { \
        git tag $(date +'%Y.%m.%d_%H.%M')_$1; \
    }; f"

    ##? Usage: git publish-tag TAG_NAME [REMOTE_NAME]
    ##?
    ##? Publish a Git tag to a remote repository.
    publish-tag = "!f() { \
        TAG_NAME=$1; \
        REMOTE_NAME=${2:-$(git origin)}; \
        git push $REMOTE_NAME refs/tags/$TAG_NAME; \
    }; f"

    ##? Usage: git unpublish-tag TAG_NAME [REMOTE_NAME]
    ##?
    ##? Remove a published Git tag from a remote repository.
    unpublish-tag = "!f() { \
        TAG_NAME=$1; \
        REMOTE_NAME=${2:-$(git origin)}; \
        git push $REMOTE_NAME :refs/tags/$TAG_NAME; \
    }; f"

    push-tags = push --tags

    # List tags.
    tags = tag -l --sort=v:refname

    # Show a list of tag names and the commits they reference.
    tags-show-ids = show-ref --tags

    last-tag = describe --tags --abbrev=0

    last-tag-all = !git describe --tags $(git rev-list --tags --max-count=1)

    # Usage: git rename-tag OLD_TAG NEW_TAG
    # Rename a tag (locally and remotely).
    rename-tag = "!f() { \
        if [ $# -ne 2 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git rename-tag OLD_TAG NEW_TAG\n'; \
            return 64; \
        fi; \
        OLD_TAG=\"$1\"; \
        NEW_TAG=\"$2\"; \
        origin=$(git origin); \
        git tag \"$NEW_TAG\" \"$OLD_TAG\"; \
        git tag -d \"$OLD_TAG\"; \
        git push \"$origin\" \"$NEW_TAG\"; \
        git push \"$origin\" :refs/tags/\"$OLD_TAG\"; \
    }; f"

    ##? Usage: git delete-tag TAG
    ##?
    ##? Delete a local and remote tag.
    delete-tag = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git delete-tag TAG\\n'; \
            return 64; \
        fi; \
        TAG=\"$1\"; \
        git tag -d \"$TAG\" && \
        git push \"$(git origin)\" --delete \"$TAG\"; \
    }; f"

    ##? Usage: git compare-commits FROM TO
    ##?
    ##? Show commits between two branches or commits.
    ##?
    ##? Example:
    ##?   git compare-commits branch1 branch2
    compare-commits = "!f() { \
        if [ $# -ne 2 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git compare-commits FROM TO\n'; \
            return 64; \
        fi; \
        FROM=\"$1\"; \
        TO=\"$2\"; \
        git log \"$FROM\"...\"$TO\"; \
    }; f"

    ##? Usage: git compare-changed-files FROM TO
    ##?
    ##? Show changed files between two branches or commits.
    ##?
    ##? Example:
    ##?   git compare-changed-files branch1 branch2
    compare-changed-files = "!f() { \
        if [ $# -ne 2 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git compare-changed-files FROM TO\n'; \
            return 64; \
        fi; \
        FROM=\"$1\"; \
        TO=\"$2\"; \
        git diff --stat \"$FROM\"...\"$TO\"; \
    }; f"

    ##? Usage: git compare FROM TO
    ##?      = git diff FROM...TO
    ##?
    ##? Show diff between two branches or commits.
    ##?
    ##? Examples:
    ##?   git compare branch1 branch2
    ##?   git compare master@{1day} master
    compare = "!f() { \
        if [ $# -ne 2 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git compare FROM TO\n'; \
            return 64; \
        fi; \
        FROM=\"$1\"; \
        TO=\"$2\"; \
        git diff \"$FROM\"...\"$TO\"; \
    }; f"
    # https://github.com/fniessen/gitboost/compare/master@%7B1day%7D...master

    compare-file-main = "!f() { \
        git diff $(git main-branch)..$(git current-branch) -- \"$1\"; \
    }; f"

    compare-file-main-difftool = "!f() { \
        git difftool $(git main-branch)..$(git rev-parse --abbrev-ref HEAD) -- \"$1\"; \
    }; f"

    # Usage: git missing [OTHER_BRANCH]
    # Show the missing commits between the current branch and another branch.
    missing = "!f() { \
        if [ $# -gt 1 ]; then \
            printf >&2 'Usage: git missing [OTHER_BRANCH]\n'; \
            return 64; \
        fi; \
        current_branch=$(git current-branch); \
        OTHER_BRANCH=${1:-$(git main-branch)}; \
        if ! git verify-local-branch \"$current_branch\"; then \
            printf >&2 \"$(tput setaf 1)ERROR: Current branch '%s' is not a valid branch.\n$(tput sgr0)\" \"$current_branch\"; \
            return 2; \
        fi; \
        if ! git verify-local-branch \"$OTHER_BRANCH\"; then \
            printf >&2 \"$(tput setaf 1)ERROR: Other branch '%s' is not a valid branch.\n$(tput sgr0)\" \"$OTHER_BRANCH\"; \
            return 2; \
        fi; \
        commits_missing_to_current=$(git rev-list --count \"$OTHER_BRANCH\"..\"$current_branch\"); \
        commits_missing_to_other=$(git rev-list --count \"$current_branch\"..\"$OTHER_BRANCH\"); \
        printf \"$(tput bold)$(tput setaf 2)Commits missing in '%s' but present in '%s':$(tput sgr0) %d commits\n\" \
            \"$OTHER_BRANCH\" \"$current_branch\" \"$commits_missing_to_current\"; \
        git --no-pager log \"$OTHER_BRANCH\"..\"$current_branch\"; \
        printf \"\n\n$(tput bold)$(tput setaf 3)Commits missing in '%s' but present in '%s':$(tput sgr0) %d commits\n\" \
            \"$current_branch\" \"$OTHER_BRANCH\" \"$commits_missing_to_other\"; \
        git --no-pager log \"$current_branch\"..\"$OTHER_BRANCH\"; \
        printf \"\n\"; \
    }; f"

    ##? Get the merge base commit hash between two branches. Defaults to main
    ##? and current branch if not specified.
    common-ancestor = "!f() { \
        MAIN_BRANCH=${1:-$(git main-branch)}; \
        CURRENT_BRANCH=${2:-$(git rev-parse --abbrev-ref HEAD)}; \
        base=$(git merge-base $MAIN_BRANCH $CURRENT_BRANCH 2> /dev/null); \
        if [ -z \"$base\" ]; then \
            printf >&2 '%s\n' \"ERROR: Unable to find common ancestor between branches '$MAIN_BRANCH' and '$CURRENT_BRANCH'. Branches may not exist or be valid.\"; \
            return 2; \
        else \
            short_base=$(git rev-parse --short $base); \
            printf '%s\n' \"$short_base\"; \
        fi \
    }; f"
    # Find the point at which a branch forked from another branch (when it was
    # branched off).
    # Find the most recent common ancestor between the current branch and the
    # default branch.
    # BUG: Does not work between 2 specific branches -- well without arguments

    # Log commits from the common ancestor of current branch and HEAD.
    log-common-ancestor = log $(git common-ancestor)..

    # Show diff from the common ancestor of current branch and HEAD.
    diff-common-ancestor = diff $(git common-ancestor)..

    # Usage: git missing-files [OTHER_BRANCH]
    # Show the changed files that are in the current branch but not in the other (i.e., asymmetrical diff).
    # Examples:
    #   git missing-files             list changed files between this and main
    #   git missing-files feature/7   list changed files between this and the 'feature/7' branch
    missing-files = "!f() { \
        current_branch=$(git current-branch); \
        OTHER_BRANCH=${1:-$(git main-branch)}; \
        if ! git verify-local-branch \"$current_branch\"; then \
            printf >&2 \"ERROR: Current branch '%s' is not a valid branch.\n\" \"$current_branch\"; \
            return 2; \
        fi; \
        if ! git verify-local-branch \"$OTHER_BRANCH\"; then \
            printf >&2 \"ERROR: Other branch '%s' is not a valid branch.\n\" \"$OTHER_BRANCH\"; \
            return 2; \
        fi; \
        missing_files_to_current=$(git diff --name-only \"$OTHER_BRANCH\"...\"$current_branch\" | wc -l | tr -d '[:space:]'); \
        printf \"$(tput bold)Files missing in '%s' but present in '%s':$(tput sgr0) %d files\n\" \"$OTHER_BRANCH\" \"$current_branch\" \"$missing_files_to_current\"; \
        git diff --stat \"$OTHER_BRANCH\"...\"$current_branch\"; \
    }; f"

    missing-files-name-only = "!f() { \
        current_branch=$(git current-branch); \
        OTHER_BRANCH=${1:-$(git main-branch)}; \
        if ! git verify-local-branch \"$current_branch\"; then \
            printf >&2 \"ERROR: Current branch '%s' is not a valid branch.\n\" \"$current_branch\"; \
            return 2; \
        fi; \
        if ! git verify-local-branch \"$OTHER_BRANCH\"; then \
            printf >&2 \"ERROR: Other branch '%s' is not a valid branch.\n\" \"$OTHER_BRANCH\"; \
            return 2; \
        fi; \
        git diff --name-only \"$OTHER_BRANCH\"...\"$current_branch\"; \
    }; f"

    ##? Usage: git log-graph
    ##?
    ##? Show a graphical log of commits.
    log-graph = log --graph

    ##? Usage: git log-graph-branches-tags-remotes
    ##?
    ##? Show a graphical log of commits with branches, tags, and remotes.
    log-graph-branches-tags-remotes = log --branches --tags --remotes --date-order --format=format:'%C(yellow)%h %C(reset) %<(75,trunc)%s <%cn> (%cr) %C(red)%d' --graph

    ##? Usage: git log-graph-all
    ##?
    ##? Show a graphical log of all references.
    log-graph-all-branches = log --all --graph

    ##? Usage: git log-graph-detail
    ##?
    ##? Show a detailed graphical log with file changes.
    log-graph-detail = log --pretty=format:'%C(green)%cr%C(reset) %C(yellow)%h%Creset %C(yellow)%d%Creset %s %C(bold blue)<%an>%Creset%n' --graph --name-status

    ##? Usage: git releases
    ##?
    ##? Display a simplified commit history graph with decorations, excluding
    ##? merge commits.
    releases = log --no-merges --all --simplify-by-decoration --graph

    # Draw Git revisions graph with Graphviz.
    graphviz = "!f() { \
        printf 'digraph git {\n'; \
        git log -25 --pretty='format:  %h -> { %p }' \"$@\" \
            | sed 's_[0-9a-f][0-9a-f]*_\"&\"_g' ; \
        printf '}\n'; \
    }; f"

    # Display a list of authors with their email addresses and commit counts,
    # sorted by number of commits.
    authors = shortlog -n -s -e --no-merges --

    # Alias for 'authors'.
    contributors = authors

    pull-request-bb = "!f() { \
        USER_NAME=\"$1\"; \
        curl --user $USER_NAME https://bitbucket.org/$(git repo-owner)/$(git repo-slug-remote)/pull-requests/new?source=$(git current-branch)&t=1; \
    }; f"

    # For GitHub.
    pr-checkout-gh = "!f() { \
        git fetch $(git origin) pull/\"$1\"/head:pr/\"$1\" \
            && git checkout pr/\"$1\"; \
    }; f"
    # https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/checking-out-pull-requests-locally

    # For GitLab.
    pr-checkout-gl = "!f() { \
        git fetch $(git origin) merge-requests/\"$1\"/head:pr/\"$1\" \
            && git checkout pr/\"$1\"; \
    }; f"
    # https://about.gitlab.com/blog/2016/12/08/git-tips-and-tricks/#add-an-alias-to-checkout-merge-requests-locally

    # For GitHub.
    mpr = "!f() { \
        declare current_branch=\"$(git current-branch)\"; \
        declare BRANCH_NAME=\"${2:-$current_branch}\"; \
        if [ $(printf \"%s\" \"$1\" | grep '^[0-9]\\+$' > /dev/null; printf $?) -eq 0 ]; then \
            git fetch $(git origin) refs/pull/\"$1\"/head:pr/\"$1\" \
                && git checkout -B $BRANCH_NAME \
                && git rebase $BRANCH_NAME pr/\"$1\" \
                && git checkout -B $BRANCH_NAME \
                && git merge --ff-only pr/\"$1\" \
                && git delete-local-branch pr/\"$1\"; \
        fi \
    }; f"

    # Usage: git merge-pr REMOTE PR_NUMBER
    #
    # Merge a GitHub PR with a formatted commit message.
    #
    # Merge given pull request into the current branch.
    # The commit message will have the same for as if done using the
    # merge button on github.com
    #
    # Example:
    #   git merge-pr $(git origin) 5
    merge-pr = "!f() { \
        if [ $# -ne 2 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git merge-pr REMOTE PR_NUMBER\\n'; \
            return 64; \
        fi; \
        USER_AND_REPO=$(git remote show \"$1\" | grep 'Fetch URL:' | sed -E 's/.*github.com[:\\/]([a-zA-Z_-]+)\\/([a-zA-Z_-]+)\\.git$/\\1 \\2/'); \
        if [ -z \"$USER_AND_REPO\" ]; then \
            printf >&2 'ERROR: Could not determine GitHub user/repo from remote\\n'; \
            return 2; \
        fi; \
        USER=$(printf \"%s\" \"$USER_AND_REPO\" | cut -d' ' -f1); \
        REPO=$(printf \"%s\" \"$USER_AND_REPO\" | cut -d' ' -f2); \
        TMP_FILE=$(mktemp); \
        curl -s \"https://api.github.com/repos/$USER/$REPO/pulls/$2\" > \"$TMP_FILE\"; \
        if ! grep -q '\"title\":' \"$TMP_FILE\"; then \
            printf >&2 'ERROR: Failed to fetch PR #%s\\n' \"$2\"; \
            rm -f \"$TMP_FILE\"; \
            return 2; \
        fi; \
        PULL_AUTHOR=$(awk '/\"head\":/{flag=1} flag&&/\"login\": \"/{print \\$2; exit}' \"$TMP_FILE\" | sed -E 's/\"([^\"]+)\".*/\\1/'); \
        PULL_REF=$(awk '/\"head\":/{flag=1} flag&&/\"ref\": \"/{print \\$2; exit}' \"$TMP_FILE\" | sed -E 's/\"([^\"]+)\".*/\\1/'); \
        PULL_TITLE=$(grep '\"title\": ' \"$TMP_FILE\" | sed 's/^ *\"title\": \"//' | sed 's/\",$//'); \
        rm -f \"$TMP_FILE\"; \
        if [ -z \"$PULL_AUTHOR\" ] || [ -z \"$PULL_REF\" ] || [ -z \"$PULL_TITLE\" ]; then \
            printf >&2 'ERROR: Failed to parse PR details\\n'; \
            return 2; \
        fi; \
        git fetch \"$1\" \"pull/$2/head\" || { \
            printf >&2 'ERROR: Failed to fetch PR #%s\\n' \"$2\"; \
            return 2; \
        }; \
        git merge --no-ff -m \"Merged pull request #$2 from $PULL_AUTHOR/$PULL_REF\\n\\n$PULL_TITLE\" FETCH_HEAD || { \
            printf >&2 'ERROR: Merge failed\\n'; \
            return 2; \
        }; \
        printf 'Merged PR #%s\\n' \"$2\"; \
    }; f"

    pr-clean = "!f() { \
        git delete-local-branch pr/\"$1\"; \
    }; f"

    related-pr-of-commit = "!sh -c 'git log --merges --ancestry-path $1..master \
            | tail -n 1 ' -"

    ##? Usage: git release-tag VERSION
    ##?
    ##? Create a tagged release version in Git and push it to the remote repository.
    release-tag = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git release-tag VERSION\n'; \
            return 64; \
        fi; \
        VERSION=\"$1\"; \
        git tag -a v\"$VERSION\" -m \"Release version $VERSION\" \
            && git push --tags \
            && git push; \
    }; f"

    # Usage: git manifest
    # Print a list of version controlled files for the current revision.
    manifest = ls-files

    # Usage: git changelog [FIRST_TAG_NAME] [LAST_TAG_NAME]
    # Detailed list of changes.
    changelog1 = "!f() { \
        git log --no-merges ${1-$(git last-tag)}..$2; \
    }; f"
    changelog = "!f() { \
        git log --no-merges --pretty=format:\"* %s\" $(git last-tag)...HEAD; \
    }; f"
    changelog-org = "!f() { \
        git log --no-merges --pretty=format:\"- %s\" $(git last-tag)...HEAD; \
    }; f"

    # le dernier tag, ainsi que la liste des commits ayant eu lieu depuis sur la
    # branche courante.
    unreleased = !git log $(git last-tag)...HEAD \
                && git last-tag

    ##? Get the tag that points to the current HEAD.
    current-tag = tag --points-at HEAD

    ##? Archive the current tag as a zip file.
    archive-current-tag = "!f() { \
        tag=$(git current-tag); \
        git archive --format=zip --output=${tag}.zip HEAD; \
    }; f"

    ##? Usage: git export-branch-diff
    ##?
    ##? Export the current branch to a diff file.
    export-branch-diff = "!f() { \
        current_branch=$(git current-branch); \
        git format-patch --stdout $current_branch > $current_branch.diff; \
    }; f"

    ##? Usage: git export-changed-files
    ##?
    ##? Export and zip changed files from the current branch compared to the main branch.
    export-changed-files = "!f() { \
        current_branch=$(git convert-current-branch-name); \
        main_branch=$(git main-branch); \
        changed_files=$(git diff --name-only \"$main_branch\"...\"$current_branch\"); \
        if [ -z \"$changed_files\" ]; then \
            printf >&2 'ERROR: No changed files to export.\n'; \
            return 2; \
        fi; \
        date=$(date +'%Y-%m-%d'); \
        zip_file=\"$date-$(git repo-slug-remote)-changed-files-$current_branch.zip\"; \
        zip -9 ~/$zip_file $changed_files; \
        printf 'Exported changed files saved as %s\n' $zip_file; \
    }; f"

    # Archive the current state to a zip file named latest.zip.
    archive-zip = archive --output=latest.zip

    # Archive the current state to a compressed tar.gz file named latest.tar.gz with maximum compression.
    archive-targz = archive --output=latest.tar.gz -9

    ##? Usage: git export-commit-files [COMMIT_HASH]
    ##?
    ##? Export changed files from a commit or HEAD and create a zip archive.
    export-commit-files = "!f() { \
        COMMIT_HASH=$(git rev-parse --short ${1:-HEAD}); \
        current_branch=$(git convert-current-branch-name); \
        zip_file_name=$(git repo-slug-remote)-commit-${current_branch}-${COMMIT_HASH}.zip; \
        git changed-files \"$COMMIT_HASH\" | tr '\n' '\\0' | xargs -0 zip -9 \"$zip_file_name\"; \
    }; f"

    # Since oldest ancestor...
    plain-diff = !git branch-diff > $(git convert-current-branch-name).diff

    patch-for-this = "!git diff -p $(git hash-object -t tree /dev/null)"

    ##? Check for whitespace errors between the current working directory and the
    ##? HEAD commit.
    check-whitespace-head = diff-tree --check $(git hash-object -t tree /dev/null) HEAD

    ##? Check for whitespace errors between the index (staging area) and the
    ##? current working directory.
    check-whitespace-index = diff --check $(git hash-object -t tree /dev/null)

    ##? Check for whitespace errors in the changes.
    whitespace-errors = diff --check

    ##? Check if any file in the repository has Windows line endings.
    check-eol = "!f() { \
        git grep --files-with-matches $'\\r' -- ':(exclude)*.git/*'; \
    }; f"

    # issues = "!f() { \
    #     USER_NAME=\"$1\"; \
    #     curl --user $USER_NAME \
    #         https://api.bitbucket.org/2.0/repositories/$(git repo-owner)/$(git repo-slug-remote)/issues \
    #         | jq -C --compact-output '.values | .[] | [.id, .title, .type, .priority, .state, .votes, .assignee.display_name, .created_on, .updated_on]' \
    #         | sed -r 's_(....)-(..)-(..)T(..):(..):(..).(............)_\\1-\\2-\\3_g' \
    #         | sed \"s_new_NEW_\" \
    #         | sed \"s_NEW_$(tput setaf 2) -- NOUVEAU -- $(tput sgr0)_\" \
    #         | sed \"s_NEW_\$(tput setaf 3) -NOUV- \$(tput sgr0)_\" \
    #         | sed \"s_open_OPEN_\" \
    #         | sed \"s_closed_CLOSED_\"; \
    # }; f"
# --data-urlencode 'priority >= \"major\"'

    issues-open = !git issues | grep "open"

    issues-assigned-to-me = !git issues | grep "$(git config --get user.name)"

    # Usage: git show-issue ISSUE_NUMBER
    show-issue = "!f() { \
        REPO_OWNER=\"YourUsername\"; \
        REPO_SLUG_REMOTE=\"YourRepository\"; \
        ISSUE_NUMBER=\"$1\"; \
        URL=\"https://github.com/$REPO_OWNER/$REPO_SLUG_REMOTE/issues/$ISSUE_NUMBER\"; \
        open \"$URL\"; \
    }; f"

    browse-issues = "!f() { \
        url=$(git config --get remote.$(git origin).url); \
        xdg-open ${url/.git}/issues/\"$1\"; \
    }; f"

    ##? Usage: git issue-keys [LOG-OPTIONS]
    ##?
    ##? List unique JIRA issue keys from commit messages.
    ##?
    ##? Example:
    ##?   git issue-keys --since="2 weeks ago"
    issue-keys = "!f() { \
        printf 'Extracting JIRA issue keys from commit messages...\n'; \
        git log \"$@\" \
            | grep -oE '[A-Z]+-[0-9]+' \
            | sort -u; \
    }; f"

    browse-wiki = "!f() { \
        url=$(git config --get remote.$(git origin).url); \
        xdg-open ${url/.git}/wiki; \
    }; f"

    ##? Usage: git download-repository [COMMIT_HASH]
    ##?
    ##? Download the contents of the repository at a specific commit (default
    ##? is HEAD) and save it as a zip file named
    ##? '<REPO-NAME>-commit-<COMMIT-HASH>.zip'.
    ##?
    ##? Examples:
    ##?   git download-repository       Download the contents of the latest
    ##?                                 commit as a zip file.
    ##?   git download-repository abc123
    ##?                                 Download the contents of commit abc123
    ##?                                 as a zip file.
    ##?   git download-repository main  Download the latest commit from the main
    ##?                                 branch.
    ##?   git download-repository v1.0.0
    ##?                                 Download the repository at the v1.0.0
    ##?                                 tag.
    download-repository = "!f() { \
        COMMIT_HASH=${1:-HEAD}; \
        git archive $COMMIT_HASH --format=zip --output=$(basename $(git root))-commit-$(git rev-parse $COMMIT_HASH).zip; \
    }; f"

    ##? Usage: git x COMMAND
    ##?
    ##? Execute a shell command and show its output.
    ##?
    ##? Example:
    ##?   git x make
    x = "!exec "

    ##? Usage: git root
    ##?
    ##? Show the absolute path to the root directory of the Git repository.
    root = rev-parse --show-toplevel

    ##? Usage: git root-relative
    ##?
    ##? Show the path relative to the root directory of the Git repository.
    root-relative = rev-parse --show-prefix

    ##? Usage: git repos
    ##?
    ##? List all Git repositories by finding .git directories, sorting the
    ##? output, and removing the '/.git' suffix and leading './'.
    repos = "!f() { \
        find . -type d -name '.git' -prune -print 2> /dev/null | while read -r repo_path; do \
            if [ \"$repo_path\" != \"./.git\" ]; then \
                repo_path=\"${repo_path%/.git}\"; \
                repo_path=\"${repo_path#./}\"; \
                printf '%s\n' \"$repo_path\"; \
            fi; \
        done | sort; \
    }; f"

    ##? Usage: git all-repos COMMAND [ARGS]
    ##?
    ##? Run a Git command for each repository in the current directory and its
    ##? subdirectories.
    ##?
    ##? Arguments:
    ##?   COMMAND                       Git command to be executed in each
    ##?                                 repository
    ##?   ARGS                          Additional arguments to be passed to the
    ##?                                 Git command
    all-repos = "!f() { \
        if [ $# -lt 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git all-repos COMMAND [ARGS]\\n'; \
            return 64; \
        fi; \
        find . -type d -name '.git' \
            | sort \
            | sed 's_/.git__' \
            | while read -r repo_path; do \
                repo_slug_local=$(git -C \"$repo_path\" repo-slug-local); \
                printf '\\033[1m%s:\\033[0m\\n' \"$repo_slug_local\"; \
                output=$(git -C \"$repo_path\" -c color.status=always \"$@\" 2>&1); \
                if [ -n \"$output\" ]; then \
                    printf '%s\\n' \"$output\" | sed 's/^/      /'; \
                fi; \
                printf '\\n'; \
            done; \
    }; f"

    # Usage: git pull-all-repos
    # Pull the changes in all Git repositories of the current directory.
    pull-all-repos = !$HOME/bin/git-pull-all-repos

    # Usage: git push-all-repos
    # Push the changes in all Git repositories of the current directory.
    push-all-repos = !$HOME/bin/git-push-all-repos

    stage-updated-and-deleted-files = add -u

    # Given a merge commit, find the span of commits that exist(ed).
    # Not so useful in itself, but used by other aliases.
    # Thanks to Rob Miller for the merge-span-* aliases.
    merge-span = "!f() { \
        printf '%s%s%s' \
            $(git log -1 --merges --pretty=format:%P $2 | cut -d' ' -f1) \
            \"$1\" \
            $(git log -1 --merges --pretty=format:%P $2 | cut -d' ' -f2); \
    }; f"

    # Find the commits that were introduced by a merge.
    merge-span-log = "!f() { \
        git log $(git merge-span .. \"$1\"); \
    }; f"

    # Show the changes that were introduced by a merge.
    merge-span-diff = "!f() { \
        git diff $(git merge-span ... \"$1\"); \
    }; f"

    # Show the changes that were introduced by a merge, in your difftool.
    merge-span-difftool = "!f() { \
        git difftool $(git merge-span ... \"$1\"); \
    }; f"

    ##? Usage: git r
    ##?
    ##? Get the default remote name and print its URL.
    r = "!f() { \
        remote_name=$(git origin); \
        git remote get-url \"$remote_name\"; \
    }; f"
    # git remote show -n origin | grep "Fetch URL" | cut -d: -f2- | sed 's/^ *//'

    ##? Usage: git incoming
    ##?
    ##? Fetch changes from the remote and shows incoming commits.
    ##? Show commits that are in the remote but not in the local branch.
    incoming = "!f() { \
        git fetch \
            && git log HEAD..@{u}; \
    }; f"

    ##? Alias for 'incoming'.
    in = incoming

    ##? Show incoming commits with file statistics.
    inll = "!f() { \
        git fetch \
            && git log --pretty=medium --abbrev-commit --stat HEAD..@{u}; \
    }; f"

    ##? Show incoming commits with unified diffs.
    inlll = "!f() { \
        git fetch \
            && git log -u HEAD..@{u}; \
    }; f"

    # Usage: git incoming-on-branch BRANCH_NAME
    # Show new commits found in the remote repository.
    # Example: git incoming-on-branch master
    incoming-on-branch = "!f() { \
        git fetch \
            && git log ..$(git origin)/$1; \
    }; f"

    # Usage: git who-changed BRANCH_NAME
    who-changed = "!f() { \
        git shortlog HEAD..$(git origin)/$1; \
    }; f"

    ##? Fetch updates from the remote repository and shows the difference
    ##? statistics between local HEAD and @{u}.
    incoming-files = "!f() { \
        git fetch \
            && git diff --stat HEAD...@{u}; \
    }; f"

    ##? Alias for 'incoming-files'.
    in-files = incoming-files

    incoming-diff = diff @{u} HEAD
    # diff with upstream branch

    ##? Usage: git update [PULL_OPTIONS]
    ##?
    ##? Update the repository and submodules, with rebasing and pruning.
    update = "!f() { \
        git pull --rebase --prune \"$@\" \
            && git submodule sync --recursive \
            && git submodule update --init --recursive; \
    }; f"

    ##? Usage: git update2 [PULL_OPTIONS]
    ##?
    ##? Update the repository and all submodules, with rebasing, pruning, and
    ##? proper branch handling.
    update2 = "!f() { \
        git pull --rebase --prune \"$@\" \
            && git submodule sync --recursive \
            && git submodule update --init --recursive \
            && git submodule foreach 'git pull --rebase \"$(git r)\" $(git current-branch)'; \
    }; f"

    # Retrieve the timestamp of the most recent pull operation, regardless of changes being present.
    latest-pull-time = "!f() { \
        fetch_head_time=$(stat -c %y $(git root)/.git/FETCH_HEAD | cut -d'.' -f1); \
        printf \"Latest pull time: %s\n\" \"$fetch_head_time\"; \
    }; f"
    # For the latest pull (even if there's nothing new).

    # Retrieve the timestamp of the last update to your current branch from the remote master branch, considering changes received.
    latest-update-time = "!f() { \
        current_branch=$(git current-branch); \
        update_time=$(stat -c %y $(git root)/.git/refs/heads/$current_branch | cut -d'.' -f1); \
        printf \"Latest update time for branch '%s': %s\n\" \"$current_branch\" \"$update_time\"; \
    }; f"
    # For the latest pull resulting in changes coming in from the remote master
    # branch (the timestamp won't change when git pull reports there are no
    # changes).

    # Pull the latest changes for the current branch from its remote counterpart.
    pull-current-branch = "!git pull $(git origin) $(git current-branch)"

    # Push the current branch to its remote counterpart.
    push-current-branch = "!git push $(git origin) $(git current-branch)"

    # Pull and push the latest changes for the current branch.
    pull-and-push-current-branch = "!f() { \
        pull-current-branch && push-current-branch; \
    }; f"

    # Update repository by pulling changes from remote and pushing local commits.
    pull-and-push = !git pull && git push

    # Avoid a fast-forward commit.
    mnf = merge --no-ff --log

    ##? Usage: git merge-into-main
    ##?
    ##? Merge changes from the current branch into the main branch.
    merge-into-main = "!f() { \
        current_branch=\"$(git current-branch)\"; \
        if [ -z \"$current_branch\" ]; then \
            printf >&2 'ERROR: Unable to determine current branch.\n'; \
            return 2; \
        fi; \
        git checkout \"$(git main-branch)\" && \
        if git merge \"$current_branch\"; then \
            printf \"\\033[1mBranch merged:\\033[0m '%s' successfully merged\n\" \"$current_branch\"; \
        else \
            printf >&2 \"\\033[1mUnable to merge branch:\\033[0m\n\"; \
            return 2; \
        fi; \
        git checkout \"$current_branch\"; \
    }; f"

    # Usage: git merge-update-push TARGET_BRANCH
    # Merge changes from the current branch into the specified target branch, updates it, and pushes changes.
    merge-update-push = "!f() { \
        current_branch=\"$(git current-branch)\"; \
        TARGET_BRANCH=\"$1\"; \
        git checkout \"$TARGET_BRANCH\" \
            && git pull \
            && git merge \"$current_branch\" \
            && git push \
            && git checkout \"$current_branch\"; \
    }; f"

    ##? Usage: git merge-test BRANCH_NAME
    ##?
    ##? Test a merge and then abort it.
    merge-test = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git merge-test BRANCH_NAME\n'; \
            return 64; \
        fi; \
        BRANCH_NAME=\"$1\"; \
        if [ -z \"$BRANCH_NAME\" ]; then \
            printf >&2 \"ERROR: No branch specified.\\n\"; \
            return 2; \
        fi; \
        git merge --no-commit --no-ff \"$BRANCH_NAME\"; \
        git merge --abort; \
        printf \"Merge aborted.\\n\"; \
    }; f"

    ##? Usage: git dry-merge1 BRANCH_TO_MERGE
    ##?
    ##? Simulate a "dry run" merge of a branch into the current branch.
    ##?
    ##? Example:
    ##?   git dry-merge1 feature # Merge the `feature` branch without committing the changes.
    dry-merge1 = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git dry-merge1 BRANCH_TO_MERGE\n'; \
            return 64; \
        fi; \
        BRANCH_TO_MERGE=\"$1\"; \
        git merge --no-commit \"$BRANCH_TO_MERGE\"; \
        git reset; \
    }; f"

    ##? Usage: git dry-merge2 BRANCH_TO_MERGE
    ##?
    ##? Simulate a "dry run" merge of a branch into the current branch.
    ##?
    ##? Example:
    ##?   git dry-merge2 feature # Merge the `feature` branch without committing the changes.
    dry-merge2 = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git dry-merge2 BRANCH_TO_MERGE\n'; \
            return 64; \
        fi; \
        BRANCH_TO_MERGE=\"$1\"; \
        git merge --no-commit --no-ff \"$BRANCH_TO_MERGE\"; \
    }; f"

    # Usage: git merge-dry-run BRANCH_NAME
    #
    # Check how the merge of BRANCH_NAME into master will go
    merge-dry-run = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git merge-dry-run BRANCH_NAME\n'; \
            return 64; \
        fi; \
        if grep -q 'changed in both' <<< $(git merge-tree $(git merge-base FETCH_HEAD \"$1\") FETCH_HEAD \"$1\"); then \
            printf 'Merge conflicts!\n' \
        else \
            printf 'This branch can be automatically merged.\n' \
        fi; \
    }; f"
    # XXX DOESN'T work for git fetch & git merge

    # Extract the "changed in both" lines as well as the conflicting parts.
    merge-dry-run-conflicts = "!f() { \
        git merge-tree $(git merge-base \"$1\" $2) \"$1\" $2 \
            | sed -n '/+<<<<<<< .our/,/+>>>>>>> .their/p;/^changed in both/{n;N;N;s/^/#/mg;p}' \
            | cdiff; \
    }; f"

    ##? Usage: git ours FILE
    ##?
    ##? Resolve conflict by using 'ours' version and add the file.
    ours = "!f() { \
        git checkout --ours \"$@\" \
            && git add \"$@\"; \
    }; f"

    ##? Usage: git theirs FILE
    ##?
    ##? Resolve conflict by using 'theirs' version and add the file.
    theirs = "!f() { \
        git checkout --theirs \"$@\" \
            && git add \"$@\"; \
    }; f"

    ##? Usage: git conflicted-files
    ##?
    ##? List files with merge conflicts only.
    conflicted-files = diff --name-only --diff-filter=U

    ##? Usage: git edit-unmerged
    ##?
    ##? Open all files with merge conflicts in the editor.
    edit-unmerged = "!$EDITOR $(git conflicted-files)"

    ##? Usage: git add-unmerged
    ##?
    ##? Add all files with merge conflicts.
    add-unmerged = "!git add $(git conflicted-files)"

    # Create a feature branch.
    feature = "!f() { \
        git create-branch feature/\"$1\" develop; \
    }; f"
    # XXX or feature-start?

    # Incorporate a finished feature on develop.
    feature-finish = "!f() { \
        git checkout develop; \
        git merge --no-ff feature/\"$1\" \
            && git delete-local-branch feature/\"$1\"; \
    }; f"

    # XXX Also bug and refactor.

    # XXX release-start
    # XXX release-finish

    ##? Shortcut for checkout.
    co = checkout

    ##? Checkout the latest commit on the current branch that is not (merged) on
    ##? 'master'.
    next = "!f() { \
        git checkout $(git rev-list --topo-order HEAD..master | tail -1); \
    }; f"

    ##? Usage: git force-checkout BRANCH_NAME
    ##?
    ##? Force checkout to a branch, discarding local changes if necessary.
    force-checkout = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: git force-checkout BRANCH_NAME\n'; \
            return 64; \
        fi; \
        BRANCH_NAME=$1; \
        git checkout \"$BRANCH_NAME\" 2>&1 | { \
            while IFS= read -r line; do \
                if printf \"%s\n\" \"$line\" | grep -q \"error: Your local changes to the following files would be overwritten by checkout:\"; then \
                    continue; \
                fi; \
                if printf \"%s\n\" \"$line\" | grep -q \"^[[:space:]]*\"; then \
                    file_path=$(printf \"%s\n\" \"$line\" | sed \"s/^[[:space:]]*//\"); \
                    if [ -n \"$file_path\" ]; then \
                        git checkout -- \"$file_path\"; \
                    fi; \
                fi; \
            done; \
        }; \
        git checkout \"$BRANCH_NAME\"; \
    }; f"

    ##? Usage: git co-autostash-include-untracked BRANCH_NAME
    ##?
    ##? Switch to a specified branch, stashing any uncommitted changes if necessary.
    ##? Only stashes if there are changes and restores the stash after switching.
    co-autostash-include-untracked = "!f() { \
        if [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then \
            printf >&2 'Usage: co-autostash BRANCH_NAME\n'; \
            return 64; \
        fi; \
        BRANCH_NAME=\"$1\"; \
        if ! git diff-index --quiet HEAD; then \
            git stash push --include-untracked --quiet; \
        fi; \
        git checkout \"$BRANCH_NAME\"; \
        if git stash list | grep -q \"^stash@{0}\"; then \
            git stash pop --quiet; \
        fi; \
    }; f"

    sb  = show-branch

    sbs = show-branch --sha1-name

    # pg sbt master pu -- if the last line is 'master' and not 'master~'
    # or 'master~N' then pu is a descendent of master
    sbt = show-branch --topics

    ##? Usage: git outgoing
    ##?
    ##? Show commits that are in the local branch but not in the remote (unpushed).
    ##? Useful after making local commits and before pushing.
    outgoing = log @{u}..HEAD

    ##? Alias for 'outgoing'.
    out = outgoing

    ##? Show outgoing commits with file statistics.
    outll = log --pretty=medium --abbrev-commit --stat @{u}..HEAD

    ##? Show outgoing commits with unified diffs.
    outlll = log -u @{u}..HEAD

    # Show new commits since the last rebase/reset/merge, with stats, excluding
    # merges.
    recent-changes = log --no-merges --stat ORIG_HEAD..

    ##? Usage: git outgoing-files
    ##?
    ##? Show the difference statistics between the remote branch and local HEAD.
    outgoing-files = diff --stat @{u}...

    ##? Alias for 'outgoing-files'.
    out-files = outgoing-files

    ##? Usage: git outgoing-all-branches
    ##?
    ##? Show commits present in local branches but not in remote branches.
    outgoing-all-branches = log --branches --not --remotes

    ##? Alias for 'outgoing-all-branches'.
    out-all = outgoing-all-branches

    ##? Usage: git compare-remote-branch-log [BRANCH_NAME]
    ##?
    ##? Show a visual comparison of the local branch against its remote
    ##? counterpart.
    compare-remote-branch-log = "!f() { \
        git log --cherry-pick --left-right --graph \"$1\"...$(git origin)/\"$1\"; \
    }; f"

    ##? Alias for 'compare-remote-branch-log'.
    in-out = compare-remote-branch-log

    ##? Usage: git sha1-name COMMIT...
    ##?
    ##? Show the name of the closest reference (branch or tag) name for a given
    ##? commit.
    sha1-name = "!f() { \
        git name-rev --name-only \"$@\"; \
    }; f"

    ##? Alias for 'sha1-name'.
    commit-ref = sha1-name

    # Apply a patch to files and/or to the index from URL.
    apply-url = "!f() { \
        curl -s \"$1\" 2>nul \
            | git apply ${@:2}; \
    }; f"

    # Apply a series of patches from an URL.
    am-url = "!f() { \
        curl -s \"$1\" 2>nul \
            | git am ${@:2}; \
    }; f"

    # Interactive apply patch.
    ipatch = "!f() { \
        git apply \"$1\"; \
        git add -p; \
    }; f"

    ##? Usage: git trace GIT_COMMAND
    ##?
    ##? Enable comprehensive Git trace logging for debugging purposes.
    trace = "!f() { \
        set -x; \
        GIT_TRACE=2 \
        GIT_CURL_VERBOSE=2 \
        GIT_TRACE_PERFORMANCE=2 \
        GIT_TRACE_PACK_ACCESS=2 \
        GIT_TRACE_PACKET=2 \
        GIT_TRACE_PACKFILE=2 \
        GIT_TRACE_SETUP=2 \
        GIT_TRACE_SHALLOW=2 \
        git \"$@\"; \
    }; f"

    ##? Usage: git dangling-commits
    ##?
    ##? List dangling commits with simplified output (SHA-1 and message).
    dangling-commits = "!git fsck \
            | awk '/dangling commit/ {print $3}' \
            | git show --format='SHA-1: %C(yellow)%h%C(reset)  %s' --stdin \
            | awk '/SHA-1/ {sub(\"SHA-1: \", \"\"); print}'"
