#!/usr/bin/env bash
remotes="$@";
if [ -z "$remotes" ]; then
    remotes=$(git remote);
fi
remotes=$(echo "$remotes" | xargs -n 1 echo)

CLB=$(git branch -l | awk '/^\*/{print $2}');

echo "$remotes" | while read remote; do
    git remote update --prune $remote
    echo
    git remote show $remote -n \
        | awk '/merges with remote/ {print $5" "$1}' \
        | while read LINE; do
              RB=$(echo "$LINE" | cut -f1 -d" ");
              ARB="refs/remotes/$remote/$RB";
              LB=$(echo "$LINE" | cut -f2 -d" ");
              ALB="refs/heads/$LB";
              NBEHIND=$(( $(git rev-list --count $ALB..$ARB 2> /dev/null) + 0));
              NAHEAD=$(( $(git rev-list --count $ARB..$ALB 2> /dev/null) + 0));
              if [ "$NBEHIND" -gt 0 ]; then
                  if [ "$NAHEAD" -gt 0 ]; then
                      echo -e "[$LB is $NBEHIND commit(s) behind and $NAHEAD commit(s) ahead of $remote/$RB.]  Not possible to fast-forward, aborting.";
                  elif [ "$LB" = "$CLB" ]; then
                      echo -e "[$LB is $NBEHIND commit(s) behind of $remote/$RB.  Fast-forwarding merge...]";
                      # git merge --quiet $ARB;
                      git merge --ff-only --verbose $ARB;
                  else
                      echo -e "[$LB is $NBEHIND commit(s) behind of $remote/$RB.  Resetting local branch to remote...]";
                      # git branch -l -f $LB -t $ARB > /dev/null;
                      git branch -l -f $LB -t $ARB;
                  fi
              else
                  echo -e "$LB is already up to date.";
              fi
              echo
          done
done
