#!/usr/bin/env bash

# Pull the latest changes for each Git repository found in the current directory.

# Find all Git repositories recursively and sort them alphabetically.
find . -type d -name ".git" | sort | while read -r repo; do
    repo_dir=$(dirname "$repo")
    repo_name=$(basename "$repo_dir")
    printf "\nPulling latest changes for repository '%s'...\n" "$(tput bold)$repo_name$(tput sgr0)"
    if ! output=$(git -C "$repo_dir" pull 2>&1); then
        printf "$(tput setaf 1)$(tput bold)%s$(tput sgr0)\n" "$output"
    else
        printf "$(tput setaf 2)%s$(tput sgr0)\n" "$output"
    fi
done




# #!/usr/bin/env bash
#
# # Pull the latest changes for each Git repository found in the current directory.
#
# # Find all Git repositories recursively and sort them alphabetically.
# find . -type d -name ".git" | sort | while read -r repo; do
#     repo_dir=$(dirname "$repo")
#     repo_name=$(basename "$repo_dir")
#     printf "\nPulling latest changes for repository '%s'...\n" "$(tput bold)$repo_name$(tput sgr0)"
#
#     # Fetch changes from remote.
#     printf "Fetching changes...\n"
#     if ! git -C "$repo_dir" fetch --quiet; then
#         printf "$(tput setaf 1)$(tput bold)Failed to fetch changes. Skipping.$(tput sgr0)\n"
#         continue
#     fi
#
#     # Check if there are changes to pull.
#     if git -C "$repo_dir" status -uno | grep -q 'Your branch is behind'; then
#         # Pull changes from remote.
#         printf "Pulling changes from remote...\n"
#         if ! output=$(git -C "$repo_dir" pull --ff-only); then
#             printf "$(tput setaf 1)$(tput bold)%s$(tput sgr0)\n" "$output"
#         else
#             printf "$(tput setaf 2)Successfully pulled changes.$(tput sgr0)\n"
#         fi
#     else
#         printf "$(tput setaf 2)Already up-to-date.$(tput sgr0)\n"
#     fi
# done
