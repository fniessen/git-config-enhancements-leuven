# Hey Emacs, this is a -*- sh -*- file ...
# NOTE: This file is meant to be sourced (e.g. from .bashrc or .zshrc)

# BSD sysexits.h codes.
EX_USAGE=64                             # Command-line usage error.
EX_UNAVAILABLE=69                       # Service unavailable.

# Check if 'git' command is available.
if ! command -v git > /dev/null 2>&1; then
    printf >&2 "ERROR: 'git' is not installed. Please install it.\n"
    return $EX_UNAVAILABLE
fi

# Set 'g' as an alias for 'git'.
alias g=git

# Check if 'zip' command is available.
if ! command -v zip > /dev/null 2>&1; then
    printf >&2 "ERROR: 'zip' is not installed. Please install it.\n"
fi

# Go to the root of your Git repository.
alias cdroot='git rev-parse && cd "$(git rev-parse --show-toplevel)"'

# Exclude .git directories/files from grep results.
alias ng="grep -v '\.git/'"             # "No Git".

# Function to iterate over commit hashes and execute a given Git command.
#
# Example:
#   git-iterate-commits changed-files
#                                 Call the 'git-iterate-commits' function with the
#                                 'changed-files' Git command.
git-iterate-commits() {
    local git_command="$1"

    # Get the previous shell command dynamically.
    local previous_command=$(fc -ln -1)
    previous_command="${previous_command##+([[:space:]])}"

    # Define color and formatting variables using ANSI escape codes.
    local reset=$'\e[0m'
    local bold=$'\e[1m'
    local gray=$'\e[90m'                # Bright black = gray.
    local orange=$'\e[38;5;208m'        # Extended color (xterm 256-color orange).

    # Display the last executed command for debug purposes.
    printf "Last executed command: ${bold}%s${reset}\n" "$previous_command"

    # Execute the previous command and loop through its output line by line,
    # processing each line immediately.
    eval "$previous_command" | while IFS= read -r line; do
        # Display the current line being processed for debug purposes in gray.
        printf "\n${gray}# %s${reset}\n" "$line"

        # Extract the commit hash from the line.
        commit_hash=$(echo "$line" | awk '{print $2}')

        # Check if commit_hash is a valid hash (7 or more hexadecimal characters).
        if [[ ! "$commit_hash" =~ ^[0-9a-fA-F]{7,}$ ]]; then
            # Print message in orange.
            printf "${orange}Skipping invalid commit hash: %s${reset}\n" \
                   "$commit_hash"
            continue
        fi

        # Execute the provided Git command with the commit hash.
        git "$git_command" "$commit_hash" \
            || printf >&2 "ERROR: Failed to execute 'git %s %s'\n" "$git_command" "$commit_hash"
    done
}

# Check if 'tig' command is installed.
if command -v tig > /dev/null 2>&1; then
    # Aliases for 'tig' commands.
    alias tigs='tig status'             # Use it all of the time!
    alias tigb='tig blame'
    alias tigall='tig --all'
    alias tigreleases='tig --all --simplify-by-decoration'
fi
