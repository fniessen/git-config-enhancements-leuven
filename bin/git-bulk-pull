#!/usr/bin/env bash

bold=$(tput bold)
reset=$(tput sgr0)

printf 'Update Git repositories in all subdirectories...\n'

# Check and fix the permissions on ~/.ssh/config.
if [[ $(stat -c %a ~/.ssh/config) != 600 ]]; then
    printf 'Bad permissions on ~/.ssh/config. Fixing it...\n'
    chmod 600 ~/.ssh/config
fi

printf 'Searching at most 5 levels of directories...\n'

# Handle directories with spaces in the find command.
find . -maxdepth 5 -name '.git' -type d -print0 | xargs -0 -I {} dirname {} | sed 's#^./##' |
    while IFS=$'\n' read -r repo; do
        printf 'Updating repository %s:\n' "${bold}$repo${reset}"
        git -C "$repo" remote update --prune # Delete old branches.
        git -C "$repo" merge --ff-only "@{u}" # Only merge the current branch.
        printf '\n'
    done

# find . -name .git -type d \
#     | xargs -n1 -P4 -I% git --git-dir=% --work-tree=%/.. remote update -p
# Using -type d prevents execution for ".git" files inside submodules. Using -P4
# runs four fetches in parallel to speed things up a bit (and continues to make
# progress elsewhere if a single repository hangs). I prefer git remote update -p
# instead of git pull so that I can deal with merge conflicts later or rebase
# after I'm offline.




# Git repositories all have HEAD, refs, objects and config entries.
# on GNU/anything,
#
# find -name HEAD -execdir test -e refs -a -e objects -a -e config \; -printf %h\\n
#
# Just checking for .git will miss many bare repos and all submodules.
#
# this should be the accepted answer: only solution that also works for bare repos also
