#!/usr/bin/env bash

# Push the latest changes for each Git repository found in the current directory.

# Define color and formatting variables using ANSI escape codes.
RESET=$'\e[0m'
BOLD=$'\e[1m'
RED=$'\e[31m'
GREEN=$'\e[32m'
YELLOW=$'\e[33m'
BLUE=$'\e[34m'
MAGENTA=$'\e[35m'
CYAN=$'\e[36m'
WHITE=$'\e[37m'
BGRED=$'\e[41m'
ERROR="${BOLD}${WHITE}${BGRED}"
WARN="${YELLOW}"

# Find all Git repositories under the current directory, using -prune to optimize search.
# NOTE: Redirect stderr to /dev/null to avoid 'permission denied' errors.
mapfile -t repos < <(find . -type d -name ".git" -prune 2> /dev/null | sort -V)

if [[ ${#repos[@]} -eq 0 ]]; then
    printf "%sNo Git repositories found.%s\n" "${WARN}" "${RESET}"
    exit 0
fi

for repo in "${repos[@]}"; do
    repo_dir=$(dirname "$repo")
    [[ -r "$repo_dir" ]] || continue
    # Get the repository name using Git's root path (more reliable than basename).
    repo_name=$(git -C "$repo_dir" rev-parse --show-toplevel 2> /dev/null | xargs basename)
    printf "\n%sâ–² Pushing latest changes for repository '%s'...%s\n" "${BOLD}${MAGENTA}" "$repo_name" "${RESET}"

    # Push changes with a timeout of 30 seconds.
    output=$(timeout 30 git -C "$repo_dir" push 2>&1)
    exit_code=$?

    case $exit_code in
        0)
            printf "%s%s%s\n" "${GREEN}" "$output" "${RESET}" | sed 's/^/        /'
            ;;
        124)
            printf "%s%s%s\n" "${ERROR}" "Timed out while pushing to repository '$repo_name'" "${RESET}" | sed 's/^/        /'
            ;;
        *)
            printf "%s%s%s\n" "${ERROR}" "$output" "${RESET}" | sed 's/^/        /'
            ;;
    esac

    # Show modified files, if any.
    modified_files=$(git -C "$repo_dir" -c color.status=always status --short)
    if [[ -n "$modified_files" ]]; then
        printf "Modified files:\n%s\n" "$modified_files" | sed 's/^/        /'
    fi
done
